const __vite__mapDeps = (i, m = __vite__mapDeps, d = (m.f || (m.f = ["assets/Index-BxiFpJdy.js", "assets/client-DVrblGvH.js", "assets/hook-Dy1HR1NH.js", "assets/ChatGlobe-CCBGmKg_.js", "assets/clsx-B-dksMZM.js", "assets/maths-BcBSyK5V.js", "assets/Globe-BI52bYoy.js", "assets/Video-BBuaToM0.js", "assets/Globe-DBFxODgR.css", "assets/Button-B2cWWBb2.js", "assets/ChatGlobe-cBNqBshC.css", "assets/KeyNumber-DYZRPPR3.js", "assets/NavigationBar-D0Oz531L.js", "assets/chevron-right-rLNBw_Rz.js", "assets/NavigationBar-DP42ApKB.css", "assets/logo-no-text-DP6lopeL.js", "assets/KeyNumber-Dvw32GBz.css", "assets/Timeline-DenWUXG4.js", "assets/php_de-BQ7JcKcq.js", "assets/php_en-BEWIHNMz.js", "assets/php_es-N-rQexfv.js", "assets/php_et-CgC_YEx0.js", "assets/php_fr-D5uL_cPI.js", "assets/php_it-OO3BVlk-.js", "assets/php_nl-CLBq2UJu.js", "assets/index-B3wK0VMZ.js", "assets/meta-Ctg1RHBe.js", "assets/moment--fyrORtG.js", "assets/Timeline-py2tn3TN.css", "assets/Vision-ykAEJzlT.js", "assets/Vision-BL2VFKMe.css", "assets/NewsListing-BI1tBC0S.js", "assets/ItemCard-Cd6z31fw.js", "assets/ItemCard-Cv6t3285.css", "assets/NewsListing-DwxihF-z.css", "assets/Index-C4VElQ9X.css", "assets/Index-Bc3r_PC5.js", "assets/Browse-1ilp7uQk.js", "assets/Browse-Ci8Ctb8p.css", "assets/PageNavBar-BS-9IWjI.js", "assets/PageNavBar-BSchdT_i.css", "assets/SearchBar-Jh02c-9o.js", "assets/SearchBar-BJjy5sWg.css", "assets/useFilters-CBPD8AIK.js", "assets/useFilters--fbAyoV2.css", "assets/innerHtml-CEPnmf3L.js", "assets/Index-jio6N8xQ.css", "assets/Recruitment-NDge1QAe.js", "assets/JobProcess-Cr9hsEdo.js", "assets/JobProcess-BqM_whLM.css", "assets/JobsRoles-B528G8kh.js", "assets/JobsRoles-B1NoJLxu.css", "assets/Recruitment-CS-rqfDf.css", "assets/Single-RMu6RNvg.js", "assets/OtherJobs-CcvfsEnV.js", "assets/ListingGrid-BtFhYkKY.js", "assets/ListingGrid-Di18kZ0U.css", "assets/Single-CkP4ARoY.css", "assets/Index-BsLmuUkW.js", "assets/ContactForm-CAlW6kkj.js", "assets/check-Cj21-9MX.js", "assets/check-8T5nlz4n.css", "assets/ContactForm-BRkdqDCE.css", "assets/ContactOffices-DhYO_XEA.js", "assets/ContactOffices-D6Pf6t9t.css", "assets/Index-ZxBscQTX.css", "assets/Single-CM0zR9Qk.js", "assets/EventForm-CfQJCPC9.js", "assets/EventForm-C-ElSYIv.css", "assets/Guests-WMGdaDfz.js", "assets/Guests-DZwzk83m.css", "assets/MediasGallery-Dlw_58fQ.js", "assets/MediasGallery-BOt6lIlF.css", "assets/Partners-CS4TQwxV.js", "assets/index-EUNgdn7F.js", "assets/Partners-0tyHfWeW.css", "assets/HeroNews-BOgEoWtr.js", "assets/HeroNews-GiTTAacr.css", "assets/LatestNews-B1hDNSTx.js", "assets/Single-CEjZl_3I.css", "assets/Index-BeFiUfOT.js", "assets/HeroHome-DqrOOAs-.js", "assets/HeroHome-BRsV3zlB.css", "assets/KeyNumbersHome-B7tiPzhO.js", "assets/KeyNumbersHome-DoPMhX0S.css", "assets/UseCasesListing-CsM1ixH8.js", "assets/UseCasesListing-CmNbZw7i.css", "assets/Values-DYz5ZrGZ.js", "assets/Values-OqvUctEO.css", "assets/Index-io7WF6nX.css", "assets/DataPrivacy-MplkL4mZ.js", "assets/Layout-Dv-Tapsq.js", "assets/HeroSimple-D6CSq5jY.js", "assets/HeroSimple-BrKNQ4Xj.css", "assets/Layout-KnhQP82N.css", "assets/LegalNotices-DeRJUZXx.js", "assets/PrivacyPolicy-DKhr23rS.js", "assets/SampleWithdrawalForm-mHSBWKZn.js", "assets/Sale-D-kzARLG.js", "assets/Use-D-kzARLG.js", "assets/Index-B9rfX-Ay.js", "assets/Index-DOPonqw7.css", "assets/Single-CwvffSAa.js", "assets/CaseStudyOffersList-BokDQuow.js", "assets/AnimatedImage-BUnhYUfO.js", "assets/utils-D1OA0j0r.js", "assets/Card-C9uJfXap.js", "assets/Card-C0bXSgz4.css", "assets/CaseStudyOffersList-WOICwQUd.css", "assets/Single-nJni1QKX.css", "assets/Index-Bm-ae8Uv.js", "assets/OfferCategory-DAnEQupo.js", "assets/OfferCategory-B4OcQWO6.css", "assets/Index-DEbD31So.css", "assets/Single-CDVdRrM4.js", "assets/CaseStudySideBar-YZCRy8vG.js", "assets/CaseStudySideBar-ctlEHeyS.css", "assets/Methodology-CVGhRYv3.js", "assets/Methodology-GSgkjCAt.css", "assets/Single-CBjdXL-L.css", "assets/Index-DfPqyTSm.js", "assets/Index-CSPklTS7.css", "assets/Research-Eu99NAey.js", "assets/ResearchContent-DS_5BWPo.js", "assets/ResearchContent-C0f5LFFf.css", "assets/ResearchLinks-DEjc8Ybg.js", "assets/ResearchLinks-CE8D_lAl.css", "assets/Research-B2oTu5BT.css", "assets/Index-BWKH0T0u.js", "assets/Index-COQZs_ow.css", "assets/Single-Cv--2wTM.js", "assets/Quote-Zh4nVDVR.js", "assets/Quote-Bf9S3iNq.css", "assets/Single-C1ZqBMlg.css", "assets/Index-CkHLZKhE.js", "assets/Index-DlhpFQqr.css"]))) => i.map(i => d[i]);
var zu = Object.defineProperty;
var Vu = (n, e, t) => e in n ? zu(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t;
var zt = (n, e, t) => Vu(n, typeof e != "symbol" ? e + "" : e, t);
import {
    r as c,
    g as Wu,
    R as W,
    a as jn,
    j as $,
    c as Qn,
    b as Ar,
    K as Tn,
    $ as _t,
    S as Cr,
    d as Hu,
    e as Uu,
    _ as fe,
    f as Gu,
    L as Xu
} from "./client-DVrblGvH.js";
import {
    _ as qu
} from "./php_de-BQ7JcKcq.js";
import {
    _ as Yu
} from "./php_en-BEWIHNMz.js";
import {
    _ as Zu
} from "./php_es-N-rQexfv.js";
import {
    _ as Ju
} from "./php_et-CgC_YEx0.js";
import {
    _ as Qu
} from "./php_fr-D5uL_cPI.js";
import {
    _ as ec
} from "./php_it-OO3BVlk-.js";
import {
    _ as tc
} from "./php_nl-CLBq2UJu.js";
import {
    g as Me,
    f as nc
} from "./maths-BcBSyK5V.js";
import {
    S as kn,
    u as Cs,
    m as rc,
    V as bo,
    a as cn,
    E as Mn
} from "./Video-BBuaToM0.js";
import {
    c as Ge
} from "./clsx-B-dksMZM.js";
import {
    s as xs
} from "./index-B3wK0VMZ.js";
import {
    M as ic
} from "./meta-Ctg1RHBe.js";
import {
    u as er
} from "./hook-Dy1HR1NH.js";
import {
    h as oc
} from "./moment--fyrORtG.js";
const sc = () => {
    const n = document.querySelectorAll("[data-animation]"),
        e = [];
    return n.forEach(t => {
        const r = t.getAttribute("data-animation");
        if (r) {
            const i = t.getAttribute("data-delay"),
                o = Me.timeline({
                    delay: i ? parseFloat(i) : 0,
                    paused: !0
                });
            r === "fade" && o.to(t, {
                opacity: 1,
                duration: 1
            }, 0);
            const s = kn.ScrollTrigger.create({
                trigger: t,
                animation: o,
                toggleActions: "play complete none none"
            });
            s && e.push(s)
        }
    }), () => {
        e.forEach(t => t && t.kill())
    }
};
var yo = typeof window < "u" && new class {
    constructor() {
        this.raf = n => {
            requestAnimationFrame(this.raf);
            const e = n - this.now;
            this.now = n;
            for (let t = 0; t < this.callbacks.length; t++) this.callbacks[t].callback(n, e)
        }, this.callbacks = [], this.now = performance.now(), requestAnimationFrame(this.raf)
    }
    add(n, e = 0) {
        return this.callbacks.push({
            callback: n,
            priority: e
        }), this.callbacks.sort((t, r) => t.priority - r.priority), () => this.remove(n)
    }
    remove(n) {
        this.callbacks = this.callbacks.filter(({
            callback: e
        }) => n !== e)
    }
};

function lc(n, e = 0) {
    c.useEffect(() => {
        if (n) return yo.add(n, e), () => yo.remove(n)
    }, [n, e])
}

function $s(n, e, t) {
    return Math.max(n, Math.min(e, t))
}
class ac {
    advance(e) {
        var l;
        if (!this.isRunning) return;
        let t = !1;
        if (this.lerp) this.value = (r = this.value, i = this.to, o = 60 * this.lerp, s = e, function(a, u, d) {
            return (1 - d) * a + d * u
        }(r, i, 1 - Math.exp(-o * s))), Math.round(this.value) === this.to && (this.value = this.to, t = !0);
        else {
            this.currentTime += e;
            const a = $s(0, this.currentTime / this.duration, 1);
            t = a >= 1;
            const u = t ? 1 : this.easing(a);
            this.value = this.from + (this.to - this.from) * u
        }
        var r, i, o, s;
        (l = this.onUpdate) == null || l.call(this, this.value, t), t && this.stop()
    }
    stop() {
        this.isRunning = !1
    }
    fromTo(e, t, {
        lerp: r = .1,
        duration: i = 1,
        easing: o = a => a,
        onStart: s,
        onUpdate: l
    }) {
        this.from = this.value = e, this.to = t, this.lerp = r, this.duration = i, this.easing = o, this.currentTime = 0, this.isRunning = !0, s == null || s(), this.onUpdate = l
    }
}
class uc {
    constructor({
        wrapper: e,
        content: t,
        autoResize: r = !0,
        debounce: i = 250
    } = {}) {
        zt(this, "resize", () => {
            this.onWrapperResize(), this.onContentResize()
        });
        zt(this, "onWrapperResize", () => {
            this.wrapper === window ? (this.width = window.innerWidth, this.height = window.innerHeight) : (this.width = this.wrapper.clientWidth, this.height = this.wrapper.clientHeight)
        });
        zt(this, "onContentResize", () => {
            this.wrapper === window ? (this.scrollHeight = this.content.scrollHeight, this.scrollWidth = this.content.scrollWidth) : (this.scrollHeight = this.wrapper.scrollHeight, this.scrollWidth = this.wrapper.scrollWidth)
        });
        this.wrapper = e, this.content = t, r && (this.debouncedResize = function(o, s) {
            let l;
            return function() {
                let a = arguments,
                    u = this;
                clearTimeout(l), l = setTimeout(function() {
                    o.apply(u, a)
                }, s)
            }
        }(this.resize, i), this.wrapper === window ? window.addEventListener("resize", this.debouncedResize, !1) : (this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize), this.wrapperResizeObserver.observe(this.wrapper)), this.contentResizeObserver = new ResizeObserver(this.debouncedResize), this.contentResizeObserver.observe(this.content)), this.resize()
    }
    destroy() {
        var e, t;
        (e = this.wrapperResizeObserver) == null || e.disconnect(), (t = this.contentResizeObserver) == null || t.disconnect(), window.removeEventListener("resize", this.debouncedResize, !1)
    }
    get limit() {
        return {
            x: this.scrollWidth - this.width,
            y: this.scrollHeight - this.height
        }
    }
}
class ws {
    constructor() {
        this.events = {}
    }
    emit(e, ...t) {
        let r = this.events[e] || [];
        for (let i = 0, o = r.length; i < o; i++) r[i](...t)
    }
    on(e, t) {
        var r;
        return (r = this.events[e]) != null && r.push(t) || (this.events[e] = [t]), () => {
            var i;
            this.events[e] = (i = this.events[e]) == null ? void 0 : i.filter(o => t !== o)
        }
    }
    off(e, t) {
        var r;
        this.events[e] = (r = this.events[e]) == null ? void 0 : r.filter(i => t !== i)
    }
    destroy() {
        this.events = {}
    }
}
const Eo = 100 / 6;
class cc {
    constructor(e, {
        wheelMultiplier: t = 1,
        touchMultiplier: r = 1
    }) {
        zt(this, "onTouchStart", e => {
            const {
                clientX: t,
                clientY: r
            } = e.targetTouches ? e.targetTouches[0] : e;
            this.touchStart.x = t, this.touchStart.y = r, this.lastDelta = {
                x: 0,
                y: 0
            }, this.emitter.emit("scroll", {
                deltaX: 0,
                deltaY: 0,
                event: e
            })
        });
        zt(this, "onTouchMove", e => {
            const {
                clientX: t,
                clientY: r
            } = e.targetTouches ? e.targetTouches[0] : e, i = -(t - this.touchStart.x) * this.touchMultiplier, o = -(r - this.touchStart.y) * this.touchMultiplier;
            this.touchStart.x = t, this.touchStart.y = r, this.lastDelta = {
                x: i,
                y: o
            }, this.emitter.emit("scroll", {
                deltaX: i,
                deltaY: o,
                event: e
            })
        });
        zt(this, "onTouchEnd", e => {
            this.emitter.emit("scroll", {
                deltaX: this.lastDelta.x,
                deltaY: this.lastDelta.y,
                event: e
            })
        });
        zt(this, "onWheel", e => {
            let {
                deltaX: t,
                deltaY: r,
                deltaMode: i
            } = e;
            t *= i === 1 ? Eo : i === 2 ? this.windowWidth : 1, r *= i === 1 ? Eo : i === 2 ? this.windowHeight : 1, t *= this.wheelMultiplier, r *= this.wheelMultiplier, this.emitter.emit("scroll", {
                deltaX: t,
                deltaY: r,
                event: e
            })
        });
        zt(this, "onWindowResize", () => {
            this.windowWidth = window.innerWidth, this.windowHeight = window.innerHeight
        });
        this.element = e, this.wheelMultiplier = t, this.touchMultiplier = r, this.touchStart = {
            x: null,
            y: null
        }, this.emitter = new ws, window.addEventListener("resize", this.onWindowResize, !1), this.onWindowResize(), this.element.addEventListener("wheel", this.onWheel, {
            passive: !1
        }), this.element.addEventListener("touchstart", this.onTouchStart, {
            passive: !1
        }), this.element.addEventListener("touchmove", this.onTouchMove, {
            passive: !1
        }), this.element.addEventListener("touchend", this.onTouchEnd, {
            passive: !1
        })
    }
    on(e, t) {
        return this.emitter.on(e, t)
    }
    destroy() {
        this.emitter.destroy(), window.removeEventListener("resize", this.onWindowResize, !1), this.element.removeEventListener("wheel", this.onWheel, {
            passive: !1
        }), this.element.removeEventListener("touchstart", this.onTouchStart, {
            passive: !1
        }), this.element.removeEventListener("touchmove", this.onTouchMove, {
            passive: !1
        }), this.element.removeEventListener("touchend", this.onTouchEnd, {
            passive: !1
        })
    }
}
class dc {
    constructor({
        wrapper: e = window,
        content: t = document.documentElement,
        wheelEventsTarget: r = e,
        eventsTarget: i = r,
        smoothWheel: o = !0,
        syncTouch: s = !1,
        syncTouchLerp: l = .075,
        touchInertiaMultiplier: a = 35,
        duration: u,
        easing: d = S => Math.min(1, 1.001 - Math.pow(2, -10 * S)),
        lerp: h = !u && .1,
        infinite: D = !1,
        orientation: g = "vertical",
        gestureOrientation: x = "vertical",
        touchMultiplier: P = 1,
        wheelMultiplier: L = 1,
        autoResize: R = !0,
        __experimental__naiveDimensions: N = !1
    } = {}) {
        this.__isSmooth = !1, this.__isScrolling = !1, this.__isStopped = !1, this.__isLocked = !1, this.onVirtualScroll = ({
            deltaX: S,
            deltaY: j,
            event: k
        }) => {
            if (k.ctrlKey) return;
            const B = k.type.includes("touch"),
                M = k.type.includes("wheel");
            if (this.options.syncTouch && B && k.type === "touchstart" && !this.isStopped && !this.isLocked) return void this.reset();
            const f = S === 0 && j === 0,
                I = this.options.gestureOrientation === "vertical" && j === 0 || this.options.gestureOrientation === "horizontal" && S === 0;
            if (f || I) return;
            let O = k.composedPath();
            if (O = O.slice(0, O.indexOf(this.rootElement)), O.find(p => {
                    var w, C, A, E, H;
                    return ((w = p.hasAttribute) === null || w === void 0 ? void 0 : w.call(p, "data-lenis-prevent")) || B && ((C = p.hasAttribute) === null || C === void 0 ? void 0 : C.call(p, "data-lenis-prevent-touch")) || M && ((A = p.hasAttribute) === null || A === void 0 ? void 0 : A.call(p, "data-lenis-prevent-wheel")) || ((E = p.classList) === null || E === void 0 ? void 0 : E.contains("lenis")) && !(!((H = p.classList) === null || H === void 0) && H.contains("lenis-stopped"))
                })) return;
            if (this.isStopped || this.isLocked) return void k.preventDefault();
            if (this.isSmooth = this.options.syncTouch && B || this.options.smoothWheel && M, !this.isSmooth) return this.isScrolling = !1, void this.animate.stop();
            k.preventDefault();
            let T = j;
            this.options.gestureOrientation === "both" ? T = Math.abs(j) > Math.abs(S) ? j : S : this.options.gestureOrientation === "horizontal" && (T = S);
            const K = B && this.options.syncTouch,
                m = B && k.type === "touchend" && Math.abs(T) > 5;
            m && (T = this.velocity * this.options.touchInertiaMultiplier), this.scrollTo(this.targetScroll + T, Object.assign({
                programmatic: !1
            }, K ? {
                lerp: m ? this.options.syncTouchLerp : 1
            } : {
                lerp: this.options.lerp,
                duration: this.options.duration,
                easing: this.options.easing
            }))
        }, this.onNativeScroll = () => {
            if (!this.__preventNextScrollEvent && !this.isScrolling) {
                const S = this.animatedScroll;
                this.animatedScroll = this.targetScroll = this.actualScroll, this.velocity = 0, this.direction = Math.sign(this.animatedScroll - S), this.emit()
            }
        }, window.lenisVersion = "1.0.42", e !== document.documentElement && e !== document.body || (e = window), this.options = {
            wrapper: e,
            content: t,
            wheelEventsTarget: r,
            eventsTarget: i,
            smoothWheel: o,
            syncTouch: s,
            syncTouchLerp: l,
            touchInertiaMultiplier: a,
            duration: u,
            easing: d,
            lerp: h,
            infinite: D,
            gestureOrientation: x,
            orientation: g,
            touchMultiplier: P,
            wheelMultiplier: L,
            autoResize: R,
            __experimental__naiveDimensions: N
        }, this.animate = new ac, this.emitter = new ws, this.dimensions = new uc({
            wrapper: e,
            content: t,
            autoResize: R
        }), this.toggleClassName("lenis", !0), this.velocity = 0, this.isLocked = !1, this.isStopped = !1, this.isSmooth = s || o, this.isScrolling = !1, this.targetScroll = this.animatedScroll = this.actualScroll, this.options.wrapper.addEventListener("scroll", this.onNativeScroll, !1), this.virtualScroll = new cc(i, {
            touchMultiplier: P,
            wheelMultiplier: L
        }), this.virtualScroll.on("scroll", this.onVirtualScroll)
    }
    destroy() {
        this.emitter.destroy(), this.options.wrapper.removeEventListener("scroll", this.onNativeScroll, !1), this.virtualScroll.destroy(), this.dimensions.destroy(), this.toggleClassName("lenis", !1), this.toggleClassName("lenis-smooth", !1), this.toggleClassName("lenis-scrolling", !1), this.toggleClassName("lenis-stopped", !1), this.toggleClassName("lenis-locked", !1)
    }
    on(e, t) {
        return this.emitter.on(e, t)
    }
    off(e, t) {
        return this.emitter.off(e, t)
    }
    setScroll(e) {
        this.isHorizontal ? this.rootElement.scrollLeft = e : this.rootElement.scrollTop = e
    }
    resize() {
        this.dimensions.resize()
    }
    emit() {
        this.emitter.emit("scroll", this)
    }
    reset() {
        this.isLocked = !1, this.isScrolling = !1, this.animatedScroll = this.targetScroll = this.actualScroll, this.velocity = 0, this.animate.stop()
    }
    start() {
        this.isStopped && (this.isStopped = !1, this.reset())
    }
    stop() {
        this.isStopped || (this.isStopped = !0, this.animate.stop(), this.reset())
    }
    raf(e) {
        const t = e - (this.time || e);
        this.time = e, this.animate.advance(.001 * t)
    }
    scrollTo(e, {
        offset: t = 0,
        immediate: r = !1,
        lock: i = !1,
        duration: o = this.options.duration,
        easing: s = this.options.easing,
        lerp: l = !o && this.options.lerp,
        onComplete: a,
        force: u = !1,
        programmatic: d = !0
    } = {}) {
        if (!this.isStopped && !this.isLocked || u) {
            if (["top", "left", "start"].includes(e)) e = 0;
            else if (["bottom", "right", "end"].includes(e)) e = this.limit;
            else {
                let h;
                if (typeof e == "string" ? h = document.querySelector(e) : e != null && e.nodeType && (h = e), h) {
                    if (this.options.wrapper !== window) {
                        const g = this.options.wrapper.getBoundingClientRect();
                        t -= this.isHorizontal ? g.left : g.top
                    }
                    const D = h.getBoundingClientRect();
                    e = (this.isHorizontal ? D.left : D.top) + this.animatedScroll
                }
            }
            if (typeof e == "number") {
                if (e += t, e = Math.round(e), this.options.infinite ? d && (this.targetScroll = this.animatedScroll = this.scroll) : e = $s(0, e, this.limit), r) return this.animatedScroll = this.targetScroll = e, this.setScroll(this.scroll), this.reset(), void(a == null || a(this));
                if (!d) {
                    if (e === this.targetScroll) return;
                    this.targetScroll = e
                }
                this.animate.fromTo(this.animatedScroll, e, {
                    duration: o,
                    easing: s,
                    lerp: l,
                    onStart: () => {
                        i && (this.isLocked = !0), this.isScrolling = !0
                    },
                    onUpdate: (h, D) => {
                        this.isScrolling = !0, this.velocity = h - this.animatedScroll, this.direction = Math.sign(this.velocity), this.animatedScroll = h, this.setScroll(this.scroll), d && (this.targetScroll = h), D || this.emit(), D && (this.reset(), this.emit(), a == null || a(this), this.__preventNextScrollEvent = !0, requestAnimationFrame(() => {
                            delete this.__preventNextScrollEvent
                        }))
                    }
                })
            }
        }
    }
    get rootElement() {
        return this.options.wrapper === window ? document.documentElement : this.options.wrapper
    }
    get limit() {
        return this.options.__experimental__naiveDimensions ? this.isHorizontal ? this.rootElement.scrollWidth - this.rootElement.clientWidth : this.rootElement.scrollHeight - this.rootElement.clientHeight : this.dimensions.limit[this.isHorizontal ? "x" : "y"]
    }
    get isHorizontal() {
        return this.options.orientation === "horizontal"
    }
    get actualScroll() {
        return this.isHorizontal ? this.rootElement.scrollLeft : this.rootElement.scrollTop
    }
    get scroll() {
        return this.options.infinite ? (e = this.animatedScroll, t = this.limit, (e % t + t) % t) : this.animatedScroll;
        var e, t
    }
    get progress() {
        return this.limit === 0 ? 1 : this.scroll / this.limit
    }
    get isSmooth() {
        return this.__isSmooth
    }
    set isSmooth(e) {
        this.__isSmooth !== e && (this.__isSmooth = e, this.toggleClassName("lenis-smooth", e))
    }
    get isScrolling() {
        return this.__isScrolling
    }
    set isScrolling(e) {
        this.__isScrolling !== e && (this.__isScrolling = e, this.toggleClassName("lenis-scrolling", e))
    }
    get isStopped() {
        return this.__isStopped
    }
    set isStopped(e) {
        this.__isStopped !== e && (this.__isStopped = e, this.toggleClassName("lenis-stopped", e))
    }
    get isLocked() {
        return this.__isLocked
    }
    set isLocked(e) {
        this.__isLocked !== e && (this.__isLocked = e, this.toggleClassName("lenis-locked", e))
    }
    get className() {
        let e = "lenis";
        return this.isStopped && (e += " lenis-stopped"), this.isLocked && (e += " lenis-locked"), this.isScrolling && (e += " lenis-scrolling"), this.isSmooth && (e += " lenis-smooth"), e
    }
    toggleClassName(e, t) {
        this.rootElement.classList.toggle(e, t), this.emitter.emit("className change", this)
    }
}
const fc = {},
    Co = n => {
        let e;
        const t = new Set,
            r = (d, h) => {
                const D = typeof d == "function" ? d(e) : d;
                if (!Object.is(D, e)) {
                    const g = e;
                    e = h ? ? (typeof D != "object" || D === null) ? D : Object.assign({}, e, D), t.forEach(x => x(e, g))
                }
            },
            i = () => e,
            a = {
                setState: r,
                getState: i,
                getInitialState: () => u,
                subscribe: d => (t.add(d), () => t.delete(d)),
                destroy: () => {
                    (fc ? "production" : void 0) !== "production" && console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."), t.clear()
                }
            },
            u = e = n(r, i, a);
        return a
    },
    pc = n => n ? Co(n) : Co;
var Fs = {
        exports: {}
    },
    Ss = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Lr = c,
    hc = xs;

function Dc(n, e) {
    return n === e && (n !== 0 || 1 / n === 1 / e) || n !== n && e !== e
}
var vc = typeof Object.is == "function" ? Object.is : Dc,
    gc = hc.useSyncExternalStore,
    mc = Lr.useRef,
    bc = Lr.useEffect,
    yc = Lr.useMemo,
    Ec = Lr.useDebugValue;
Ss.useSyncExternalStoreWithSelector = function(n, e, t, r, i) {
    var o = mc(null);
    if (o.current === null) {
        var s = {
            hasValue: !1,
            value: null
        };
        o.current = s
    } else s = o.current;
    o = yc(function() {
        function a(g) {
            if (!u) {
                if (u = !0, d = g, g = r(g), i !== void 0 && s.hasValue) {
                    var x = s.value;
                    if (i(x, g)) return h = x
                }
                return h = g
            }
            if (x = h, vc(d, g)) return x;
            var P = r(g);
            return i !== void 0 && i(x, P) ? (d = g, x) : (d = g, h = P)
        }
        var u = !1,
            d, h, D = t === void 0 ? null : t;
        return [function() {
            return a(e())
        }, D === null ? void 0 : function() {
            return a(D())
        }]
    }, [e, t, r, i]);
    var l = gc(n, o[0], o[1]);
    return bc(function() {
        s.hasValue = !0, s.value = l
    }, [l]), Ec(l), l
};
Fs.exports = Ss;
var Cc = Fs.exports;
const xc = Wu(Cc),
    _s = {},
    {
        useDebugValue: $c
    } = W,
    {
        useSyncExternalStoreWithSelector: wc
    } = xc;
let xo = !1;
const Fc = n => n;

function Sc(n, e = Fc, t) {
    (_s ? "production" : void 0) !== "production" && t && !xo && (console.warn("[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"), xo = !0);
    const r = wc(n.subscribe, n.getState, n.getServerState || n.getInitialState, e, t);
    return $c(r), r
}
const $o = n => {
        (_s ? "production" : void 0) !== "production" && typeof n != "function" && console.warn("[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.");
        const e = typeof n == "function" ? pc(n) : n,
            t = (r, i) => Sc(e, r, i);
        return Object.assign(t, e), t
    },
    _c = n => n ? $o(n) : $o;
typeof window < "u" && (window.reactLenisVersion = "0.0.47");
const Ps = c.createContext(null),
    Ts = _c(() => ({}));

function tr(n, e = [], t = 0) {
    const {
        lenis: r,
        addCallback: i,
        removeCallback: o
    } = function() {
        const s = c.useContext(Ps),
            l = Ts();
        return s ? ? l
    }();
    return c.useEffect(() => {
        if (n && i && o && r) return i(n, t), n(r), () => {
            o(n)
        }
    }, [r, i, o, t, ...e]), r
}
const Pc = c.forwardRef((n, e) => {
    var {
        children: t,
        root: r = !1,
        options: i = {},
        autoRaf: o = !0,
        rafPriority: s = 0,
        className: l
    } = n, a = function(N, S) {
        var j = {};
        for (var k in N) Object.prototype.hasOwnProperty.call(N, k) && S.indexOf(k) < 0 && (j[k] = N[k]);
        if (N != null && typeof Object.getOwnPropertySymbols == "function") {
            var B = 0;
            for (k = Object.getOwnPropertySymbols(N); B < k.length; B++) S.indexOf(k[B]) < 0 && Object.prototype.propertyIsEnumerable.call(N, k[B]) && (j[k[B]] = N[k[B]])
        }
        return j
    }(n, ["children", "root", "options", "autoRaf", "rafPriority", "className"]);
    const u = c.useRef(null),
        d = c.useRef(null),
        [h, D] = c.useState(void 0),
        g = c.useRef([]),
        x = c.useCallback((N, S) => {
            g.current.push({
                callback: N,
                priority: S
            }), g.current.sort((j, k) => j.priority - k.priority)
        }, []),
        P = c.useCallback(N => {
            g.current = g.current.filter(S => S.callback !== N)
        }, []);
    c.useImperativeHandle(e, () => ({
        wrapper: u.current,
        content: d.current,
        lenis: h
    }), [h]), c.useEffect(() => {
        const N = new dc(Object.assign(Object.assign({}, i), !r && {
            wrapper: u.current,
            content: d.current
        }));
        return D(N), () => {
            N.destroy(), D(void 0)
        }
    }, [r, JSON.stringify(i)]), lc(N => {
        o && (h == null || h.raf(N))
    }, s), c.useEffect(() => {
        r && h && Ts.setState({
            lenis: h,
            addCallback: x,
            removeCallback: P
        })
    }, [r, h, x, P]);
    const L = c.useCallback(N => {
        for (let S = 0; S < g.current.length; S++) g.current[S].callback(N)
    }, []);
    c.useEffect(() => (h == null || h.on("scroll", L), () => {
        h == null || h.off("scroll", L)
    }), [h, L]);
    const R = c.useCallback(() => {
        u.current && (u.current.className = Ge(h == null ? void 0 : h.className, l))
    }, [h, l]);
    return c.useEffect(() => (R(), h == null || h.on("className change", R), () => {
        h == null || h.off("className change", R)
    }), [h, R]), W.createElement(Ps.Provider, {
        value: {
            lenis: h,
            addCallback: x,
            removeCallback: P
        }
    }, r ? t : W.createElement("div", Object.assign({
        ref: u,
        className: Ge(h == null ? void 0 : h.className, l)
    }, a), W.createElement("div", {
        ref: d
    }, t)))
});

function fi() {
    return fi = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var r in t)({}).hasOwnProperty.call(t, r) && (n[r] = t[r])
        }
        return n
    }, fi.apply(null, arguments)
}

function ks(n, e) {
    if (n == null) return {};
    var t = {};
    for (var r in n)
        if ({}.hasOwnProperty.call(n, r)) {
            if (e.indexOf(r) !== -1) continue;
            t[r] = n[r]
        }
    return t
}

function pi(n, e) {
    return pi = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, r) {
        return t.__proto__ = r, t
    }, pi(n, e)
}

function Ii(n, e) {
    n.prototype = Object.create(e.prototype), n.prototype.constructor = n, pi(n, e)
}

function Tc(n, e) {
    return n.classList ? !!e && n.classList.contains(e) : (" " + (n.className.baseVal || n.className) + " ").indexOf(" " + e + " ") !== -1
}

function kc(n, e) {
    n.classList ? n.classList.add(e) : Tc(n, e) || (typeof n.className == "string" ? n.className = n.className + " " + e : n.setAttribute("class", (n.className && n.className.baseVal || "") + " " + e))
}

function wo(n, e) {
    return n.replace(new RegExp("(^|\\s)" + e + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "")
}

function Ac(n, e) {
    n.classList ? n.classList.remove(e) : typeof n.className == "string" ? n.className = wo(n.className, e) : n.setAttribute("class", wo(n.className && n.className.baseVal || "", e))
}
const Fo = {
        disabled: !1
    },
    Ki = W.createContext(null);
var As = function(e) {
        return e.scrollTop
    },
    zn = "unmounted",
    fn = "exited",
    bt = "entering",
    Rt = "entered",
    Gn = "exiting",
    Et = function(n) {
        Ii(e, n);

        function e(r, i) {
            var o;
            o = n.call(this, r, i) || this;
            var s = i,
                l = s && !s.isMounting ? r.enter : r.appear,
                a;
            return o.appearStatus = null, r.in ? l ? (a = fn, o.appearStatus = bt) : a = Rt : r.unmountOnExit || r.mountOnEnter ? a = zn : a = fn, o.state = {
                status: a
            }, o.nextCallback = null, o
        }
        e.getDerivedStateFromProps = function(i, o) {
            var s = i.in;
            return s && o.status === zn ? {
                status: fn
            } : null
        };
        var t = e.prototype;
        return t.componentDidMount = function() {
            this.updateStatus(!0, this.appearStatus)
        }, t.componentDidUpdate = function(i) {
            var o = null;
            if (i !== this.props) {
                var s = this.state.status;
                this.props.in ? s !== bt && s !== Rt && (o = bt) : (s === bt || s === Rt) && (o = Gn)
            }
            this.updateStatus(!1, o)
        }, t.componentWillUnmount = function() {
            this.cancelNextCallback()
        }, t.getTimeouts = function() {
            var i = this.props.timeout,
                o, s, l;
            return o = s = l = i, i != null && typeof i != "number" && (o = i.exit, s = i.enter, l = i.appear !== void 0 ? i.appear : s), {
                exit: o,
                enter: s,
                appear: l
            }
        }, t.updateStatus = function(i, o) {
            if (i === void 0 && (i = !1), o !== null)
                if (this.cancelNextCallback(), o === bt) {
                    if (this.props.unmountOnExit || this.props.mountOnEnter) {
                        var s = this.props.nodeRef ? this.props.nodeRef.current : jn.findDOMNode(this);
                        s && As(s)
                    }
                    this.performEnter(i)
                } else this.performExit();
            else this.props.unmountOnExit && this.state.status === fn && this.setState({
                status: zn
            })
        }, t.performEnter = function(i) {
            var o = this,
                s = this.props.enter,
                l = this.context ? this.context.isMounting : i,
                a = this.props.nodeRef ? [l] : [jn.findDOMNode(this), l],
                u = a[0],
                d = a[1],
                h = this.getTimeouts(),
                D = l ? h.appear : h.enter;
            if (!i && !s || Fo.disabled) {
                this.safeSetState({
                    status: Rt
                }, function() {
                    o.props.onEntered(u)
                });
                return
            }
            this.props.onEnter(u, d), this.safeSetState({
                status: bt
            }, function() {
                o.props.onEntering(u, d), o.onTransitionEnd(D, function() {
                    o.safeSetState({
                        status: Rt
                    }, function() {
                        o.props.onEntered(u, d)
                    })
                })
            })
        }, t.performExit = function() {
            var i = this,
                o = this.props.exit,
                s = this.getTimeouts(),
                l = this.props.nodeRef ? void 0 : jn.findDOMNode(this);
            if (!o || Fo.disabled) {
                this.safeSetState({
                    status: fn
                }, function() {
                    i.props.onExited(l)
                });
                return
            }
            this.props.onExit(l), this.safeSetState({
                status: Gn
            }, function() {
                i.props.onExiting(l), i.onTransitionEnd(s.exit, function() {
                    i.safeSetState({
                        status: fn
                    }, function() {
                        i.props.onExited(l)
                    })
                })
            })
        }, t.cancelNextCallback = function() {
            this.nextCallback !== null && (this.nextCallback.cancel(), this.nextCallback = null)
        }, t.safeSetState = function(i, o) {
            o = this.setNextCallback(o), this.setState(i, o)
        }, t.setNextCallback = function(i) {
            var o = this,
                s = !0;
            return this.nextCallback = function(l) {
                s && (s = !1, o.nextCallback = null, i(l))
            }, this.nextCallback.cancel = function() {
                s = !1
            }, this.nextCallback
        }, t.onTransitionEnd = function(i, o) {
            this.setNextCallback(o);
            var s = this.props.nodeRef ? this.props.nodeRef.current : jn.findDOMNode(this),
                l = i == null && !this.props.addEndListener;
            if (!s || l) {
                setTimeout(this.nextCallback, 0);
                return
            }
            if (this.props.addEndListener) {
                var a = this.props.nodeRef ? [this.nextCallback] : [s, this.nextCallback],
                    u = a[0],
                    d = a[1];
                this.props.addEndListener(u, d)
            }
            i != null && setTimeout(this.nextCallback, i)
        }, t.render = function() {
            var i = this.state.status;
            if (i === zn) return null;
            var o = this.props,
                s = o.children;
            o.in, o.mountOnEnter, o.unmountOnExit, o.appear, o.enter, o.exit, o.timeout, o.addEndListener, o.onEnter, o.onEntering, o.onEntered, o.onExit, o.onExiting, o.onExited, o.nodeRef;
            var l = ks(o, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
            return W.createElement(Ki.Provider, {
                value: null
            }, typeof s == "function" ? s(i, l) : W.cloneElement(W.Children.only(s), l))
        }, e
    }(W.Component);
Et.contextType = Ki;
Et.propTypes = {};

function yn() {}
Et.defaultProps = { in: !1,
    mountOnEnter: !1,
    unmountOnExit: !1,
    appear: !1,
    enter: !0,
    exit: !0,
    onEnter: yn,
    onEntering: yn,
    onEntered: yn,
    onExit: yn,
    onExiting: yn,
    onExited: yn
};
Et.UNMOUNTED = zn;
Et.EXITED = fn;
Et.ENTERING = bt;
Et.ENTERED = Rt;
Et.EXITING = Gn;
var Lc = function(e, t) {
        return e && t && t.split(" ").forEach(function(r) {
            return kc(e, r)
        })
    },
    Zr = function(e, t) {
        return e && t && t.split(" ").forEach(function(r) {
            return Ac(e, r)
        })
    },
    Oi = function(n) {
        Ii(e, n);

        function e() {
            for (var r, i = arguments.length, o = new Array(i), s = 0; s < i; s++) o[s] = arguments[s];
            return r = n.call.apply(n, [this].concat(o)) || this, r.appliedClasses = {
                appear: {},
                enter: {},
                exit: {}
            }, r.onEnter = function(l, a) {
                var u = r.resolveArguments(l, a),
                    d = u[0],
                    h = u[1];
                r.removeClasses(d, "exit"), r.addClass(d, h ? "appear" : "enter", "base"), r.props.onEnter && r.props.onEnter(l, a)
            }, r.onEntering = function(l, a) {
                var u = r.resolveArguments(l, a),
                    d = u[0],
                    h = u[1],
                    D = h ? "appear" : "enter";
                r.addClass(d, D, "active"), r.props.onEntering && r.props.onEntering(l, a)
            }, r.onEntered = function(l, a) {
                var u = r.resolveArguments(l, a),
                    d = u[0],
                    h = u[1],
                    D = h ? "appear" : "enter";
                r.removeClasses(d, D), r.addClass(d, D, "done"), r.props.onEntered && r.props.onEntered(l, a)
            }, r.onExit = function(l) {
                var a = r.resolveArguments(l),
                    u = a[0];
                r.removeClasses(u, "appear"), r.removeClasses(u, "enter"), r.addClass(u, "exit", "base"), r.props.onExit && r.props.onExit(l)
            }, r.onExiting = function(l) {
                var a = r.resolveArguments(l),
                    u = a[0];
                r.addClass(u, "exit", "active"), r.props.onExiting && r.props.onExiting(l)
            }, r.onExited = function(l) {
                var a = r.resolveArguments(l),
                    u = a[0];
                r.removeClasses(u, "exit"), r.addClass(u, "exit", "done"), r.props.onExited && r.props.onExited(l)
            }, r.resolveArguments = function(l, a) {
                return r.props.nodeRef ? [r.props.nodeRef.current, l] : [l, a]
            }, r.getClassNames = function(l) {
                var a = r.props.classNames,
                    u = typeof a == "string",
                    d = u && a ? a + "-" : "",
                    h = u ? "" + d + l : a[l],
                    D = u ? h + "-active" : a[l + "Active"],
                    g = u ? h + "-done" : a[l + "Done"];
                return {
                    baseClassName: h,
                    activeClassName: D,
                    doneClassName: g
                }
            }, r
        }
        var t = e.prototype;
        return t.addClass = function(i, o, s) {
            var l = this.getClassNames(o)[s + "ClassName"],
                a = this.getClassNames("enter"),
                u = a.doneClassName;
            o === "appear" && s === "done" && u && (l += " " + u), s === "active" && i && As(i), l && (this.appliedClasses[o][s] = l, Lc(i, l))
        }, t.removeClasses = function(i, o) {
            var s = this.appliedClasses[o],
                l = s.base,
                a = s.active,
                u = s.done;
            this.appliedClasses[o] = {}, l && Zr(i, l), a && Zr(i, a), u && Zr(i, u)
        }, t.render = function() {
            var i = this.props;
            i.classNames;
            var o = ks(i, ["classNames"]);
            return W.createElement(Et, fi({}, o, {
                onEnter: this.onEnter,
                onEntered: this.onEntered,
                onEntering: this.onEntering,
                onExit: this.onExit,
                onExiting: this.onExiting,
                onExited: this.onExited
            }))
        }, e
    }(W.Component);
Oi.defaultProps = {
    classNames: ""
};
Oi.propTypes = {};
var ar, ur;

function Bc(n, e) {
    return !(n === e || W.isValidElement(n) && W.isValidElement(e) && n.key != null && n.key === e.key)
}
var An = {
        out: "out-in",
        in: "in-out"
    },
    xr = function(e, t, r) {
        return function() {
            var i;
            e.props[t] && (i = e.props)[t].apply(i, arguments), r()
        }
    },
    Rc = (ar = {}, ar[An.out] = function(n) {
        var e = n.current,
            t = n.changeState;
        return W.cloneElement(e, { in: !1,
            onExited: xr(e, "onExited", function() {
                t(bt, null)
            })
        })
    }, ar[An.in] = function(n) {
        var e = n.current,
            t = n.changeState,
            r = n.children;
        return [e, W.cloneElement(r, { in: !0,
            onEntered: xr(r, "onEntered", function() {
                t(bt)
            })
        })]
    }, ar),
    Mc = (ur = {}, ur[An.out] = function(n) {
        var e = n.children,
            t = n.changeState;
        return W.cloneElement(e, { in: !0,
            onEntered: xr(e, "onEntered", function() {
                t(Rt, W.cloneElement(e, { in: !0
                }))
            })
        })
    }, ur[An.in] = function(n) {
        var e = n.current,
            t = n.children,
            r = n.changeState;
        return [W.cloneElement(e, { in: !1,
            onExited: xr(e, "onExited", function() {
                r(Rt, W.cloneElement(t, { in: !0
                }))
            })
        }), W.cloneElement(t, { in: !0
        })]
    }, ur),
    Br = function(n) {
        Ii(e, n);

        function e() {
            for (var r, i = arguments.length, o = new Array(i), s = 0; s < i; s++) o[s] = arguments[s];
            return r = n.call.apply(n, [this].concat(o)) || this, r.state = {
                status: Rt,
                current: null
            }, r.appeared = !1, r.changeState = function(l, a) {
                a === void 0 && (a = r.state.current), r.setState({
                    status: l,
                    current: a
                })
            }, r
        }
        var t = e.prototype;
        return t.componentDidMount = function() {
            this.appeared = !0
        }, e.getDerivedStateFromProps = function(i, o) {
            return i.children == null ? {
                current: null
            } : o.status === bt && i.mode === An.in ? {
                status: bt
            } : o.current && Bc(o.current, i.children) ? {
                status: Gn
            } : {
                current: W.cloneElement(i.children, { in: !0
                })
            }
        }, t.render = function() {
            var i = this.props,
                o = i.children,
                s = i.mode,
                l = this.state,
                a = l.status,
                u = l.current,
                d = {
                    children: o,
                    current: u,
                    changeState: this.changeState,
                    status: a
                },
                h;
            switch (a) {
                case bt:
                    h = Mc[s](d);
                    break;
                case Gn:
                    h = Rc[s](d);
                    break;
                case Rt:
                    h = u
            }
            return W.createElement(Ki.Provider, {
                value: {
                    isMounting: !this.appeared
                }
            }, h)
        }, e
    }(W.Component);
Br.propTypes = {};
Br.defaultProps = {
    mode: An.out
};
const Ft = 42,
    Vn = 32;
let Jr = 0,
    cr = 0;
const Zt = Array.from({
        length: Ft * Vn
    }, () => ({
        open: 0,
        close: 0,
        progress: 1,
        opacity: 0,
        offset: Math.random() + 1
    })),
    Nc = ({
        isOpen: n,
        duration: e
    }) => {
        const t = c.useRef(null),
            r = c.useRef(null),
            [i, o] = c.useState(null),
            s = c.useCallback(D => {
                if (D) {
                    t.current = D;
                    const g = D.getContext("2d");
                    g && o(g)
                }
            }, []);
        c.useEffect(() => (window.addEventListener("resize", l), l(), () => window.removeEventListener("resize", l)), []);
        const l = () => {
                t.current && (t.current.width = window.innerWidth, t.current.height = window.innerHeight, Jr = t.current.width / Ft, cr = t.current.height / Vn)
            },
            a = () => {
                if (i) {
                    i.clearRect(0, 0, i.canvas.width, i.canvas.height), i.fillStyle = "rgba(22, 22, 22, 1)";
                    for (let D = 0; D < Vn; D++)
                        for (let g = 0; g < Ft; g++) i.fillRect(Jr * g - 1, cr * (D + 1) - 1 - cr * Math.min(1, Zt[g + D * Ft].close * Zt[g + D * Ft].offset), Jr + 2, (cr + 2) * (1 - Math.min(1, Zt[g + D * Ft].open * Zt[g + D * Ft].offset)) * Math.min(1, Zt[g + D * Ft].close * Zt[g + D * Ft].offset))
                }
            },
            u = () => {
                l();
                const D = Me.timeline();
                return D.to(Zt, {
                    open: 1,
                    duration: e / 1e3 - .1,
                    ease: "immg.zoomOut",
                    onUpdate: () => {
                        a()
                    },
                    stagger: {
                        amount: e / 1e3 - .1,
                        grid: [Vn, Ft],
                        from: [0, 0]
                    }
                }, 0), D
            },
            d = () => {
                l();
                const D = Me.timeline();
                return D.fromTo(Zt, {
                    close: 0,
                    open: 0
                }, {
                    close: 1,
                    duration: e / 1e3 - .1,
                    ease: "immg.zoomOut",
                    onUpdate: () => {
                        a()
                    },
                    stagger: {
                        amount: e / 1e3 - .1,
                        grid: [Vn, Ft],
                        from: [0, 1]
                    }
                }, 0), D
            },
            h = D => {
                const g = r.current;
                Me.context(() => {
                    const x = Me.timeline();
                    n ? x.add(d()) : x.add(u()), x.call(D)
                }, g)
            };
        return $.jsx(Et, {
            nodeRef: r,
            in: n,
            timeout: 800,
            addEndListener: h,
            children: $.jsx("div", {
                ref: r,
                id: "transition-element",
                children: $.jsx("canvas", {
                    ref: s,
                    id: "canvas-transition"
                })
            })
        })
    };
/*!
 * @gsap/react 2.1.2
 * https://gsap.com
 *
 * Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
let So = typeof document < "u" ? c.useLayoutEffect : c.useEffect,
    _o = n => n && !Array.isArray(n) && typeof n == "object",
    dr = [],
    Ic = {},
    Ls = Me;
const on = (n, e = dr) => {
    let t = Ic;
    _o(n) ? (t = n, n = null, e = "dependencies" in t ? t.dependencies : dr) : _o(e) && (t = e, e = "dependencies" in t ? t.dependencies : dr), n && typeof n != "function" && console.warn("First parameter must be a function or config object");
    const {
        scope: r,
        revertOnUpdate: i
    } = t, o = c.useRef(!1), s = c.useRef(Ls.context(() => {}, r)), l = c.useRef(u => s.current.add(null, u)), a = e && e.length && !i;
    return a && So(() => (o.current = !0, () => s.current.revert()), dr), So(() => {
        if (n && s.current.add(n, r), !a || !o.current) return () => s.current.revert()
    }, e), {
        context: s.current,
        contextSafe: l.current
    }
};
on.register = n => {
    Ls = n
};
on.headless = !0;
const Kc = W[typeof document < "u" && document.createElement !== void 0 ? "useLayoutEffect" : "useEffect"];
var hi = {
    exports: {}
};
(function(n, e) {
    (function(t, r) {
        r(e)
    })(Qn, function(t) {
        var r = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
            i = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/ig,
            o = Math.PI / 180,
            s = Math.sin,
            l = Math.cos,
            a = Math.abs,
            u = Math.sqrt,
            d = function(p) {
                return typeof p == "number"
            },
            h = 1e5,
            D = function(p) {
                return Math.round(p * h) / h || 0
            };

        function g(m, p, w, C, A, E, H) {
            for (var X = m.length, q, G, ne, te, se; --X > -1;)
                for (q = m[X], G = q.length, ne = 0; ne < G; ne += 2) te = q[ne], se = q[ne + 1], q[ne] = te * p + se * C + E, q[ne + 1] = te * w + se * A + H;
            return m._dirty = 1, m
        }

        function x(m, p, w, C, A, E, H, X, q) {
            if (!(m === X && p === q)) {
                w = a(w), C = a(C);
                var G = A % 360 * o,
                    ne = l(G),
                    te = s(G),
                    se = Math.PI,
                    ue = se * 2,
                    ie = (m - X) / 2,
                    z = (p - q) / 2,
                    oe = ne * ie + te * z,
                    Q = -te * ie + ne * z,
                    re = oe * oe,
                    ae = Q * Q,
                    de = re / (w * w) + ae / (C * C);
                de > 1 && (w = u(de) * w, C = u(de) * C);
                var he = w * w,
                    $e = C * C,
                    Ee = (he * $e - he * ae - $e * re) / (he * ae + $e * re);
                Ee < 0 && (Ee = 0);
                var pe = (E === H ? -1 : 1) * u(Ee),
                    Pe = pe * (w * Q / C),
                    me = pe * -(C * oe / w),
                    je = (m + X) / 2,
                    ze = (p + q) / 2,
                    at = je + (ne * Pe - te * me),
                    Tt = ze + (te * Pe + ne * me),
                    tt = (oe - Pe) / w,
                    De = (Q - me) / C,
                    Ae = (-oe - Pe) / w,
                    Ze = (-Q - me) / C,
                    Z = tt * tt + De * De,
                    vt = (De < 0 ? -1 : 1) * Math.acos(tt / u(Z)),
                    Ve = (tt * Ze - De * Ae < 0 ? -1 : 1) * Math.acos((tt * Ae + De * Ze) / u(Z * (Ae * Ae + Ze * Ze)));
                isNaN(Ve) && (Ve = se), !H && Ve > 0 ? Ve -= ue : H && Ve < 0 && (Ve += ue), vt %= ue, Ve %= ue;
                var dt = Math.ceil(a(Ve) / (ue / 4)),
                    ft = [],
                    nt = Ve / dt,
                    Le = 4 / 3 * s(nt / 2) / (1 + l(nt / 2)),
                    ln = ne * w,
                    ut = te * w,
                    qt = te * -C,
                    Bn = ne * C,
                    ot;
                for (ot = 0; ot < dt; ot++) A = vt + ot * nt, oe = l(A), Q = s(A), tt = l(A += nt), De = s(A), ft.push(oe - Le * Q, Q + Le * oe, tt + Le * De, De - Le * tt, tt, De);
                for (ot = 0; ot < ft.length; ot += 2) oe = ft[ot], Q = ft[ot + 1], ft[ot] = oe * ln + Q * qt + at, ft[ot + 1] = oe * ut + Q * Bn + Tt;
                return ft[ot - 2] = X, ft[ot - 1] = q, ft
            }
        }

        function P(m) {
            var p = (m + "").replace(i, function(Pe) {
                    var me = +Pe;
                    return me < 1e-4 && me > -1e-4 ? 0 : me
                }).match(r) || [],
                w = [],
                C = 0,
                A = 0,
                E = 2 / 3,
                H = p.length,
                X = 0,
                q = "ERROR: malformed path: " + m,
                G, ne, te, se, ue, ie, z, oe, Q, re, ae, de, he, $e, Ee, pe = function(me, je, ze, at) {
                    re = (ze - me) / 3, ae = (at - je) / 3, z.push(me + re, je + ae, ze - re, at - ae, ze, at)
                };
            if (!m || !isNaN(p[0]) || isNaN(p[1])) return console.log(q), w;
            for (G = 0; G < H; G++)
                if (he = ue, isNaN(p[G]) ? (ue = p[G].toUpperCase(), ie = ue !== p[G]) : G--, te = +p[G + 1], se = +p[G + 2], ie && (te += C, se += A), G || (oe = te, Q = se), ue === "M") z && (z.length < 8 ? w.length -= 1 : X += z.length), C = oe = te, A = Q = se, z = [te, se], w.push(z), G += 2, ue = "L";
                else if (ue === "C") z || (z = [0, 0]), ie || (C = A = 0), z.push(te, se, C + p[G + 3] * 1, A + p[G + 4] * 1, C += p[G + 5] * 1, A += p[G + 6] * 1), G += 6;
            else if (ue === "S") re = C, ae = A, (he === "C" || he === "S") && (re += C - z[z.length - 4], ae += A - z[z.length - 3]), ie || (C = A = 0), z.push(re, ae, te, se, C += p[G + 3] * 1, A += p[G + 4] * 1), G += 4;
            else if (ue === "Q") re = C + (te - C) * E, ae = A + (se - A) * E, ie || (C = A = 0), C += p[G + 3] * 1, A += p[G + 4] * 1, z.push(re, ae, C + (te - C) * E, A + (se - A) * E, C, A), G += 4;
            else if (ue === "T") re = C - z[z.length - 4], ae = A - z[z.length - 3], z.push(C + re, A + ae, te + (C + re * 1.5 - te) * E, se + (A + ae * 1.5 - se) * E, C = te, A = se), G += 2;
            else if (ue === "H") pe(C, A, C = te, A), G += 1;
            else if (ue === "V") pe(C, A, C, A = te + (ie ? A - C : 0)), G += 1;
            else if (ue === "L" || ue === "Z") ue === "Z" && (te = oe, se = Q, z.closed = !0), (ue === "L" || a(C - te) > .5 || a(A - se) > .5) && (pe(C, A, te, se), ue === "L" && (G += 2)), C = te, A = se;
            else if (ue === "A") {
                if ($e = p[G + 4], Ee = p[G + 5], re = p[G + 6], ae = p[G + 7], ne = 7, $e.length > 1 && ($e.length < 3 ? (ae = re, re = Ee, ne--) : (ae = Ee, re = $e.substr(2), ne -= 2), Ee = $e.charAt(1), $e = $e.charAt(0)), de = x(C, A, +p[G + 1], +p[G + 2], +p[G + 3], +$e, +Ee, (ie ? C : 0) + re * 1, (ie ? A : 0) + ae * 1), G += ne, de)
                    for (ne = 0; ne < de.length; ne++) z.push(de[ne]);
                C = z[z.length - 2], A = z[z.length - 1]
            } else console.log(q);
            return G = z.length, G < 6 ? (w.pop(), G = 0) : z[0] === z[G - 2] && z[1] === z[G - 1] && (z.closed = !0), w.totalPoints = X + G, w
        }

        function L(m) {
            d(m[0]) && (m = [m]);
            var p = "",
                w = m.length,
                C, A, E, H;
            for (A = 0; A < w; A++) {
                for (H = m[A], p += "M" + D(H[0]) + "," + D(H[1]) + " C", C = H.length, E = 2; E < C; E++) p += D(H[E++]) + "," + D(H[E++]) + " " + D(H[E++]) + "," + D(H[E++]) + " " + D(H[E++]) + "," + D(H[E]) + " ";
                H.closed && (p += "z")
            }
            return p
        }
        /*!
         * CustomEase 3.12.7
         * https://gsap.com
         *
         * @license Copyright 2008-2025, GreenSock. All rights reserved.
         * Subject to the terms at https://gsap.com/standard-license or for
         * Club GSAP members, the agreement issued with that membership.
         * @author: Jack Doyle, jack@greensock.com
         */
        var R, N, S = function() {
                return R || typeof window < "u" && (R = window.gsap) && R.registerPlugin && R
            },
            j = function() {
                R = S(), R ? (R.registerEase("_CE", K.create), N = 1) : console.warn("Please gsap.registerPlugin(CustomEase)")
            },
            k = 1e20,
            B = function(p) {
                return ~~(p * 1e3 + (p < 0 ? -.5 : .5)) / 1e3
            },
            M = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/gi,
            f = /[cLlsSaAhHvVtTqQ]/g,
            I = function(p) {
                var w = p.length,
                    C = k,
                    A;
                for (A = 1; A < w; A += 6) + p[A] < C && (C = +p[A]);
                return C
            },
            O = function(p, w, C) {
                !C && C !== 0 && (C = Math.max(+p[p.length - 1], +p[1]));
                var A = +p[0] * -1,
                    E = -C,
                    H = p.length,
                    X = 1 / (+p[H - 2] + A),
                    q = -w || (Math.abs(+p[H - 1] - +p[1]) < .01 * (+p[H - 2] - +p[0]) ? I(p) + E : +p[H - 1] + E),
                    G;
                for (q ? q = 1 / q : q = -X, G = 0; G < H; G += 2) p[G] = (+p[G] + A) * X, p[G + 1] = (+p[G + 1] + E) * q
            },
            T = function m(p, w, C, A, E, H, X, q, G, ne, te) {
                var se = (p + C) / 2,
                    ue = (w + A) / 2,
                    ie = (C + E) / 2,
                    z = (A + H) / 2,
                    oe = (E + X) / 2,
                    Q = (H + q) / 2,
                    re = (se + ie) / 2,
                    ae = (ue + z) / 2,
                    de = (ie + oe) / 2,
                    he = (z + Q) / 2,
                    $e = (re + de) / 2,
                    Ee = (ae + he) / 2,
                    pe = X - p,
                    Pe = q - w,
                    me = Math.abs((C - X) * Pe - (A - q) * pe),
                    je = Math.abs((E - X) * Pe - (H - q) * pe),
                    ze;
                return ne || (ne = [{
                    x: p,
                    y: w
                }, {
                    x: X,
                    y: q
                }], te = 1), ne.splice(te || ne.length - 1, 0, {
                    x: $e,
                    y: Ee
                }), (me + je) * (me + je) > G * (pe * pe + Pe * Pe) && (ze = ne.length, m(p, w, se, ue, re, ae, $e, Ee, G, ne, te), m($e, Ee, de, he, oe, Q, X, q, G, ne, te + 1 + (ne.length - ze))), ne
            },
            K = function() {
                function m(w, C, A) {
                    N || j(), this.id = w, this.setData(C, A)
                }
                var p = m.prototype;
                return p.setData = function(C, A) {
                    A = A || {}, C = C || "0,0,1,1";
                    var E = C.match(M),
                        H = 1,
                        X = [],
                        q = [],
                        G = A.precision || 1,
                        ne = G <= 1,
                        te, se, ue, ie, z, oe, Q, re, ae;
                    if (this.data = C, (f.test(C) || ~C.indexOf("M") && C.indexOf("C") < 0) && (E = P(C)[0]), te = E.length, te === 4) E.unshift(0, 0), E.push(1, 1), te = 8;
                    else if ((te - 2) % 6) throw "Invalid CustomEase";
                    for ((+E[0] != 0 || +E[te - 2] != 1) && O(E, A.height, A.originY), this.segment = E, ie = 2; ie < te; ie += 6) se = {
                        x: +E[ie - 2],
                        y: +E[ie - 1]
                    }, ue = {
                        x: +E[ie + 4],
                        y: +E[ie + 5]
                    }, X.push(se, ue), T(se.x, se.y, +E[ie], +E[ie + 1], +E[ie + 2], +E[ie + 3], ue.x, ue.y, 1 / (G * 2e5), X, X.length - 1);
                    for (te = X.length, ie = 0; ie < te; ie++) Q = X[ie], re = X[ie - 1] || Q, (Q.x > re.x || re.y !== Q.y && re.x === Q.x || Q === re) && Q.x <= 1 ? (re.cx = Q.x - re.x, re.cy = Q.y - re.y, re.n = Q, re.nx = Q.x, ne && ie > 1 && Math.abs(re.cy / re.cx - X[ie - 2].cy / X[ie - 2].cx) > 2 && (ne = 0), re.cx < H && (re.cx ? H = re.cx : (re.cx = .001, ie === te - 1 && (re.x -= .001, H = Math.min(H, .001), ne = 0)))) : (X.splice(ie--, 1), te--);
                    if (te = 1 / H + 1 | 0, z = 1 / te, oe = 0, Q = X[0], ne) {
                        for (ie = 0; ie < te; ie++) ae = ie * z, Q.nx < ae && (Q = X[++oe]), se = Q.y + (ae - Q.x) / Q.cx * Q.cy, q[ie] = {
                            x: ae,
                            cx: z,
                            y: se,
                            cy: 0,
                            nx: 9
                        }, ie && (q[ie - 1].cy = se - q[ie - 1].y);
                        oe = X[X.length - 1], q[te - 1].cy = oe.y - se, q[te - 1].cx = oe.x - q[q.length - 1].x
                    } else {
                        for (ie = 0; ie < te; ie++) Q.nx < ie * z && (Q = X[++oe]), q[ie] = Q;
                        oe < X.length - 1 && (q[ie - 1] = X[X.length - 2])
                    }
                    return this.ease = function(de) {
                        var he = q[de * te | 0] || q[te - 1];
                        return he.nx < de && (he = he.n), he.y + (de - he.x) / he.cx * he.cy
                    }, this.ease.custom = this, this.id && R && R.registerEase(this.id, this.ease), this
                }, p.getSVGData = function(C) {
                    return m.getSVGData(this, C)
                }, m.create = function(C, A, E) {
                    return new m(C, A, E).ease
                }, m.register = function(C) {
                    R = C, j()
                }, m.get = function(C) {
                    return R.parseEase(C)
                }, m.getSVGData = function(C, A) {
                    A = A || {};
                    var E = A.width || 100,
                        H = A.height || 100,
                        X = A.x || 0,
                        q = (A.y || 0) + H,
                        G = R.utils.toArray(A.path)[0],
                        ne, te, se, ue, ie, z, oe, Q, re, ae;
                    if (A.invert && (H = -H, q = 0), typeof C == "string" && (C = R.parseEase(C)), C.custom && (C = C.custom), C instanceof m) ne = L(g([C.segment], E, 0, 0, -H, X, q));
                    else {
                        for (ne = [X, q], oe = Math.max(5, (A.precision || 1) * 200), ue = 1 / oe, oe += 2, Q = 5 / oe, re = B(X + ue * E), ae = B(q + C(ue) * -H), te = (ae - q) / (re - X), se = 2; se < oe; se++) ie = B(X + se * ue * E), z = B(q + C(se * ue) * -H), (Math.abs((z - ae) / (ie - re) - te) > Q || se === oe - 1) && (ne.push(re, ae), te = (z - ae) / (ie - re)), re = ie, ae = z;
                        ne = "M" + ne.join(",")
                    }
                    return G && G.setAttribute("d", ne), ne
                }, m
            }();
        K.version = "3.12.7", K.headless = !0, S() && R.registerPlugin(K), t.CustomEase = K, t.default = K, Object.defineProperty(t, "__esModule", {
            value: !0
        })
    })
})(hi, hi.exports);
var Jt = hi.exports,
    Di = {
        exports: {}
    };
(function(n, e) {
    (function(t, r) {
        r(e)
    })(Qn, function(t) {
        var r, i, o, s, l, a, u, d, h = "transform",
            D = h + "Origin",
            g, x = function(v) {
                var y = v.ownerDocument || v;
                for (!(h in v.style) && ("msTransform" in v.style) && (h = "msTransform", D = h + "Origin"); y.parentNode && (y = y.parentNode););
                if (i = window, u = new T, y) {
                    r = y, o = y.documentElement, s = y.body, d = r.createElementNS("http://www.w3.org/2000/svg", "g"), d.style.transform = "none";
                    var b = y.createElement("div"),
                        _ = y.createElement("div"),
                        F = y && (y.body || y.firstElementChild);
                    F && F.appendChild && (F.appendChild(b), b.appendChild(_), b.setAttribute("style", "position:static;transform:translate3d(0,0,1px)"), g = _.offsetParent !== b, F.removeChild(b))
                }
                return y
            },
            P = function(v) {
                for (var y, b; v && v !== s;) b = v._gsap, b && b.uncache && b.get(v, "x"), b && !b.scaleX && !b.scaleY && b.renderTransform && (b.scaleX = b.scaleY = 1e-4, b.renderTransform(1, b), y ? y.push(b) : y = [b]), v = v.parentNode;
                return y
            },
            L = [],
            R = [],
            N = function() {
                return i.pageYOffset || r.scrollTop || o.scrollTop || s.scrollTop || 0
            },
            S = function() {
                return i.pageXOffset || r.scrollLeft || o.scrollLeft || s.scrollLeft || 0
            },
            j = function(v) {
                return v.ownerSVGElement || ((v.tagName + "").toLowerCase() === "svg" ? v : null)
            },
            k = function J(v) {
                if (i.getComputedStyle(v).position === "fixed") return !0;
                if (v = v.parentNode, v && v.nodeType === 1) return J(v)
            },
            B = function J(v, y) {
                if (v.parentNode && (r || x(v))) {
                    var b = j(v),
                        _ = b ? b.getAttribute("xmlns") || "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml",
                        F = b ? y ? "rect" : "g" : "div",
                        U = y !== 2 ? 0 : 100,
                        ee = y === 3 ? 100 : 0,
                        Y = "position:absolute;display:block;pointer-events:none;margin:0;padding:0;",
                        V = r.createElementNS ? r.createElementNS(_.replace(/^https/, "http"), F) : r.createElement(F);
                    return y && (b ? (a || (a = J(v)), V.setAttribute("width", .01), V.setAttribute("height", .01), V.setAttribute("transform", "translate(" + U + "," + ee + ")"), a.appendChild(V)) : (l || (l = J(v), l.style.cssText = Y), V.style.cssText = Y + "width:0.1px;height:0.1px;top:" + ee + "px;left:" + U + "px", l.appendChild(V))), V
                }
                throw "Need document and parent."
            },
            M = function(v) {
                for (var y = new T, b = 0; b < v.numberOfItems; b++) y.multiply(v.getItem(b).matrix);
                return y
            },
            f = function(v) {
                var y = v.getCTM(),
                    b;
                return y || (b = v.style[h], v.style[h] = "none", v.appendChild(d), y = d.getCTM(), v.removeChild(d), b ? v.style[h] = b : v.style.removeProperty(h.replace(/([A-Z])/g, "-$1").toLowerCase())), y || u.clone()
            },
            I = function(v, y) {
                var b = j(v),
                    _ = v === b,
                    F = b ? L : R,
                    U = v.parentNode,
                    ee, Y, V, ce, le, ge;
                if (v === i) return v;
                if (F.length || F.push(B(v, 1), B(v, 2), B(v, 3)), ee = b ? a : l, b) _ ? (V = f(v), ce = -V.e / V.a, le = -V.f / V.d, Y = u) : v.getBBox ? (V = v.getBBox(), Y = v.transform ? v.transform.baseVal : {}, Y = Y.numberOfItems ? Y.numberOfItems > 1 ? M(Y) : Y.getItem(0).matrix : u, ce = Y.a * V.x + Y.c * V.y, le = Y.b * V.x + Y.d * V.y) : (Y = new T, ce = le = 0), y && v.tagName.toLowerCase() === "g" && (ce = le = 0), (_ ? b : U).appendChild(ee), ee.setAttribute("transform", "matrix(" + Y.a + "," + Y.b + "," + Y.c + "," + Y.d + "," + (Y.e + ce) + "," + (Y.f + le) + ")");
                else {
                    if (ce = le = 0, g)
                        for (Y = v.offsetParent, V = v; V && (V = V.parentNode) && V !== Y && V.parentNode;)(i.getComputedStyle(V)[h] + "").length > 4 && (ce = V.offsetLeft, le = V.offsetTop, V = 0);
                    if (ge = i.getComputedStyle(v), ge.position !== "absolute" && ge.position !== "fixed")
                        for (Y = v.offsetParent; U && U !== Y;) ce += U.scrollLeft || 0, le += U.scrollTop || 0, U = U.parentNode;
                    V = ee.style, V.top = v.offsetTop - le + "px", V.left = v.offsetLeft - ce + "px", V[h] = ge[h], V[D] = ge[D], V.position = ge.position === "fixed" ? "fixed" : "absolute", v.parentNode.appendChild(ee)
                }
                return ee
            },
            O = function(v, y, b, _, F, U, ee) {
                return v.a = y, v.b = b, v.c = _, v.d = F, v.e = U, v.f = ee, v
            },
            T = function() {
                function J(y, b, _, F, U, ee) {
                    y === void 0 && (y = 1), b === void 0 && (b = 0), _ === void 0 && (_ = 0), F === void 0 && (F = 1), U === void 0 && (U = 0), ee === void 0 && (ee = 0), O(this, y, b, _, F, U, ee)
                }
                var v = J.prototype;
                return v.inverse = function() {
                    var b = this.a,
                        _ = this.b,
                        F = this.c,
                        U = this.d,
                        ee = this.e,
                        Y = this.f,
                        V = b * U - _ * F || 1e-10;
                    return O(this, U / V, -_ / V, -F / V, b / V, (F * Y - U * ee) / V, -(b * Y - _ * ee) / V)
                }, v.multiply = function(b) {
                    var _ = this.a,
                        F = this.b,
                        U = this.c,
                        ee = this.d,
                        Y = this.e,
                        V = this.f,
                        ce = b.a,
                        le = b.c,
                        ge = b.b,
                        Se = b.d,
                        _e = b.e,
                        Be = b.f;
                    return O(this, ce * _ + ge * U, ce * F + ge * ee, le * _ + Se * U, le * F + Se * ee, Y + _e * _ + Be * U, V + _e * F + Be * ee)
                }, v.clone = function() {
                    return new J(this.a, this.b, this.c, this.d, this.e, this.f)
                }, v.equals = function(b) {
                    var _ = this.a,
                        F = this.b,
                        U = this.c,
                        ee = this.d,
                        Y = this.e,
                        V = this.f;
                    return _ === b.a && F === b.b && U === b.c && ee === b.d && Y === b.e && V === b.f
                }, v.apply = function(b, _) {
                    _ === void 0 && (_ = {});
                    var F = b.x,
                        U = b.y,
                        ee = this.a,
                        Y = this.b,
                        V = this.c,
                        ce = this.d,
                        le = this.e,
                        ge = this.f;
                    return _.x = F * ee + U * V + le || 0, _.y = F * Y + U * ce + ge || 0, _
                }, J
            }();

        function K(J, v, y, b) {
            if (!J || !J.parentNode || (r || x(J)).documentElement === J) return new T;
            var _ = P(J),
                F = j(J),
                U = F ? L : R,
                ee = I(J, y),
                Y = U[0].getBoundingClientRect(),
                V = U[1].getBoundingClientRect(),
                ce = U[2].getBoundingClientRect(),
                le = ee.parentNode,
                ge = !b && k(J),
                Se = new T((V.left - Y.left) / 100, (V.top - Y.top) / 100, (ce.left - Y.left) / 100, (ce.top - Y.top) / 100, Y.left + (ge ? 0 : S()), Y.top + (ge ? 0 : N()));
            if (le.removeChild(ee), _)
                for (Y = _.length; Y--;) V = _[Y], V.scaleX = V.scaleY = 0, V.renderTransform(1, V);
            return v ? Se.inverse() : Se
        }
        /*!
         * Flip 3.12.7
         * https://gsap.com
         *
         * @license Copyright 2008-2025, GreenSock. All rights reserved.
         * Subject to the terms at https://gsap.com/standard-license or for
         * Club GSAP members, the agreement issued with that membership.
         * @author: Jack Doyle, jack@greensock.com
         */
        var m = 1,
            p, w, C, A, E, H, X, q = function(v, y) {
                return v.actions.forEach(function(b) {
                    return b.vars[y] && b.vars[y](b)
                })
            },
            G = {},
            ne = 180 / Math.PI,
            te = Math.PI / 180,
            se = {},
            ue = {},
            ie = {},
            z = function(v) {
                return typeof v == "string" ? v.split(" ").join("").split(",") : v
            },
            oe = z("onStart,onUpdate,onComplete,onReverseComplete,onInterrupt"),
            Q = z("transform,transformOrigin,width,height,position,top,left,opacity,zIndex,maxWidth,maxHeight,minWidth,minHeight"),
            re = function(v) {
                return p(v)[0] || console.warn("Element not found:", v)
            },
            ae = function(v) {
                return Math.round(v * 1e4) / 1e4 || 0
            },
            de = function(v, y, b) {
                return v.forEach(function(_) {
                    return _.classList[b](y)
                })
            },
            he = {
                zIndex: 1,
                kill: 1,
                simple: 1,
                spin: 1,
                clearProps: 1,
                targets: 1,
                toggleClass: 1,
                onComplete: 1,
                onUpdate: 1,
                onInterrupt: 1,
                onStart: 1,
                delay: 1,
                repeat: 1,
                repeatDelay: 1,
                yoyo: 1,
                scale: 1,
                fade: 1,
                absolute: 1,
                props: 1,
                onEnter: 1,
                onLeave: 1,
                custom: 1,
                paused: 1,
                nested: 1,
                prune: 1,
                absoluteOnLeave: 1
            },
            $e = {
                zIndex: 1,
                simple: 1,
                clearProps: 1,
                scale: 1,
                absolute: 1,
                fitChild: 1,
                getVars: 1,
                props: 1
            },
            Ee = function(v) {
                return v.replace(/([A-Z])/g, "-$1").toLowerCase()
            },
            pe = function(v, y) {
                var b = {},
                    _;
                for (_ in v) y[_] || (b[_] = v[_]);
                return b
            },
            Pe = {},
            me = function(v) {
                var y = Pe[v] = z(v);
                return ie[v] = y.concat(Q), y
            },
            je = function(v) {
                var y = v._gsap || w.core.getCache(v);
                return y.gmCache === w.ticker.frame ? y.gMatrix : (y.gmCache = w.ticker.frame, y.gMatrix = K(v, !0, !1, !0))
            },
            ze = function J(v, y, b) {
                b === void 0 && (b = 0);
                for (var _ = v.parentNode, F = 1e3 * Math.pow(10, b) * (y ? -1 : 1), U = y ? -F * 900 : 0; v;) U += F, v = v.previousSibling;
                return _ ? U + J(_, y, b + 1) : U
            },
            at = function(v, y, b) {
                return v.forEach(function(_) {
                    return _.d = ze(b ? _.element : _.t, y)
                }), v.sort(function(_, F) {
                    return _.d - F.d
                }), v
            },
            Tt = function(v, y) {
                for (var b = v.element.style, _ = v.css = v.css || [], F = y.length, U, ee; F--;) U = y[F], ee = b[U] || b.getPropertyValue(U), _.push(ee ? U : ue[U] || (ue[U] = Ee(U)), ee);
                return b
            },
            tt = function(v) {
                var y = v.css,
                    b = v.element.style,
                    _ = 0;
                for (v.cache.uncache = 1; _ < y.length; _ += 2) y[_ + 1] ? b[y[_]] = y[_ + 1] : b.removeProperty(y[_]);
                !y[y.indexOf("transform") + 1] && b.translate && (b.removeProperty("translate"), b.removeProperty("scale"), b.removeProperty("rotate"))
            },
            De = function(v, y) {
                v.forEach(function(b) {
                    return b.a.cache.uncache = 1
                }), y || v.finalStates.forEach(tt)
            },
            Ae = "paddingTop,paddingRight,paddingBottom,paddingLeft,gridArea,transition".split(","),
            Ze = function(v, y, b) {
                var _ = v.element,
                    F = v.width,
                    U = v.height,
                    ee = v.uncache,
                    Y = v.getProp,
                    V = _.style,
                    ce = 4,
                    le, ge, Se;
                if (typeof y != "object" && (y = v), C && b !== 1) return C._abs.push({
                    t: _,
                    b: v,
                    a: v,
                    sd: 0
                }), C._final.push(function() {
                    return (v.cache.uncache = 1) && tt(v)
                }), _;
                for (ge = Y("display") === "none", (!v.isVisible || ge) && (ge && (Tt(v, ["display"]).display = y.display), v.matrix = y.matrix, v.width = F = v.width || y.width, v.height = U = v.height || y.height), Tt(v, Ae), Se = window.getComputedStyle(_); ce--;) V[Ae[ce]] = Se[Ae[ce]];
                if (V.gridArea = "1 / 1 / 1 / 1", V.transition = "none", V.position = "absolute", V.width = F + "px", V.height = U + "px", V.top || (V.top = "0px"), V.left || (V.left = "0px"), ee) le = new an(_);
                else if (le = pe(v, se), le.position = "absolute", v.simple) {
                    var _e = _.getBoundingClientRect();
                    le.matrix = new T(1, 0, 0, 1, _e.left + S(), _e.top + N())
                } else le.matrix = K(_, !1, !1, !0);
                return le = qt(le, v, !0), v.x = H(le.x, .01), v.y = H(le.y, .01), _
            },
            Z = function(v, y) {
                return y !== !0 && (y = p(y), v = v.filter(function(b) {
                    if (y.indexOf((b.sd < 0 ? b.b : b.a).element) !== -1) return !0;
                    b.t._gsap.renderTransform(1), b.b.isVisible && (b.t.style.width = b.b.width + "px", b.t.style.height = b.b.height + "px")
                })), v
            },
            vt = function(v) {
                return at(v, !0).forEach(function(y) {
                    return (y.a.isVisible || y.b.isVisible) && Ze(y.sd < 0 ? y.b : y.a, y.b, 1)
                })
            },
            Ve = function(v, y) {
                return y && v.idLookup[dt(y).id] || v.elementStates[0]
            },
            dt = function(v, y, b, _) {
                return v instanceof an ? v : v instanceof $t ? Ve(v, _) : new an(typeof v == "string" ? re(v) || console.warn(v + " not found") : v, y, b)
            },
            ft = function(v, y) {
                for (var b = w.getProperty(v.element, null, "native"), _ = v.props = {}, F = y.length; F--;) _[y[F]] = (b(y[F]) + "").trim();
                return _.zIndex && (_.zIndex = parseFloat(_.zIndex) || 0), v
            },
            nt = function(v, y) {
                var b = v.style || v,
                    _;
                for (_ in y) b[_] = y[_]
            },
            Le = function(v) {
                var y = v.getAttribute("data-flip-id");
                return y || v.setAttribute("data-flip-id", y = "auto-" + m++), y
            },
            ln = function(v) {
                return v.map(function(y) {
                    return y.element
                })
            },
            ut = function(v, y, b) {
                return v && y.length && b.add(v(ln(y), b, new $t(y, 0, !0)), 0)
            },
            qt = function(v, y, b, _, F, U) {
                var ee = v.element,
                    Y = v.cache,
                    V = v.parent,
                    ce = v.x,
                    le = v.y,
                    ge = y.width,
                    Se = y.height,
                    _e = y.scaleX,
                    Be = y.scaleY,
                    Te = y.rotation,
                    ke = y.bounds,
                    st = U && X && X(ee, "transform,width,height"),
                    be = v,
                    Je = y.matrix,
                    We = Je.e,
                    rt = Je.f,
                    kt = v.bounds.width !== ke.width || v.bounds.height !== ke.height || v.scaleX !== _e || v.scaleY !== Be || v.rotation !== Te,
                    At = !kt && v.simple && y.simple && !F,
                    Qe, we, Ie, It, wt, lt, ye;
                return At || !V ? (_e = Be = 1, Te = Qe = 0) : (wt = je(V), lt = wt.clone().multiply(y.ctm ? y.matrix.clone().multiply(y.ctm) : y.matrix), Te = ae(Math.atan2(lt.b, lt.a) * ne), Qe = ae(Math.atan2(lt.c, lt.d) * ne + Te) % 360, _e = Math.sqrt(Math.pow(lt.a, 2) + Math.pow(lt.b, 2)), Be = Math.sqrt(Math.pow(lt.c, 2) + Math.pow(lt.d, 2)) * Math.cos(Qe * te), F && (F = p(F)[0], It = w.getProperty(F), ye = F.getBBox && typeof F.getBBox == "function" && F.getBBox(), be = {
                    scaleX: It("scaleX"),
                    scaleY: It("scaleY"),
                    width: ye ? ye.width : Math.ceil(parseFloat(It("width", "px"))),
                    height: ye ? ye.height : parseFloat(It("height", "px"))
                }), Y.rotation = Te + "deg", Y.skewX = Qe + "deg"), b ? (_e *= ge === be.width || !be.width ? 1 : ge / be.width, Be *= Se === be.height || !be.height ? 1 : Se / be.height, Y.scaleX = _e, Y.scaleY = Be) : (ge = H(ge * _e / be.scaleX, 0), Se = H(Se * Be / be.scaleY, 0), ee.style.width = ge + "px", ee.style.height = Se + "px"), _ && nt(ee, y.props), At || !V ? (ce += We - v.matrix.e, le += rt - v.matrix.f) : kt || V !== y.parent ? (Y.renderTransform(1, Y), lt = K(F || ee, !1, !1, !0), we = wt.apply({
                    x: lt.e,
                    y: lt.f
                }), Ie = wt.apply({
                    x: We,
                    y: rt
                }), ce += Ie.x - we.x, le += Ie.y - we.y) : (wt.e = wt.f = 0, Ie = wt.apply({
                    x: We - v.matrix.e,
                    y: rt - v.matrix.f
                }), ce += Ie.x, le += Ie.y), ce = H(ce, .02), le = H(le, .02), U && !(U instanceof an) ? st && st.revert() : (Y.x = ce + "px", Y.y = le + "px", Y.renderTransform(1, Y)), U && (U.x = ce, U.y = le, U.rotation = Te, U.skewX = Qe, b ? (U.scaleX = _e, U.scaleY = Be) : (U.width = ge, U.height = Se)), U || Y
            },
            Bn = function(v, y) {
                return v instanceof $t ? v : new $t(v, y)
            },
            ot = function(v, y, b) {
                var _ = v.idLookup[b],
                    F = v.alt[b];
                return F.isVisible && (!(y.getElementState(F.element) || F).isVisible || !_.isVisible) ? F : _
            },
            zr = [],
            Vr = "width,height,overflowX,overflowY".split(","),
            or, ho = function(v) {
                if (v !== or) {
                    var y = E.style,
                        b = E.clientWidth === window.outerWidth,
                        _ = E.clientHeight === window.outerHeight,
                        F = 4;
                    if (v && (b || _)) {
                        for (; F--;) zr[F] = y[Vr[F]];
                        b && (y.width = E.clientWidth + "px", y.overflowY = "hidden"), _ && (y.height = E.clientHeight + "px", y.overflowX = "hidden"), or = v
                    } else if (or) {
                        for (; F--;) zr[F] ? y[Vr[F]] = zr[F] : y.removeProperty(Ee(Vr[F]));
                        or = v
                    }
                }
            },
            Wr = function(v, y, b, _) {
                v instanceof $t && y instanceof $t || console.warn("Not a valid state object."), b = b || {};
                var F = b,
                    U = F.clearProps,
                    ee = F.onEnter,
                    Y = F.onLeave,
                    V = F.absolute,
                    ce = F.absoluteOnLeave,
                    le = F.custom,
                    ge = F.delay,
                    Se = F.paused,
                    _e = F.repeat,
                    Be = F.repeatDelay,
                    Te = F.yoyo,
                    ke = F.toggleClass,
                    st = F.nested,
                    be = F.zIndex,
                    Je = F.scale,
                    We = F.fade,
                    rt = F.stagger,
                    kt = F.spin,
                    At = F.prune,
                    Qe = ("props" in b ? b : v).props,
                    we = pe(b, he),
                    Ie = w.timeline({
                        delay: ge,
                        paused: Se,
                        repeat: _e,
                        repeatDelay: Be,
                        yoyo: Te,
                        data: "isFlip"
                    }),
                    It = we,
                    wt = [],
                    lt = [],
                    ye = [],
                    lr = [],
                    Ku = kt === !0 ? 1 : kt || 0,
                    Ou = typeof kt == "function" ? kt : function() {
                        return Ku
                    },
                    Ur = v.interrupted || y.interrupted,
                    Do = Ie[_ !== 1 ? "to" : "from"],
                    mn, ht, vo, Yt, Ye, Ke, bn, Lt, Gr, Kt, Ot, Xr, Xe, ct;
                for (ht in y.idLookup) Ot = y.alt[ht] ? ot(y, v, ht) : y.idLookup[ht], Ye = Ot.element, Kt = v.idLookup[ht], v.alt[ht] && Ye === Kt.element && (v.alt[ht].isVisible || !Ot.isVisible) && (Kt = v.alt[ht]), Kt ? (Ke = {
                    t: Ye,
                    b: Kt,
                    a: Ot,
                    sd: Kt.element === Ye ? 0 : Ot.isVisible ? 1 : -1
                }, ye.push(Ke), Ke.sd && (Ke.sd < 0 && (Ke.b = Ot, Ke.a = Kt), Ur && Tt(Ke.b, Qe ? ie[Qe] : Q), We && ye.push(Ke.swap = {
                    t: Kt.element,
                    b: Ke.b,
                    a: Ke.a,
                    sd: -Ke.sd,
                    swap: Ke
                })), Ye._flip = Kt.element._flip = C ? C.timeline : Ie) : Ot.isVisible && (ye.push({
                    t: Ye,
                    b: pe(Ot, {
                        isVisible: 1
                    }),
                    a: Ot,
                    sd: 0,
                    entering: 1
                }), Ye._flip = C ? C.timeline : Ie);
                if (Qe && (Pe[Qe] || me(Qe)).forEach(function(jt) {
                        return we[jt] = function(un) {
                            return ye[un].a.props[jt]
                        }
                    }), ye.finalStates = Gr = [], Xr = function() {
                        for (at(ye), ho(!0), Yt = 0; Yt < ye.length; Yt++) Ke = ye[Yt], Xe = Ke.a, ct = Ke.b, At && !Xe.isDifferent(ct) && !Ke.entering ? ye.splice(Yt--, 1) : (Ye = Ke.t, st && !(Ke.sd < 0) && Yt && (Xe.matrix = K(Ye, !1, !1, !0)), ct.isVisible && Xe.isVisible ? (Ke.sd < 0 ? (bn = new an(Ye, Qe, v.simple), qt(bn, Xe, Je, 0, 0, bn), bn.matrix = K(Ye, !1, !1, !0), bn.css = Ke.b.css, Ke.a = Xe = bn, We && (Ye.style.opacity = Ur ? ct.opacity : Xe.opacity), rt && lr.push(Ye)) : Ke.sd > 0 && We && (Ye.style.opacity = Ur ? Xe.opacity - ct.opacity : "0"), qt(Xe, ct, Je, Qe)) : ct.isVisible !== Xe.isVisible && (ct.isVisible ? Xe.isVisible || (ct.css = Xe.css, lt.push(ct), ye.splice(Yt--, 1), V && st && qt(Xe, ct, Je, Qe)) : (Xe.isVisible && wt.push(Xe), ye.splice(Yt--, 1))), Je || (Ye.style.maxWidth = Math.max(Xe.width, ct.width) + "px", Ye.style.maxHeight = Math.max(Xe.height, ct.height) + "px", Ye.style.minWidth = Math.min(Xe.width, ct.width) + "px", Ye.style.minHeight = Math.min(Xe.height, ct.height) + "px"), st && ke && Ye.classList.add(ke)), Gr.push(Xe);
                        var un;
                        if (ke && (un = Gr.map(function(ve) {
                                return ve.element
                            }), st && un.forEach(function(ve) {
                                return ve.classList.remove(ke)
                            })), ho(!1), Je ? (we.scaleX = function(ve) {
                                return ye[ve].a.scaleX
                            }, we.scaleY = function(ve) {
                                return ye[ve].a.scaleY
                            }) : (we.width = function(ve) {
                                return ye[ve].a.width + "px"
                            }, we.height = function(ve) {
                                return ye[ve].a.height + "px"
                            }, we.autoRound = b.autoRound || !1), we.x = function(ve) {
                                return ye[ve].a.x + "px"
                            }, we.y = function(ve) {
                                return ye[ve].a.y + "px"
                            }, we.rotation = function(ve) {
                                return ye[ve].a.rotation + (kt ? Ou(ve, Lt[ve], Lt) * 360 : 0)
                            }, we.skewX = function(ve) {
                                return ye[ve].a.skewX
                            }, Lt = ye.map(function(ve) {
                                return ve.t
                            }), (be || be === 0) && (we.modifiers = {
                                zIndex: function() {
                                    return be
                                }
                            }, we.zIndex = be, we.immediateRender = b.immediateRender !== !1), We && (we.opacity = function(ve) {
                                return ye[ve].sd < 0 ? 0 : ye[ve].sd > 0 ? ye[ve].a.opacity : "+=0"
                            }), lr.length) {
                            rt = w.utils.distribute(rt);
                            var ju = Lt.slice(lr.length);
                            we.stagger = function(ve, mo) {
                                return rt(~lr.indexOf(mo) ? Lt.indexOf(ye[ve].swap.t) : ve, mo, ju)
                            }
                        }
                        if (oe.forEach(function(ve) {
                                return b[ve] && Ie.eventCallback(ve, b[ve], b[ve + "Params"])
                            }), le && Lt.length) {
                            It = pe(we, he), "scale" in le && (le.scaleX = le.scaleY = le.scale, delete le.scale);
                            for (ht in le) mn = pe(le[ht], $e), mn[ht] = we[ht], !("duration" in mn) && "duration" in we && (mn.duration = we.duration), mn.stagger = we.stagger, Do.call(Ie, Lt, mn, 0), delete It[ht]
                        }(Lt.length || lt.length || wt.length) && (ke && Ie.add(function() {
                            return de(un, ke, Ie._zTime < 0 ? "remove" : "add")
                        }, 0) && !Se && de(un, ke, "add"), Lt.length && Do.call(Ie, Lt, It, 0)), ut(ee, wt, Ie), ut(Y, lt, Ie);
                        var Yr = C && C.timeline;
                        Yr && (Yr.add(Ie, 0), C._final.push(function() {
                            return De(ye, !U)
                        })), vo = Ie.duration(), Ie.call(function() {
                            var ve = Ie.time() >= vo;
                            ve && !Yr && De(ye, !U), ke && de(un, ke, ve ? "remove" : "add")
                        })
                    }, ce && (V = ye.filter(function(jt) {
                        return !jt.sd && !jt.a.isVisible && jt.b.isVisible
                    }).map(function(jt) {
                        return jt.a.element
                    })), C) {
                    var go;
                    V && (go = C._abs).push.apply(go, Z(ye, V)), C._run.push(Xr)
                } else V && vt(Z(ye, V)), Xr();
                var qr = C ? C.timeline : Ie;
                return qr.revert = function() {
                    return Hr(qr, 1, 1)
                }, qr
            },
            Mu = function J(v) {
                v.vars.onInterrupt && v.vars.onInterrupt.apply(v, v.vars.onInterruptParams || []), v.getChildren(!0, !1, !0).forEach(J)
            },
            Hr = function(v, y, b) {
                if (v && v.progress() < 1 && (!v.paused() || b)) return y && (Mu(v), y < 2 && v.progress(1), v.kill()), !0
            },
            sr = function(v) {
                for (var y = v.idLookup = {}, b = v.alt = {}, _ = v.elementStates, F = _.length, U; F--;) U = _[F], y[U.id] ? b[U.id] = U : y[U.id] = U
            },
            $t = function() {
                function J(y, b, _) {
                    if (this.props = b && b.props, this.simple = !!(b && b.simple), _) this.targets = ln(y), this.elementStates = y, sr(this);
                    else {
                        this.targets = p(y);
                        var F = b && (b.kill === !1 || b.batch && !b.kill);
                        C && !F && C._kill.push(this), this.update(F || !!C)
                    }
                }
                var v = J.prototype;
                return v.update = function(b) {
                    var _ = this;
                    return this.elementStates = this.targets.map(function(F) {
                        return new an(F, _.props, _.simple)
                    }), sr(this), this.interrupt(b), this.recordInlineStyles(), this
                }, v.clear = function() {
                    return this.targets.length = this.elementStates.length = 0, sr(this), this
                }, v.fit = function(b, _, F) {
                    for (var U = at(this.elementStates.slice(0), !1, !0), ee = (b || this).idLookup, Y = 0, V, ce; Y < U.length; Y++) V = U[Y], F && (V.matrix = K(V.element, !1, !1, !0)), ce = ee[V.id], ce && qt(V, ce, _, !0, 0, V), V.matrix = K(V.element, !1, !1, !0);
                    return this
                }, v.getProperty = function(b, _) {
                    var F = this.getElementState(b) || se;
                    return (_ in F ? F : F.props || se)[_]
                }, v.add = function(b) {
                    for (var _ = b.targets.length, F = this.idLookup, U = this.alt, ee, Y, V; _--;) Y = b.elementStates[_], V = F[Y.id], V && (Y.element === V.element || U[Y.id] && U[Y.id].element === Y.element) ? (ee = this.elementStates.indexOf(Y.element === V.element ? V : U[Y.id]), this.targets.splice(ee, 1, b.targets[_]), this.elementStates.splice(ee, 1, Y)) : (this.targets.push(b.targets[_]), this.elementStates.push(Y));
                    return b.interrupted && (this.interrupted = !0), b.simple || (this.simple = !1), sr(this), this
                }, v.compare = function(b) {
                    var _ = b.idLookup,
                        F = this.idLookup,
                        U = [],
                        ee = [],
                        Y = [],
                        V = [],
                        ce = [],
                        le = b.alt,
                        ge = this.alt,
                        Se = function(At, Qe, we) {
                            return (At.isVisible !== Qe.isVisible ? At.isVisible ? Y : V : At.isVisible ? ee : U).push(we) && ce.push(we)
                        },
                        _e = function(At, Qe, we) {
                            return ce.indexOf(we) < 0 && Se(At, Qe, we)
                        },
                        Be, Te, ke, st, be, Je, We, rt;
                    for (ke in _) be = le[ke], Je = ge[ke], Be = be ? ot(b, this, ke) : _[ke], st = Be.element, Te = F[ke], Je ? (rt = Te.isVisible || !Je.isVisible && st === Te.element ? Te : Je, We = be && !Be.isVisible && !be.isVisible && rt.element === be.element ? be : Be, We.isVisible && rt.isVisible && We.element !== rt.element ? ((We.isDifferent(rt) ? ee : U).push(We.element, rt.element), ce.push(We.element, rt.element)) : Se(We, rt, We.element), be && We.element === be.element && (be = _[ke]), _e(We.element !== Te.element && be ? be : We, Te, Te.element), _e(be && be.element === Je.element ? be : We, Je, Je.element), be && _e(be, Je.element === be.element ? Je : Te, be.element)) : (Te ? Te.isDifferent(Be) ? Se(Be, Te, st) : U.push(st) : Y.push(st), be && _e(be, Te, be.element));
                    for (ke in F) _[ke] || (V.push(F[ke].element), ge[ke] && V.push(ge[ke].element));
                    return {
                        changed: ee,
                        unchanged: U,
                        enter: Y,
                        leave: V
                    }
                }, v.recordInlineStyles = function() {
                    for (var b = ie[this.props] || Q, _ = this.elementStates.length; _--;) Tt(this.elementStates[_], b)
                }, v.interrupt = function(b) {
                    var _ = this,
                        F = [];
                    this.targets.forEach(function(U) {
                        var ee = U._flip,
                            Y = Hr(ee, b ? 0 : 1);
                        b && Y && F.indexOf(ee) < 0 && ee.add(function() {
                            return _.updateVisibility()
                        }), Y && F.push(ee)
                    }), !b && F.length && this.updateVisibility(), this.interrupted || (this.interrupted = !!F.length)
                }, v.updateVisibility = function() {
                    this.elementStates.forEach(function(b) {
                        var _ = b.element.getBoundingClientRect();
                        b.isVisible = !!(_.width || _.height || _.top || _.left), b.uncache = 1
                    })
                }, v.getElementState = function(b) {
                    return this.elementStates[this.targets.indexOf(re(b))]
                }, v.makeAbsolute = function() {
                    return at(this.elementStates.slice(0), !0, !0).map(Ze)
                }, J
            }(),
            an = function() {
                function J(y, b, _) {
                    this.element = y, this.update(b, _)
                }
                var v = J.prototype;
                return v.isDifferent = function(b) {
                    var _ = this.bounds,
                        F = b.bounds;
                    return _.top !== F.top || _.left !== F.left || _.width !== F.width || _.height !== F.height || !this.matrix.equals(b.matrix) || this.opacity !== b.opacity || this.props && b.props && JSON.stringify(this.props) !== JSON.stringify(b.props)
                }, v.update = function(b, _) {
                    var F = this,
                        U = F.element,
                        ee = w.getProperty(U),
                        Y = w.core.getCache(U),
                        V = U.getBoundingClientRect(),
                        ce = U.getBBox && typeof U.getBBox == "function" && U.nodeName.toLowerCase() !== "svg" && U.getBBox(),
                        le = _ ? new T(1, 0, 0, 1, V.left + S(), V.top + N()) : K(U, !1, !1, !0);
                    F.getProp = ee, F.element = U, F.id = Le(U), F.matrix = le, F.cache = Y, F.bounds = V, F.isVisible = !!(V.width || V.height || V.left || V.top), F.display = ee("display"), F.position = ee("position"), F.parent = U.parentNode, F.x = ee("x"), F.y = ee("y"), F.scaleX = Y.scaleX, F.scaleY = Y.scaleY, F.rotation = ee("rotation"), F.skewX = ee("skewX"), F.opacity = ee("opacity"), F.width = ce ? ce.width : H(ee("width", "px"), .04), F.height = ce ? ce.height : H(ee("height", "px"), .04), b && ft(F, Pe[b] || me(b)), F.ctm = U.getCTM && U.nodeName.toLowerCase() === "svg" && f(U).inverse(), F.simple = _ || ae(le.a) === 1 && !ae(le.b) && !ae(le.c) && ae(le.d) === 1, F.uncache = 0
                }, J
            }(),
            Nu = function() {
                function J(y, b) {
                    this.vars = y, this.batch = b, this.states = [], this.timeline = b.timeline
                }
                var v = J.prototype;
                return v.getStateById = function(b) {
                    for (var _ = this.states.length; _--;)
                        if (this.states[_].idLookup[b]) return this.states[_]
                }, v.kill = function() {
                    this.batch.remove(this)
                }, J
            }(),
            Iu = function() {
                function J(y) {
                    this.id = y, this.actions = [], this._kill = [], this._final = [], this._abs = [], this._run = [], this.data = {}, this.state = new $t, this.timeline = w.timeline()
                }
                var v = J.prototype;
                return v.add = function(b) {
                    var _ = this.actions.filter(function(F) {
                        return F.vars === b
                    });
                    return _.length ? _[0] : (_ = new Nu(typeof b == "function" ? {
                        animate: b
                    } : b, this), this.actions.push(_), _)
                }, v.remove = function(b) {
                    var _ = this.actions.indexOf(b);
                    return _ >= 0 && this.actions.splice(_, 1), this
                }, v.getState = function(b) {
                    var _ = this,
                        F = C,
                        U = A;
                    return C = this, this.state.clear(), this._kill.length = 0, this.actions.forEach(function(ee) {
                        ee.vars.getState && (ee.states.length = 0, A = ee, ee.state = ee.vars.getState(ee)), b && ee.states.forEach(function(Y) {
                            return _.state.add(Y)
                        })
                    }), A = U, C = F, this.killConflicts(), this
                }, v.animate = function() {
                    var b = this,
                        _ = C,
                        F = this.timeline,
                        U = this.actions.length,
                        ee, Y;
                    for (C = this, F.clear(), this._abs.length = this._final.length = this._run.length = 0, this.actions.forEach(function(V) {
                            V.vars.animate && V.vars.animate(V);
                            var ce = V.vars.onEnter,
                                le = V.vars.onLeave,
                                ge = V.targets,
                                Se, _e;
                            ge && ge.length && (ce || le) && (Se = new $t, V.states.forEach(function(Be) {
                                return Se.add(Be)
                            }), _e = Se.compare(Rn.getState(ge)), _e.enter.length && ce && ce(_e.enter), _e.leave.length && le && le(_e.leave))
                        }), vt(this._abs), this._run.forEach(function(V) {
                            return V()
                        }), Y = F.duration(), ee = this._final.slice(0), F.add(function() {
                            Y <= F.time() && (ee.forEach(function(V) {
                                return V()
                            }), q(b, "onComplete"))
                        }), C = _; U--;) this.actions[U].vars.once && this.actions[U].kill();
                    return q(this, "onStart"), F.restart(), this
                }, v.loadState = function(b) {
                    b || (b = function() {
                        return 0
                    });
                    var _ = [];
                    return this.actions.forEach(function(F) {
                        if (F.vars.loadState) {
                            var U, ee = function Y(V) {
                                V && (F.targets = V), U = _.indexOf(Y), ~U && (_.splice(U, 1), _.length || b())
                            };
                            _.push(ee), F.vars.loadState(ee)
                        }
                    }), _.length || b(), this
                }, v.setState = function() {
                    return this.actions.forEach(function(b) {
                        return b.targets = b.vars.setState && b.vars.setState(b)
                    }), this
                }, v.killConflicts = function(b) {
                    return this.state.interrupt(b), this._kill.forEach(function(_) {
                        return _.interrupt(b)
                    }), this
                }, v.run = function(b, _) {
                    var F = this;
                    return this !== C && (b || this.getState(_), this.loadState(function() {
                        F._killed || (F.setState(), F.animate())
                    })), this
                }, v.clear = function(b) {
                    this.state.clear(), b || (this.actions.length = 0)
                }, v.getStateById = function(b) {
                    for (var _ = this.actions.length, F; _--;)
                        if (F = this.actions[_].getStateById(b), F) return F;
                    return this.state.idLookup[b] && this.state
                }, v.kill = function() {
                    this._killed = 1, this.clear(), delete G[this.id]
                }, J
            }(),
            Rn = function() {
                function J() {}
                return J.getState = function(y, b) {
                    var _ = Bn(y, b);
                    return A && A.states.push(_), b && b.batch && J.batch(b.batch).state.add(_), _
                }, J.from = function(y, b) {
                    return b = b || {}, "clearProps" in b || (b.clearProps = !0), Wr(y, Bn(b.targets || y.targets, {
                        props: b.props || y.props,
                        simple: b.simple,
                        kill: !!b.kill
                    }), b, -1)
                }, J.to = function(y, b) {
                    return Wr(y, Bn(b.targets || y.targets, {
                        props: b.props || y.props,
                        simple: b.simple,
                        kill: !!b.kill
                    }), b, 1)
                }, J.fromTo = function(y, b, _) {
                    return Wr(y, b, _)
                }, J.fit = function(y, b, _) {
                    var F = _ ? pe(_, $e) : {},
                        U = _ || F,
                        ee = U.absolute,
                        Y = U.scale,
                        V = U.getVars,
                        ce = U.props,
                        le = U.runBackwards,
                        ge = U.onComplete,
                        Se = U.simple,
                        _e = _ && _.fitChild && re(_.fitChild),
                        Be = dt(b, ce, Se, y),
                        Te = dt(y, 0, Se, Be),
                        ke = ce ? ie[ce] : Q,
                        st = w.context();
                    return ce && nt(F, Be.props), Tt(Te, ke), le && ("immediateRender" in F || (F.immediateRender = !0), F.onComplete = function() {
                        tt(Te), ge && ge.apply(this, arguments)
                    }), ee && Ze(Te, Be), F = qt(Te, Be, Y || _e, ce, _e, F.duration || V ? F : 0), typeof _ == "object" && "zIndex" in _ && (F.zIndex = _.zIndex), st && !V && st.add(function() {
                        return function() {
                            return tt(Te)
                        }
                    }), V ? F : F.duration ? w.to(Te.element, F) : null
                }, J.makeAbsolute = function(y, b) {
                    return (y instanceof $t ? y : new $t(y, b)).makeAbsolute()
                }, J.batch = function(y) {
                    return y || (y = "default"), G[y] || (G[y] = new Iu(y))
                }, J.killFlipsOf = function(y, b) {
                    (y instanceof $t ? y.targets : p(y)).forEach(function(_) {
                        return _ && Hr(_._flip, b !== !1 ? 1 : 2)
                    })
                }, J.isFlipping = function(y) {
                    var b = J.getByTarget(y);
                    return !!b && b.isActive()
                }, J.getByTarget = function(y) {
                    return (re(y) || se)._flip
                }, J.getElementState = function(y, b) {
                    return new an(re(y), b)
                }, J.convertCoordinates = function(y, b, _) {
                    var F = K(b, !0, !0).multiply(K(y));
                    return _ ? F.apply(_) : F
                }, J.register = function(y) {
                    if (E = typeof document < "u" && document.body, E) {
                        w = y, x(E), p = w.utils.toArray, X = w.core.getStyleSaver;
                        var b = w.utils.snap(.1);
                        H = function(F, U) {
                            return b(parseFloat(F) + U)
                        }
                    }
                }, J
            }();
        Rn.version = "3.12.7", typeof window < "u" && window.gsap && window.gsap.registerPlugin(Rn), t.Flip = Rn, t.default = Rn, Object.defineProperty(t, "__esModule", {
            value: !0
        })
    })
})(Di, Di.exports);
var Oc = Di.exports,
    vi = {
        exports: {}
    };
(function(n, e) {
    (function(t, r) {
        r(e)
    })(Qn, function(t) {
        var r = /(?:^\s+|\s+$)/g,
            i = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2642\u2640]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDD27\uDCBC\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCC\uDFCB]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;

        function o(S) {
            var j = S.nodeType,
                k = "";
            if (j === 1 || j === 9 || j === 11) {
                if (typeof S.textContent == "string") return S.textContent;
                for (S = S.firstChild; S; S = S.nextSibling) k += o(S)
            } else if (j === 3 || j === 4) return S.nodeValue;
            return k
        }

        function s(S, j, k, B, M) {
            if (S += "", k && (S = S.trim ? S.trim() : S.replace(r, "")), j && j !== "") return S.replace(/>/g, "&gt;").replace(/</g, "&lt;").split(j);
            for (var f = [], I = S.length, O = 0, T, K; O < I; O++) K = S.charAt(O), (K.charCodeAt(0) >= 55296 && K.charCodeAt(0) <= 56319 || S.charCodeAt(O + 1) >= 65024 && S.charCodeAt(O + 1) <= 65039) && (T = ((S.substr(O, 12).split(i) || [])[1] || "").length || 2, K = S.substr(O, T), f.emoji = 1, O += T - 1), f.push(M ? K : K === ">" ? "&gt;" : K === "<" ? "&lt;" : B && K === " " && (S.charAt(O - 1) === " " || S.charAt(O + 1) === " ") ? "&nbsp;" : K);
            return f
        }
        /*!
         * ScrambleTextPlugin 3.12.7
         * https://gsap.com
         *
         * @license Copyright 2008-2025, GreenSock. All rights reserved.
         * Subject to the terms at https://gsap.com/standard-license or for
         * Club GSAP members, the agreement issued with that membership.
         * @author: Jack Doyle, jack@greensock.com
         */
        var l = function() {
                function S(k) {
                    this.chars = s(k), this.sets = [], this.length = 50;
                    for (var B = 0; B < 20; B++) this.sets[B] = g(80, this.chars)
                }
                var j = S.prototype;
                return j.grow = function(B) {
                    for (var M = 0; M < 20; M++) this.sets[M] += g(B - this.length, this.chars);
                    this.length = B
                }, S
            }(),
            a, u, d = function() {
                return a || typeof window < "u" && (a = window.gsap) && a.registerPlugin && a
            },
            h = 1,
            D = /\s+/g,
            g = function(j, k) {
                for (var B = k.length, M = ""; --j > -1;) M += k[~~(Math.random() * B)];
                return M
            },
            x = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
            P = x.toLowerCase(),
            L = {
                upperCase: new l(x),
                lowerCase: new l(P),
                upperAndLowerCase: new l(x + P)
            },
            R = function() {
                u = a = d()
            },
            N = {
                version: "3.12.7",
                name: "scrambleText",
                register: function(j, k, B) {
                    a = j, R()
                },
                init: function(j, k, B, M, f) {
                    if (u || R(), this.prop = "innerHTML" in j ? "innerHTML" : "textContent" in j ? "textContent" : 0, !!this.prop) {
                        this.target = j, typeof k != "object" && (k = {
                            text: k
                        });
                        var I = k.text || k.value || "",
                            O = k.trim !== !1,
                            T = this,
                            K, m, p, w;
                        return T.delimiter = K = k.delimiter || "", T.original = s(o(j).replace(D, " ").split("&nbsp;").join(""), K, O), (I === "{original}" || I === !0 || I == null) && (I = T.original.join(K)), T.text = s((I || "").replace(D, " "), K, O), T.hasClass = !!(k.newClass || k.oldClass), T.newClass = k.newClass, T.oldClass = k.oldClass, w = K === "", T.textHasEmoji = w && !!T.text.emoji, T.charsHaveEmoji = !!k.chars && !!s(k.chars).emoji, T.length = w ? T.original.length : T.original.join(K).length, T.lengthDif = (w ? T.text.length : T.text.join(K).length) - T.length, T.fillChar = k.fillChar || k.chars && ~k.chars.indexOf(" ") ? "&nbsp;" : "", T.charSet = p = L[k.chars || "upperCase"] || new l(k.chars), T.speed = .05 / (k.speed || 1), T.prevScrambleTime = 0, T.setIndex = Math.random() * 20 | 0, m = T.length + Math.max(T.lengthDif, 0), m > p.length && p.grow(m), T.chars = p.sets[T.setIndex], T.revealDelay = k.revealDelay || 0, T.tweenLength = k.tweenLength !== !1, T.tween = B, T.rightToLeft = !!k.rightToLeft, T._props.push("scrambleText", "text"), h
                    }
                },
                render: function(j, k) {
                    var B = k.target,
                        M = k.prop,
                        f = k.text,
                        I = k.delimiter,
                        O = k.tween,
                        T = k.prevScrambleTime,
                        K = k.revealDelay,
                        m = k.setIndex,
                        p = k.chars,
                        w = k.charSet,
                        C = k.length,
                        A = k.textHasEmoji,
                        E = k.charsHaveEmoji,
                        H = k.lengthDif,
                        X = k.tweenLength,
                        q = k.oldClass,
                        G = k.newClass,
                        ne = k.rightToLeft,
                        te = k.fillChar,
                        se = k.speed,
                        ue = k.original,
                        ie = k.hasClass,
                        z = f.length,
                        oe = O._time,
                        Q = oe - T,
                        re, ae, de, he, $e, Ee, pe, Pe, me, je, ze;
                    K && (O._from && (oe = O._dur - oe), j = oe === 0 ? 0 : oe < K ? 1e-6 : oe === O._dur ? 1 : O._ease((oe - K) / (O._dur - K))), j < 0 ? j = 0 : j > 1 && (j = 1), ne && (j = 1 - j), re = ~~(j * z + .5), j ? ((Q > se || Q < -se) && (k.setIndex = m = (m + (Math.random() * 19 | 0)) % 20, k.chars = w.sets[m], k.prevScrambleTime += Q), he = p) : he = ue.join(I), ze = O._from ? j : 1 - j, je = C + (X ? O._from ? ze * ze * ze : 1 - ze * ze * ze : 1) * H, ne ? j === 1 && (O._from || O.data === "isFromStart") ? (de = "", he = ue.join(I)) : (pe = f.slice(re).join(I), E ? de = s(he).slice(0, je - (A ? s(pe) : pe).length + .5 | 0).join("") : de = he.substr(0, je - (A ? s(pe) : pe).length + .5 | 0), he = pe) : (de = f.slice(0, re).join(I), ae = (A ? s(de) : de).length, E ? he = s(he).slice(ae, je + .5 | 0).join("") : he = he.substr(ae, je - ae + .5 | 0)), ie ? (Pe = ne ? q : G, me = ne ? G : q, $e = Pe && re !== 0, Ee = me && re !== z, pe = ($e ? "<span class='" + Pe + "'>" : "") + de + ($e ? "</span>" : "") + (Ee ? "<span class='" + me + "'>" : "") + I + he + (Ee ? "</span>" : "")) : pe = de + I + he, B[M] = te === "&nbsp;" && ~pe.indexOf("  ") ? pe.split("  ").join("&nbsp;&nbsp;") : pe
                }
            };
        N.emojiSafeSplit = s, N.getText = o, d() && a.registerPlugin(N), t.ScrambleTextPlugin = N, t.default = N, Object.defineProperty(t, "__esModule", {
            value: !0
        })
    })
})(vi, vi.exports);
var jc = vi.exports,
    gi = {
        exports: {}
    };
(function(n, e) {
    (function(t, r) {
        r(e)
    })(Qn, function(t) {
        /*!
         * ScrollToPlugin 3.12.7
         * https://gsap.com
         *
         * @license Copyright 2008-2025, GreenSock. All rights reserved.
         * Subject to the terms at https://gsap.com/standard-license or for
         * Club GSAP members, the agreement issued with that membership.
         * @author: Jack Doyle, jack@greensock.com
         */
        var r, i, o, s, l, a, u, d, h = function() {
                return typeof window < "u"
            },
            D = function() {
                return r || h() && (r = window.gsap) && r.registerPlugin && r
            },
            g = function(M) {
                return typeof M == "string"
            },
            x = function(M) {
                return typeof M == "function"
            },
            P = function(M, f) {
                var I = f === "x" ? "Width" : "Height",
                    O = "scroll" + I,
                    T = "client" + I;
                return M === o || M === s || M === l ? Math.max(s[O], l[O]) - (o["inner" + I] || s[T] || l[T]) : M[O] - M["offset" + I]
            },
            L = function(M, f) {
                var I = "scroll" + (f === "x" ? "Left" : "Top");
                return M === o && (M.pageXOffset != null ? I = "page" + f.toUpperCase() + "Offset" : M = s[I] != null ? s : l),
                    function() {
                        return M[I]
                    }
            },
            R = function(M, f, I, O) {
                if (x(M) && (M = M(f, I, O)), typeof M != "object") return g(M) && M !== "max" && M.charAt(1) !== "=" ? {
                    x: M,
                    y: M
                } : {
                    y: M
                };
                if (M.nodeType) return {
                    y: M,
                    x: M
                };
                var T = {},
                    K;
                for (K in M) T[K] = K !== "onAutoKill" && x(M[K]) ? M[K](f, I, O) : M[K];
                return T
            },
            N = function(M, f) {
                if (M = a(M)[0], !M || !M.getBoundingClientRect) return console.warn("scrollTo target doesn't exist. Using 0") || {
                    x: 0,
                    y: 0
                };
                var I = M.getBoundingClientRect(),
                    O = !f || f === o || f === l,
                    T = O ? {
                        top: s.clientTop - (o.pageYOffset || s.scrollTop || l.scrollTop || 0),
                        left: s.clientLeft - (o.pageXOffset || s.scrollLeft || l.scrollLeft || 0)
                    } : f.getBoundingClientRect(),
                    K = {
                        x: I.left - T.left,
                        y: I.top - T.top
                    };
                return !O && f && (K.x += L(f, "x")(), K.y += L(f, "y")()), K
            },
            S = function(M, f, I, O, T) {
                return !isNaN(M) && typeof M != "object" ? parseFloat(M) - T : g(M) && M.charAt(1) === "=" ? parseFloat(M.substr(2)) * (M.charAt(0) === "-" ? -1 : 1) + O - T : M === "max" ? P(f, I) - T : Math.min(P(f, I), N(M, f)[I] - T)
            },
            j = function() {
                r = D(), h() && r && typeof document < "u" && document.body && (o = window, l = document.body, s = document.documentElement, a = r.utils.toArray, r.config({
                    autoKillThreshold: 7
                }), u = r.config(), i = 1)
            },
            k = {
                version: "3.12.7",
                name: "scrollTo",
                rawVars: 1,
                register: function(M) {
                    r = M, j()
                },
                init: function(M, f, I, O, T) {
                    i || j();
                    var K = this,
                        m = r.getProperty(M, "scrollSnapType");
                    K.isWin = M === o, K.target = M, K.tween = I, f = R(f, O, M, T), K.vars = f, K.autoKill = !!("autoKill" in f ? f : u).autoKill, K.getX = L(M, "x"), K.getY = L(M, "y"), K.x = K.xPrev = K.getX(), K.y = K.yPrev = K.getY(), d || (d = r.core.globals().ScrollTrigger), r.getProperty(M, "scrollBehavior") === "smooth" && r.set(M, {
                        scrollBehavior: "auto"
                    }), m && m !== "none" && (K.snap = 1, K.snapInline = M.style.scrollSnapType, M.style.scrollSnapType = "none"), f.x != null ? (K.add(K, "x", K.x, S(f.x, M, "x", K.x, f.offsetX || 0), O, T), K._props.push("scrollTo_x")) : K.skipX = 1, f.y != null ? (K.add(K, "y", K.y, S(f.y, M, "y", K.y, f.offsetY || 0), O, T), K._props.push("scrollTo_y")) : K.skipY = 1
                },
                render: function(M, f) {
                    for (var I = f._pt, O = f.target, T = f.tween, K = f.autoKill, m = f.xPrev, p = f.yPrev, w = f.isWin, C = f.snap, A = f.snapInline, E, H, X, q, G; I;) I.r(M, I.d), I = I._next;
                    E = w || !f.skipX ? f.getX() : m, H = w || !f.skipY ? f.getY() : p, X = H - p, q = E - m, G = u.autoKillThreshold, f.x < 0 && (f.x = 0), f.y < 0 && (f.y = 0), K && (!f.skipX && (q > G || q < -G) && E < P(O, "x") && (f.skipX = 1), !f.skipY && (X > G || X < -G) && H < P(O, "y") && (f.skipY = 1), f.skipX && f.skipY && (T.kill(), f.vars.onAutoKill && f.vars.onAutoKill.apply(T, f.vars.onAutoKillParams || []))), w ? o.scrollTo(f.skipX ? E : f.x, f.skipY ? H : f.y) : (f.skipY || (O.scrollTop = f.y), f.skipX || (O.scrollLeft = f.x)), C && (M === 1 || M === 0) && (H = O.scrollTop, E = O.scrollLeft, A ? O.style.scrollSnapType = A : O.style.removeProperty("scroll-snap-type"), O.scrollTop = H + 1, O.scrollLeft = E + 1, O.scrollTop = H, O.scrollLeft = E), f.xPrev = f.x, f.yPrev = f.y, d && d.update()
                },
                kill: function(M) {
                    var f = M === "scrollTo",
                        I = this._props.indexOf(M);
                    return (f || M === "scrollTo_x") && (this.skipX = 1), (f || M === "scrollTo_y") && (this.skipY = 1), I > -1 && this._props.splice(I, 1), !this._props.length
                }
            };
        k.max = P, k.getOffset = N, k.buildGetter = L, k.config = function(B) {
            u || j() || (u = r.config());
            for (var M in B) u[M] = B[M]
        }, D() && r.registerPlugin(k), t.ScrollToPlugin = k, t.default = k, Object.defineProperty(t, "__esModule", {
            value: !0
        })
    })
})(gi, gi.exports);
var zc = gi.exports,
    mi = {
        exports: {}
    };
(function(n, e) {
    (function(t, r) {
        r(e)
    })(Qn, function(t) {
        var r = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2642\u2640]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDD27\uDCBC\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCC\uDFCB]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;

        function i(m) {
            var p = m.nodeType,
                w = "";
            if (p === 1 || p === 9 || p === 11) {
                if (typeof m.textContent == "string") return m.textContent;
                for (m = m.firstChild; m; m = m.nextSibling) w += i(m)
            } else if (p === 3 || p === 4) return m.nodeValue;
            return w
        }
        /*!
         * SplitText: 3.12.7
         * https://gsap.com
         *
         * @license Copyright 2008-2025, GreenSock. All rights reserved.
         * Subject to the terms at https://gsap.com/standard-license or for
         * Club GSAP members, the agreement issued with that membership.
         * @author: Jack Doyle, jack@greensock.com
         */
        var o, s, l, a, u, d, h = /(?:\r|\n|\t\t)/g,
            D = /(?:\s\s+)/g,
            g = " ",
            x = function(p) {
                o = document, s = window, a = a || p || s.gsap || console.warn("Please gsap.registerPlugin(SplitText)"), a && (d = a.utils.toArray, u = a.core.context || function() {}, l = 1)
            },
            P = function(p) {
                return s.getComputedStyle(p)
            },
            L = function(p) {
                return p.position === "absolute" || p.absolute === !0
            },
            R = function(p, w) {
                for (var C = w.length, A; --C > -1;)
                    if (A = w[C], p.substr(0, A.length) === A) return A.length
            },
            N = " style='position:relative;display:inline-block;'",
            S = function(p, w) {
                p === void 0 && (p = "");
                var C = ~p.indexOf("++"),
                    A = 1;
                return C && (p = p.split("++").join("")),
                    function() {
                        return "<" + w + N + (p ? " class='" + p + (C ? A++ : "") + "'>" : ">")
                    }
            },
            j = function m(p, w, C) {
                var A = p.nodeType;
                if (A === 1 || A === 9 || A === 11)
                    for (p = p.firstChild; p; p = p.nextSibling) m(p, w, C);
                else(A === 3 || A === 4) && (p.nodeValue = p.nodeValue.split(w).join(C))
            },
            k = function(p, w) {
                for (var C = w.length; --C > -1;) p.push(w[C])
            },
            B = function(p, w, C) {
                for (var A; p && p !== w;) {
                    if (A = p._next || p.nextSibling, A) return A.textContent.charAt(0) === C;
                    p = p.parentNode || p._parent
                }
            },
            M = function m(p) {
                var w = d(p.childNodes),
                    C = w.length,
                    A, E;
                for (A = 0; A < C; A++) E = w[A], E._isSplit ? m(E) : A && E.previousSibling && E.previousSibling.nodeType === 3 ? (E.previousSibling.nodeValue += E.nodeType === 3 ? E.nodeValue : E.firstChild.nodeValue, p.removeChild(E)) : E.nodeType !== 3 && (p.insertBefore(E.firstChild, E), p.removeChild(E))
            },
            f = function(p, w) {
                return parseFloat(w[p]) || 0
            },
            I = function(p, w, C, A, E, H, X) {
                var q = P(p),
                    G = f("paddingLeft", q),
                    ne = -999,
                    te = f("borderBottomWidth", q) + f("borderTopWidth", q),
                    se = f("borderLeftWidth", q) + f("borderRightWidth", q),
                    ue = f("paddingTop", q) + f("paddingBottom", q),
                    ie = f("paddingLeft", q) + f("paddingRight", q),
                    z = f("fontSize", q) * (w.lineThreshold || .2),
                    oe = q.textAlign,
                    Q = [],
                    re = [],
                    ae = [],
                    de = w.wordDelimiter || " ",
                    he = w.tag ? w.tag : w.span ? "span" : "div",
                    $e = w.type || w.split || "chars,words,lines",
                    Ee = E && ~$e.indexOf("lines") ? [] : null,
                    pe = ~$e.indexOf("words"),
                    Pe = ~$e.indexOf("chars"),
                    me = L(w),
                    je = w.linesClass,
                    ze = ~(je || "").indexOf("++"),
                    at = [],
                    Tt = q.display === "flex",
                    tt = p.style.display,
                    De, Ae, Ze, Z, vt, Ve, dt, ft, nt, Le, ln, ut;
                for (ze && (je = je.split("++").join("")), Tt && (p.style.display = "block"), Ae = p.getElementsByTagName("*"), Ze = Ae.length, vt = [], De = 0; De < Ze; De++) vt[De] = Ae[De];
                if (Ee || me)
                    for (De = 0; De < Ze; De++) Z = vt[De], Ve = Z.parentNode === p, (Ve || me || Pe && !pe) && (ut = Z.offsetTop, Ee && Ve && Math.abs(ut - ne) > z && (Z.nodeName !== "BR" || De === 0) && (dt = [], Ee.push(dt), ne = ut), me && (Z._x = Z.offsetLeft, Z._y = ut, Z._w = Z.offsetWidth, Z._h = Z.offsetHeight), Ee && ((Z._isSplit && Ve || !Pe && Ve || pe && Ve || !pe && Z.parentNode.parentNode === p && !Z.parentNode._isSplit) && (dt.push(Z), Z._x -= G, B(Z, p, de) && (Z._wordEnd = !0)), Z.nodeName === "BR" && (Z.nextSibling && Z.nextSibling.nodeName === "BR" || De === 0) && Ee.push([])));
                for (De = 0; De < Ze; De++) {
                    if (Z = vt[De], Ve = Z.parentNode === p, Z.nodeName === "BR") {
                        Ee || me ? (Z.parentNode && Z.parentNode.removeChild(Z), vt.splice(De--, 1), Ze--) : pe || p.appendChild(Z);
                        continue
                    }
                    if (me && (nt = Z.style, !pe && !Ve && (Z._x += Z.parentNode._x, Z._y += Z.parentNode._y), nt.left = Z._x + "px", nt.top = Z._y + "px", nt.position = "absolute", nt.display = "block", nt.width = Z._w + 1 + "px", nt.height = Z._h + "px"), !pe && Pe)
                        if (Z._isSplit)
                            for (Z._next = Ae = Z.nextSibling, Z.parentNode.appendChild(Z); Ae && Ae.nodeType === 3 && Ae.textContent === " ";) Z._next = Ae.nextSibling, Z.parentNode.appendChild(Ae), Ae = Ae.nextSibling;
                        else Z.parentNode._isSplit ? (Z._parent = Z.parentNode, !Z.previousSibling && Z.firstChild && (Z.firstChild._isFirst = !0), Z.nextSibling && Z.nextSibling.textContent === " " && !Z.nextSibling.nextSibling && at.push(Z.nextSibling), Z._next = Z.nextSibling && Z.nextSibling._isFirst ? null : Z.nextSibling, Z.parentNode.removeChild(Z), vt.splice(De--, 1), Ze--) : Ve || (ut = !Z.nextSibling && B(Z.parentNode, p, de), Z.parentNode._parent && Z.parentNode._parent.appendChild(Z), ut && Z.parentNode.appendChild(o.createTextNode(" ")), he === "span" && (Z.style.display = "inline"), Q.push(Z));
                    else Z.parentNode._isSplit && !Z._isSplit && Z.innerHTML !== "" ? re.push(Z) : Pe && !Z._isSplit && (he === "span" && (Z.style.display = "inline"), Q.push(Z))
                }
                for (De = at.length; --De > -1;) at[De].parentNode.removeChild(at[De]);
                if (Ee) {
                    for (me && (Le = o.createElement(he), p.appendChild(Le), ln = Le.offsetWidth + "px", ut = Le.offsetParent === p ? 0 : p.offsetLeft, p.removeChild(Le)), nt = p.style.cssText, p.style.cssText = "display:none;"; p.firstChild;) p.removeChild(p.firstChild);
                    for (ft = de === " " && (!me || !pe && !Pe), De = 0; De < Ee.length; De++) {
                        for (dt = Ee[De], Le = o.createElement(he), Le.style.cssText = "display:block;text-align:" + oe + ";position:" + (me ? "absolute;" : "relative;"), je && (Le.className = je + (ze ? De + 1 : "")), ae.push(Le), Ze = dt.length, Ae = 0; Ae < Ze; Ae++) dt[Ae].nodeName !== "BR" && (Z = dt[Ae], Le.appendChild(Z), ft && Z._wordEnd && Le.appendChild(o.createTextNode(" ")), me && (Ae === 0 && (Le.style.top = Z._y + "px", Le.style.left = G + ut + "px"), Z.style.top = "0px", ut && (Z.style.left = Z._x - ut + "px")));
                        Ze === 0 ? Le.innerHTML = "&nbsp;" : !pe && !Pe && (M(Le), j(Le, " ", " ")), me && (Le.style.width = ln, Le.style.height = Z._h + "px"), p.appendChild(Le)
                    }
                    p.style.cssText = nt
                }
                me && (X > p.clientHeight && (p.style.height = X - ue + "px", p.clientHeight < X && (p.style.height = X + te + "px")), H > p.clientWidth && (p.style.width = H - ie + "px", p.clientWidth < H && (p.style.width = H + se + "px"))), Tt && (tt ? p.style.display = tt : p.style.removeProperty("display")), k(C, Q), pe && k(A, re), k(E, ae)
            },
            O = function(p, w, C, A) {
                var E = w.tag ? w.tag : w.span ? "span" : "div",
                    H = w.type || w.split || "chars,words,lines",
                    X = ~H.indexOf("chars"),
                    q = L(w),
                    G = w.wordDelimiter || " ",
                    ne = function(me) {
                        return me === G || me === g && G === " "
                    },
                    te = G !== " " ? "" : q ? "&#173; " : " ",
                    se = "</" + E + ">",
                    ue = 1,
                    ie = w.specialChars ? typeof w.specialChars == "function" ? w.specialChars : R : null,
                    z, oe, Q, re, ae, de, he, $e, Ee = o.createElement("div"),
                    pe = p.parentNode;
                for (pe.insertBefore(Ee, p), Ee.textContent = p.nodeValue, pe.removeChild(p), p = Ee, z = i(p), he = z.indexOf("<") !== -1, w.reduceWhiteSpace !== !1 && (z = z.replace(D, " ").replace(h, "")), he && (z = z.split("<").join("{{LT}}")), ae = z.length, oe = (z.charAt(0) === " " ? te : "") + C(), Q = 0; Q < ae; Q++)
                    if (de = z.charAt(Q), ie && ($e = ie(z.substr(Q), w.specialChars))) de = z.substr(Q, $e || 1), oe += X && de !== " " ? A() + de + "</" + E + ">" : de, Q += $e - 1;
                    else if (ne(de) && !ne(z.charAt(Q - 1)) && Q) {
                    for (oe += ue ? se : "", ue = 0; ne(z.charAt(Q + 1));) oe += te, Q++;
                    Q === ae - 1 ? oe += te : z.charAt(Q + 1) !== ")" && (oe += te + C(), ue = 1)
                } else de === "{" && z.substr(Q, 6) === "{{LT}}" ? (oe += X ? A() + "{{LT}}</" + E + ">" : "{{LT}}", Q += 5) : de.charCodeAt(0) >= 55296 && de.charCodeAt(0) <= 56319 || z.charCodeAt(Q + 1) >= 65024 && z.charCodeAt(Q + 1) <= 65039 ? (re = ((z.substr(Q, 12).split(r) || [])[1] || "").length || 2, oe += X && de !== " " ? A() + z.substr(Q, re) + "</" + E + ">" : z.substr(Q, re), Q += re - 1) : oe += X && de !== " " ? A() + de + "</" + E + ">" : de;
                p.outerHTML = oe + (ue ? se : ""), he && j(pe, "{{LT}}", "<")
            },
            T = function m(p, w, C, A) {
                var E = d(p.childNodes),
                    H = E.length,
                    X = L(w),
                    q, G;
                if (p.nodeType !== 3 || H > 1) {
                    for (w.absolute = !1, q = 0; q < H; q++) G = E[q], G._next = G._isFirst = G._parent = G._wordEnd = null, (G.nodeType !== 3 || /\S+/.test(G.nodeValue)) && (X && G.nodeType !== 3 && P(G).display === "inline" && (G.style.display = "inline-block", G.style.position = "relative"), G._isSplit = !0, m(G, w, C, A));
                    w.absolute = X, p._isSplit = !0;
                    return
                }
                O(p, w, C, A)
            },
            K = function() {
                function m(w, C) {
                    l || x(), this.elements = d(w), this.chars = [], this.words = [], this.lines = [], this._originals = [], this.vars = C || {}, u(this), this.split(C)
                }
                var p = m.prototype;
                return p.split = function(C) {
                    this.isSplit && this.revert(), this.vars = C = C || this.vars, this._originals.length = this.chars.length = this.words.length = this.lines.length = 0;
                    for (var A = this.elements.length, E = C.tag ? C.tag : C.span ? "span" : "div", H = S(C.wordsClass, E), X = S(C.charsClass, E), q, G, ne; --A > -1;) ne = this.elements[A], this._originals[A] = {
                        html: ne.innerHTML,
                        style: ne.getAttribute("style")
                    }, q = ne.clientHeight, G = ne.clientWidth, T(ne, C, H, X), I(ne, C, this.chars, this.words, this.lines, G, q);
                    return this.chars.reverse(), this.words.reverse(), this.lines.reverse(), this.isSplit = !0, this
                }, p.revert = function() {
                    var C = this._originals;
                    if (!C) throw "revert() call wasn't scoped properly.";
                    return this.elements.forEach(function(A, E) {
                        A.innerHTML = C[E].html, A.setAttribute("style", C[E].style || "")
                    }), this.chars = [], this.words = [], this.lines = [], this.isSplit = !1, this
                }, m.create = function(C, A) {
                    return new m(C, A)
                }, m
            }();
        K.version = "3.12.7", K.register = x, t.SplitText = K, t.default = K, Object.defineProperty(t, "__esModule", {
            value: !0
        })
    })
})(mi, mi.exports);
var Xn = mi.exports;
const Vc = () => {
    const n = tr(kn.ScrollTrigger.update);
    return Kc(() => {
        Me.defaults({
            ease: "none"
        }), Me.config({
            force3D: !0
        }), Me.registerPlugin(kn.ScrollTrigger, Xn.SplitText, Jt.CustomEase, Oc.Flip, on, zc.ScrollToPlugin, jc.ScrambleTextPlugin), Jt.CustomEase.create("immg.zoomIn", "0.9, 0.0, 0.4, 1.0"), Jt.CustomEase.create("immg.zoomOut", "0.4, 0.0, 0.1, 1.0"), Jt.CustomEase.create("immg.posIn", "0.4, 0.0, 0.1, 1.0"), Jt.CustomEase.create("immg.posOut", "0.9, 0.0, 0.4, 1.0"), Jt.CustomEase.create("immg.expoOut", "0.14, 1.0, 0.34, 1.0"), Jt.CustomEase.create("immg.expoIn", "0.66, 0.0, 0.86, 0.0"), Jt.CustomEase.create("menuIn", "0.75, 0.0, 0.25, 1.0");
        const e = t => {
            n == null || n.raf(t * 1e3)
        };
        return Me.ticker.add(e), Me.ticker.lagSmoothing(0), () => {
            Me.ticker.remove(e)
        }
    }, [n]), null
};

function Wc({
    children: n
}) {
    return $.jsx(Pc, {
        root: !0,
        autoRaf: !1,
        children: n
    })
}
const Bs = c.createContext(void 0),
    Hc = ({ ...n
    }) => {
        const [e, t] = c.useState(), r = {
            modal: e,
            setModal: t
        };
        return $.jsx(Bs.Provider, {
            value: r,
            ...n
        })
    },
    Uc = () => {
        const n = c.useContext(Bs);
        if (n === void 0) throw new Error("useInteractionState must be used within an InteractionContext");
        return n
    },
    Gc = "_textFadeAnimation_bo663_23",
    Xc = "_hidden_bo663_28",
    qc = "_char_bo663_33",
    Yc = "_line_bo663_37",
    En = {
        textFadeAnimation: Gc,
        hidden: Xc,
        char: qc,
        line: Yc
    },
    bi = ({
        tag: n = "div",
        parentWrapper: e,
        children: t,
        className: r,
        delay: i = 0,
        byChar: o = !0,
        innerHtml: s = !1
    }) => {
        const l = n,
            a = c.useRef(null),
            u = c.useRef(null),
            d = c.useRef(!1);
        return on(async () => {
            var x;
            await document.fonts.ready;
            const h = Me.timeline({
                delay: i
            });
            if (!a.current) {
                console.warn("TextFadeAnimation: No element found", r, n);
                return
            }
            if ((x = a.current) == null || x.classList.remove(En.hidden), o) {
                u.current && u.current.revert(), u.current = new Xn.SplitText(a.current, {
                    type: "words, lines",
                    wordsClass: En.char,
                    linesClass: En.line
                });
                const P = .03,
                    R = u.current.words.length * P;
                h.to(u.current.lines, {
                    y: 0,
                    ease: "power3.out",
                    duration: 1,
                    stagger: .1
                }, 0), h.to(u.current.lines, {
                    opacity: 1,
                    ease: "linear",
                    duration: 1,
                    stagger: .1
                }, .1), h.to(u.current.words, {
                    opacity: 1,
                    duration: R,
                    stagger: P
                }, .1)
            } else u.current && u.current.revert(), u.current = new Xn.SplitText(a.current, {
                type: "lines",
                linesClass: En.line
            }), h.to(u.current.lines, {
                y: 0,
                stagger: .1,
                duration: 1.2,
                ease: "power2.out"
            }, 0), h.to(u.current.lines, {
                opacity: 1,
                stagger: .1,
                duration: 1.2,
                ease: "none"
            }, 0);
            const D = kn.ScrollTrigger.create({
                    trigger: (e == null ? void 0 : e.current) || a.current,
                    start: "top 90%",
                    animation: h,
                    toggleActions: "play complete none none",
                    onEnter: () => {
                        d.current = !0
                    }
                }),
                g = () => {
                    var P;
                    (P = u.current) == null || P.revert(), d.current && (h.kill(), D.kill())
                };
            return window.addEventListener("resize", g), () => {
                window.removeEventListener("resize", g)
            }
        }, []), $.jsx(l, {
            ref: a,
            className: Ge(En.textFadeAnimation, En.hidden, r),
            ...s ? {
                dangerouslySetInnerHTML: {
                    __html: t
                }
            } : {
                children: t
            }
        })
    },
    Zc = "_absoluteText_1mtai_23",
    Jc = "_textScrambleAnimation_1mtai_28",
    Qc = "_centered_1mtai_33",
    ed = "_realText_1mtai_38",
    td = "_charLowercase_1mtai_43",
    Nn = {
        absoluteText: Zc,
        textScrambleAnimation: Jc,
        centered: Qc,
        realText: ed,
        charLowercase: td
    },
    nd = (n, e) => n ? "lowerCase" : e ? "upperCase" : "upperAndLowerCase",
    pt = c.forwardRef(({
        children: n,
        from: e = "",
        timescale: t = 1,
        delay: r = 0,
        onHover: i = !1,
        onInit: o = !1,
        lowercase: s = !1,
        uppercase: l = !1,
        scramble: a = !0,
        centered: u = !1,
        speed: d = .6,
        color: h = "",
        className: D
    }, g) => {
        const x = c.useRef(null),
            P = c.useRef(null),
            L = c.useRef(null),
            {
                contextSafe: R
            } = on({
                scope: x
            }),
            N = () => {
                var I, O;
                const j = Me.timeline({
                    paused: !0
                });
                if (!P.current) return j;
                L.current && L.current.revert(), P.current.textContent = e || n, L.current = new Xn.SplitText(P.current, {
                    type: "chars",
                    charsClass: l ? "" : Nn.charLowercase
                });
                const k = (e || n).split("").filter(T => T !== " "),
                    B = .03,
                    f = L.current.chars.length * B;
                return j.to((I = L.current) == null ? void 0 : I.chars, {
                    opacity: .2,
                    duration: f,
                    stagger: .03,
                    ease: "power2.out",
                    color: h || "inherit"
                }, 0), j.to((O = L.current) == null ? void 0 : O.chars, {
                    opacity: 1,
                    duration: f,
                    stagger: .04,
                    ease: "power2.out",
                    clearProps: "color"
                }, f), a && L.current.chars.forEach((T, K) => {
                    j.to(T, {
                        scrambleText: {
                            text: k[K],
                            speed: d,
                            chars: nd(s, l)
                        },
                        duration: .7,
                        ease: "none"
                    }, K * B + .05)
                }), j.restart()
            },
            S = R(() => {
                P.current && Me.killTweensOf(P.current), Me.timeline({
                    paused: !0
                }).timeScale(t).add(N(), r).restart()
            });
        return c.useEffect(() => {
            o && S()
        }, [S, o]), c.useImperativeHandle(g, () => ({
            el: x.current,
            scrambleText: S
        })), $.jsxs("span", {
            ref: x,
            className: Ge(Nn.textScrambleAnimation, D, {
                [Nn.centered]: u
            }),
            onMouseEnter: i ? () => S() : void 0,
            children: [$.jsxs("span", {
                ref: P,
                "aria-hidden": !0,
                className: Nn.absoluteText,
                children: [e || n, " "]
            }), $.jsx("span", {
                className: Nn.realText,
                children: n
            })]
        })
    });
pt.displayName = "TextScrambleAnimation";
const rd = "_animatedImage_1ril0_23",
    id = {
        animatedImage: rd
    },
    Rs = c.forwardRef(({
        folder: n,
        imagesCount: e = 1
    }, t) => {
        const r = {
                index: 0
            },
            i = c.useRef(null),
            o = c.useRef(null),
            s = c.useRef(null),
            l = c.useRef([]),
            [a, u] = c.useState(!1),
            d = c.useCallback(g => {
                const x = s.current;
                if (o.current && x && l.current[g]) {
                    x.clearRect(0, 0, o.current.width, o.current.height);
                    const P = l.current[g];
                    if (P) {
                        const {
                            offsetX: L,
                            offsetY: R,
                            imgWidth: N,
                            imgHeight: S
                        } = nc(o.current.width, o.current.height, P.naturalWidth, P.naturalHeight);
                        x.drawImage(P, L, R, N, S)
                    }
                }
            }, [l, s]);
        c.useEffect(() => {
            (async () => {
                if (a) return;
                const x = [...Array(e).keys()].map((L, R) => new Promise((N, S) => {
                        const j = new Image;
                        j.src = `/animations/${n}/${R+1}.webp`, j.onload = () => N(j), j.onerror = S
                    })),
                    P = await Promise.allSettled(x);
                l.current = [...P.map(L => L.status === "fulfilled" ? L.value : void 0)], u(!0)
            })()
        }, [n, e, a]);
        const h = c.useCallback(g => {
                if (g) {
                    o.current = g;
                    const x = g.getContext("2d");
                    x && (s.current = x)
                }
            }, []),
            D = c.useCallback(() => {
                o.current && (o.current.width = o.current.clientWidth, o.current.height = o.current.clientHeight, d(0))
            }, [d]);
        return c.useEffect(() => (window.addEventListener("resize", D), D(), () => window.removeEventListener("resize", D)), [D]), on(() => {
            var g;
            return (g = i.current) == null || g.kill(), i.current = Me.timeline({
                paused: !0
            }), i.current.fromTo(r, {
                index: 0
            }, {
                index: e,
                duration: 1.2,
                ease: "steps(" + e + ")",
                onUpdate: () => {
                    isNaN(r.index) && (r.index = e), d(Math.round(r.index))
                }
            }), () => {
                var x;
                (x = i.current) == null || x.kill()
            }
        }), c.useImperativeHandle(t, () => ({
            tl: i.current
        })), $.jsx("div", {
            className: id.animatedImage,
            children: $.jsx("canvas", {
                ref: h
            })
        })
    });
Rs.displayName = "AnimatedImageFooter";
const Fe = typeof document < "u" ? W.useLayoutEffect : () => {};

function it(n) {
    const e = c.useRef(null);
    return Fe(() => {
        e.current = n
    }, [n]), c.useCallback((...t) => {
        const r = e.current;
        return r == null ? void 0 : r(...t)
    }, [])
}

function od(n) {
    let [e, t] = c.useState(n), r = c.useRef(null), i = it(() => {
        if (!r.current) return;
        let s = r.current.next();
        if (s.done) {
            r.current = null;
            return
        }
        e === s.value ? i() : t(s.value)
    });
    Fe(() => {
        r.current && i()
    });
    let o = it(s => {
        r.current = s(e), i()
    });
    return [e, o]
}
const ji = {
        prefix: String(Math.round(Math.random() * 1e10)),
        current: 0
    },
    Ms = W.createContext(ji),
    sd = W.createContext(!1);
let ld = !!(typeof window < "u" && window.document && window.document.createElement),
    Qr = new WeakMap;

function ad(n = !1) {
    let e = c.useContext(Ms),
        t = c.useRef(null);
    if (t.current === null && !n) {
        var r, i;
        let o = (i = W.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || i === void 0 || (r = i.ReactCurrentOwner) === null || r === void 0 ? void 0 : r.current;
        if (o) {
            let s = Qr.get(o);
            s == null ? Qr.set(o, {
                id: e.current,
                state: o.memoizedState
            }) : o.memoizedState !== s.state && (e.current = s.id, Qr.delete(o))
        }
        t.current = ++e.current
    }
    return t.current
}

function ud(n) {
    let e = c.useContext(Ms);
    e === ji && !ld && console.warn("When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.");
    let t = ad(!!n),
        r = `react-aria${e.prefix}`;
    return n || `${r}-${t}`
}

function cd(n) {
    let e = W.useId(),
        [t] = c.useState(Ln()),
        r = t ? "react-aria" : `react-aria${ji.prefix}`;
    return n || `${r}-${e}`
}
const dd = typeof W.useId == "function" ? cd : ud;

function fd() {
    return !1
}

function pd() {
    return !0
}

function hd(n) {
    return () => {}
}

function Ln() {
    return typeof W.useSyncExternalStore == "function" ? W.useSyncExternalStore(hd, fd, pd) : c.useContext(sd)
}
let Dd = !!(typeof window < "u" && window.document && window.document.createElement),
    tn = new Map;

function Ct(n) {
    let [e, t] = c.useState(n), r = c.useRef(null), i = dd(e), o = c.useCallback(s => {
        r.current = s
    }, []);
    return Dd && (tn.has(i) && !tn.get(i).includes(o) ? tn.set(i, [...tn.get(i), o]) : tn.set(i, [o])), Fe(() => {
        let s = i;
        return () => {
            tn.delete(s)
        }
    }, [i]), c.useEffect(() => {
        let s = r.current;
        s && (r.current = null, t(s))
    }), i
}

function vd(n, e) {
    if (n === e) return n;
    let t = tn.get(n);
    if (t) return t.forEach(i => i(e)), e;
    let r = tn.get(e);
    return r ? (r.forEach(i => i(n)), n) : e
}

function $r(n = []) {
    let e = Ct(),
        [t, r] = od(e),
        i = c.useCallback(() => {
            r(function*() {
                yield e, yield document.getElementById(e) ? e : void 0
            })
        }, [e, r]);
    return Fe(i, [e, i, ...n]), t
}

function hn(...n) {
    return (...e) => {
        for (let t of n) typeof t == "function" && t(...e)
    }
}
const Ne = n => {
        var e;
        return (e = n == null ? void 0 : n.ownerDocument) !== null && e !== void 0 ? e : document
    },
    Pt = n => n && "window" in n && n.window === n ? n : Ne(n).defaultView || window;

function Oe(...n) {
    let e = { ...n[0]
    };
    for (let t = 1; t < n.length; t++) {
        let r = n[t];
        for (let i in r) {
            let o = e[i],
                s = r[i];
            typeof o == "function" && typeof s == "function" && i[0] === "o" && i[1] === "n" && i.charCodeAt(2) >= 65 && i.charCodeAt(2) <= 90 ? e[i] = hn(o, s) : (i === "className" || i === "UNSAFE_className") && typeof o == "string" && typeof s == "string" ? e[i] = Ge(o, s) : i === "id" && o && s ? e.id = vd(o, s) : e[i] = s !== void 0 ? s : o
        }
    }
    return e
}

function Ns(...n) {
    return n.length === 1 && n[0] ? n[0] : e => {
        for (let t of n) typeof t == "function" ? t(e) : t != null && (t.current = e)
    }
}
const gd = new Set(["id"]),
    md = new Set(["aria-label", "aria-labelledby", "aria-describedby", "aria-details"]),
    bd = new Set(["href", "hrefLang", "target", "rel", "download", "ping", "referrerPolicy"]),
    yd = /^(data-.*)$/;

function Nt(n, e = {}) {
    let {
        labelable: t,
        isLink: r,
        propNames: i
    } = e, o = {};
    for (const s in n) Object.prototype.hasOwnProperty.call(n, s) && (gd.has(s) || t && md.has(s) || r && bd.has(s) || i != null && i.has(s) || yd.test(s)) && (o[s] = n[s]);
    return o
}

function Ht(n) {
    if (Ed()) n.focus({
        preventScroll: !0
    });
    else {
        let e = Cd(n);
        n.focus(), xd(e)
    }
}
let fr = null;

function Ed() {
    if (fr == null) {
        fr = !1;
        try {
            document.createElement("div").focus({
                get preventScroll() {
                    return fr = !0, !0
                }
            })
        } catch {}
    }
    return fr
}

function Cd(n) {
    let e = n.parentNode,
        t = [],
        r = document.scrollingElement || document.documentElement;
    for (; e instanceof HTMLElement && e !== r;)(e.offsetHeight < e.scrollHeight || e.offsetWidth < e.scrollWidth) && t.push({
        element: e,
        scrollTop: e.scrollTop,
        scrollLeft: e.scrollLeft
    }), e = e.parentNode;
    return r instanceof HTMLElement && t.push({
        element: r,
        scrollTop: r.scrollTop,
        scrollLeft: r.scrollLeft
    }), t
}

function xd(n) {
    for (let {
            element: e,
            scrollTop: t,
            scrollLeft: r
        } of n) e.scrollTop = t, e.scrollLeft = r
}

function Rr(n) {
    var e;
    return typeof window > "u" || window.navigator == null ? !1 : ((e = window.navigator.userAgentData) === null || e === void 0 ? void 0 : e.brands.some(t => n.test(t.brand))) || n.test(window.navigator.userAgent)
}

function zi(n) {
    var e;
    return typeof window < "u" && window.navigator != null ? n.test(((e = window.navigator.userAgentData) === null || e === void 0 ? void 0 : e.platform) || window.navigator.platform) : !1
}

function Xt(n) {
    let e = null;
    return () => (e == null && (e = n()), e)
}
const rn = Xt(function() {
        return zi(/^Mac/i)
    }),
    $d = Xt(function() {
        return zi(/^iPhone/i)
    }),
    Is = Xt(function() {
        return zi(/^iPad/i) || rn() && navigator.maxTouchPoints > 1
    }),
    Mr = Xt(function() {
        return $d() || Is()
    }),
    wd = Xt(function() {
        return rn() || Mr()
    }),
    Vi = Xt(function() {
        return Rr(/AppleWebKit/i) && !Ks()
    }),
    Ks = Xt(function() {
        return Rr(/Chrome/i)
    }),
    Wi = Xt(function() {
        return Rr(/Android/i)
    }),
    Fd = Xt(function() {
        return Rr(/Firefox/i)
    }),
    Sd = c.createContext({
        isNative: !0,
        open: Pd,
        useHref: n => n
    });

function Hi() {
    return c.useContext(Sd)
}

function Dn(n, e, t = !0) {
    var r, i;
    let {
        metaKey: o,
        ctrlKey: s,
        altKey: l,
        shiftKey: a
    } = e;
    Fd() && (!((i = window.event) === null || i === void 0 || (r = i.type) === null || r === void 0) && r.startsWith("key")) && n.target === "_blank" && (rn() ? o = !0 : s = !0);
    let u = Vi() && rn() && !Is() ? new KeyboardEvent("keydown", {
        keyIdentifier: "Enter",
        metaKey: o,
        ctrlKey: s,
        altKey: l,
        shiftKey: a
    }) : new MouseEvent("click", {
        metaKey: o,
        ctrlKey: s,
        altKey: l,
        shiftKey: a,
        bubbles: !0,
        cancelable: !0
    });
    Dn.isOpening = t, Ht(n), n.dispatchEvent(u), Dn.isOpening = !1
}
Dn.isOpening = !1;

function _d(n, e) {
    if (n instanceof HTMLAnchorElement) e(n);
    else if (n.hasAttribute("data-href")) {
        let t = document.createElement("a");
        t.href = n.getAttribute("data-href"), n.hasAttribute("data-target") && (t.target = n.getAttribute("data-target")), n.hasAttribute("data-rel") && (t.rel = n.getAttribute("data-rel")), n.hasAttribute("data-download") && (t.download = n.getAttribute("data-download")), n.hasAttribute("data-ping") && (t.ping = n.getAttribute("data-ping")), n.hasAttribute("data-referrer-policy") && (t.referrerPolicy = n.getAttribute("data-referrer-policy")), n.appendChild(t), e(t), n.removeChild(t)
    }
}

function Pd(n, e) {
    _d(n, t => Dn(t, e))
}

function Td(n) {
    let e = Hi();
    var t;
    const r = e.useHref((t = n == null ? void 0 : n.href) !== null && t !== void 0 ? t : "");
    return {
        href: n != null && n.href ? r : void 0,
        target: n == null ? void 0 : n.target,
        rel: n == null ? void 0 : n.rel,
        download: n == null ? void 0 : n.download,
        ping: n == null ? void 0 : n.ping,
        referrerPolicy: n == null ? void 0 : n.referrerPolicy
    }
}
let $n = new Map,
    yi = new Set;

function Po() {
    if (typeof window > "u") return;

    function n(r) {
        return "propertyName" in r
    }
    let e = r => {
            if (!n(r) || !r.target) return;
            let i = $n.get(r.target);
            i || (i = new Set, $n.set(r.target, i), r.target.addEventListener("transitioncancel", t, {
                once: !0
            })), i.add(r.propertyName)
        },
        t = r => {
            if (!n(r) || !r.target) return;
            let i = $n.get(r.target);
            if (i && (i.delete(r.propertyName), i.size === 0 && (r.target.removeEventListener("transitioncancel", t), $n.delete(r.target)), $n.size === 0)) {
                for (let o of yi) o();
                yi.clear()
            }
        };
    document.body.addEventListener("transitionrun", e), document.body.addEventListener("transitionend", t)
}
typeof document < "u" && (document.readyState !== "loading" ? Po() : document.addEventListener("DOMContentLoaded", Po));

function Os(n) {
    requestAnimationFrame(() => {
        $n.size === 0 ? n() : yi.add(n)
    })
}

function js() {
    let n = c.useRef(new Map),
        e = c.useCallback((i, o, s, l) => {
            let a = l != null && l.once ? (...u) => {
                n.current.delete(s), s(...u)
            } : s;
            n.current.set(s, {
                type: o,
                eventTarget: i,
                fn: a,
                options: l
            }), i.addEventListener(o, a, l)
        }, []),
        t = c.useCallback((i, o, s, l) => {
            var a;
            let u = ((a = n.current.get(s)) === null || a === void 0 ? void 0 : a.fn) || s;
            i.removeEventListener(o, u, l), n.current.delete(s)
        }, []),
        r = c.useCallback(() => {
            n.current.forEach((i, o) => {
                t(i.eventTarget, i.type, o, i.options)
            })
        }, [t]);
    return c.useEffect(() => r, [r]), {
        addGlobalListener: e,
        removeGlobalListener: t,
        removeAllGlobalListeners: r
    }
}

function zs(n, e) {
    let {
        id: t,
        "aria-label": r,
        "aria-labelledby": i
    } = n;
    return t = Ct(t), i && r ? i = [...new Set([t, ...i.trim().split(/\s+/)])].join(" ") : i && (i = i.trim().split(/\s+/).join(" ")), !r && !i && e && (r = e), {
        id: t,
        "aria-label": r,
        "aria-labelledby": i
    }
}

function Nr(n) {
    const e = c.useRef(null);
    return c.useMemo(() => ({
        get current() {
            return e.current
        },
        set current(t) {
            e.current = t, typeof n == "function" ? n(t) : n && (n.current = t)
        }
    }), [n])
}

function To(n, e) {
    const t = c.useRef(!0),
        r = c.useRef(null);
    Fe(() => (t.current = !0, () => {
        t.current = !1
    }), []), Fe(() => {
        t.current ? t.current = !1 : (!r.current || e.some((i, o) => !Object.is(i, r[o]))) && n(), r.current = e
    }, e)
}

function kd() {
    return typeof window.ResizeObserver < "u"
}

function Ei(n) {
    const {
        ref: e,
        box: t,
        onResize: r
    } = n;
    c.useEffect(() => {
        let i = e == null ? void 0 : e.current;
        if (i)
            if (kd()) {
                const o = new window.ResizeObserver(s => {
                    s.length && r()
                });
                return o.observe(i, {
                    box: t
                }), () => {
                    i && o.unobserve(i)
                }
            } else return window.addEventListener("resize", r, !1), () => {
                window.removeEventListener("resize", r, !1)
            }
    }, [r, e, t])
}

function Vs(n, e) {
    Fe(() => {
        if (n && n.ref && e) return n.ref.current = e.current, () => {
            n.ref && (n.ref.current = null)
        }
    })
}

function qn(n, e) {
    if (!n) return !1;
    let t = window.getComputedStyle(n),
        r = /(auto|scroll)/.test(t.overflow + t.overflowX + t.overflowY);
    return r && e && (r = n.scrollHeight !== n.clientHeight || n.scrollWidth !== n.clientWidth), r
}

function Ws(n, e) {
    let t = n;
    for (qn(t, e) && (t = t.parentElement); t && !qn(t, e);) t = t.parentElement;
    return t || document.scrollingElement || document.documentElement
}

function Ad(n, e) {
    const t = [];
    for (; n && n !== document.documentElement;) qn(n, e) && t.push(n), n = n.parentElement;
    return t
}
let Ld = 0;
const ei = new Map;

function Bd(n) {
    let [e, t] = c.useState();
    return Fe(() => {
        if (!n) return;
        let r = ei.get(n);
        if (r) t(r.element.id);
        else {
            let i = `react-aria-description-${Ld++}`;
            t(i);
            let o = document.createElement("div");
            o.id = i, o.style.display = "none", o.textContent = n, document.body.appendChild(o), r = {
                refCount: 0,
                element: o
            }, ei.set(n, r)
        }
        return r.refCount++, () => {
            r && --r.refCount === 0 && (r.element.remove(), ei.delete(n))
        }
    }, [n]), {
        "aria-describedby": n ? e : void 0
    }
}

function pr(n, e, t, r) {
    let i = it(t),
        o = t == null;
    c.useEffect(() => {
        if (o || !n.current) return;
        let s = n.current;
        return s.addEventListener(e, i, r), () => {
            s.removeEventListener(e, i, r)
        }
    }, [n, e, r, o, i])
}

function Hs(n, e) {
    let t = ko(n, e, "left"),
        r = ko(n, e, "top"),
        i = e.offsetWidth,
        o = e.offsetHeight,
        s = n.scrollLeft,
        l = n.scrollTop,
        {
            borderTopWidth: a,
            borderLeftWidth: u,
            scrollPaddingTop: d,
            scrollPaddingRight: h,
            scrollPaddingBottom: D,
            scrollPaddingLeft: g
        } = getComputedStyle(n),
        x = s + parseInt(u, 10),
        P = l + parseInt(a, 10),
        L = x + n.clientWidth,
        R = P + n.clientHeight,
        N = parseInt(d, 10) || 0,
        S = parseInt(D, 10) || 0,
        j = parseInt(h, 10) || 0,
        k = parseInt(g, 10) || 0;
    t <= s + k ? s = t - parseInt(u, 10) - k : t + i > L - j && (s += t + i - L + j), r <= P + N ? l = r - parseInt(a, 10) - N : r + o > R - S && (l += r + o - R + S), n.scrollLeft = s, n.scrollTop = l
}

function ko(n, e, t) {
    const r = t === "left" ? "offsetLeft" : "offsetTop";
    let i = 0;
    for (; e.offsetParent && (i += e[r], e.offsetParent !== n);) {
        if (e.offsetParent.contains(n)) {
            i -= n[r];
            break
        }
        e = e.offsetParent
    }
    return i
}

function Ao(n, e) {
    if (n && document.contains(n)) {
        let s = document.scrollingElement || document.documentElement;
        if (window.getComputedStyle(s).overflow === "hidden") {
            let a = Ad(n);
            for (let u of a) Hs(u, n)
        } else {
            var t;
            let {
                left: a,
                top: u
            } = n.getBoundingClientRect();
            n == null || (t = n.scrollIntoView) === null || t === void 0 || t.call(n, {
                block: "nearest"
            });
            let {
                left: d,
                top: h
            } = n.getBoundingClientRect();
            if (Math.abs(a - d) > 1 || Math.abs(u - h) > 1) {
                var r, i, o;
                e == null || (i = e.containingElement) === null || i === void 0 || (r = i.scrollIntoView) === null || r === void 0 || r.call(i, {
                    block: "center",
                    inline: "center"
                }), (o = n.scrollIntoView) === null || o === void 0 || o.call(n, {
                    block: "nearest"
                })
            }
        }
    }
}

function Ci(n) {
    return n.mozInputSource === 0 && n.isTrusted ? !0 : Wi() && n.pointerType ? n.type === "click" && n.buttons === 1 : n.detail === 0 && !n.pointerType
}

function Rd(n) {
    return !Wi() && n.width === 0 && n.height === 0 || n.width === 1 && n.height === 1 && n.pressure === 0 && n.detail === 0 && n.pointerType === "mouse"
}

function Md(n, e, t) {
    let r = c.useRef(e),
        i = it(() => {
            t && t(r.current)
        });
    c.useEffect(() => {
        var o;
        let s = n == null || (o = n.current) === null || o === void 0 ? void 0 : o.form;
        return s == null || s.addEventListener("reset", i), () => {
            s == null || s.removeEventListener("reset", i)
        }
    }, [n, i])
}
const Nd = "react-aria-clear-focus",
    Id = "react-aria-focus",
    Us = "react-aria-update-activedescendant";

function wn(n) {
    return rn() ? n.metaKey : n.ctrlKey
}

function Kd(n, e = !0) {
    let [t, r] = c.useState(!0), i = t && e;
    return Fe(() => {
        if (i && n.current && "getAnimations" in n.current)
            for (let o of n.current.getAnimations()) o instanceof CSSTransition && o.cancel()
    }, [n, i]), Gs(n, i, c.useCallback(() => r(!1), [])), i
}

function Od(n, e) {
    let [t, r] = c.useState(e ? "open" : "closed");
    switch (t) {
        case "open":
            e || r("exiting");
            break;
        case "closed":
        case "exiting":
            e && r("open");
            break
    }
    let i = t === "exiting";
    return Gs(n, i, c.useCallback(() => {
        r(o => o === "exiting" ? "closed" : o)
    }, [])), i
}

function Gs(n, e, t) {
    Fe(() => {
        if (e && n.current) {
            if (!("getAnimations" in n.current)) {
                t();
                return
            }
            let r = n.current.getAnimations();
            if (r.length === 0) {
                t();
                return
            }
            let i = !1;
            return Promise.all(r.map(o => o.finished)).then(() => {
                i || Ar.flushSync(() => {
                    t()
                })
            }).catch(() => {}), () => {
                i = !0
            }
        }
    }, [n, e, t])
}

function Ui(n, e, t) {
    let [r, i] = c.useState(n || e), o = c.useRef(n !== void 0), s = n !== void 0;
    c.useEffect(() => {
        let u = o.current;
        u !== s && console.warn(`WARN: A component changed from ${u?"controlled":"uncontrolled"} to ${s?"controlled":"uncontrolled"}.`), o.current = s
    }, [s]);
    let l = s ? n : r,
        a = c.useCallback((u, ...d) => {
            let h = (D, ...g) => {
                t && (Object.is(l, D) || t(D, ...g)), s || (l = D)
            };
            typeof u == "function" ? (console.warn("We can not support a function callback. See Github Issues for details https://github.com/adobe/react-spectrum/issues/2320"), i((g, ...x) => {
                let P = u(s ? l : g, ...x);
                return h(P, ...d), s ? g : P
            })) : (s || i(u), h(u, ...d))
        }, [s, l, t]);
    return [l, a]
}

function xi(n, e = -1 / 0, t = 1 / 0) {
    return Math.min(Math.max(n, e), t)
}
const Lo = Symbol("default");

function Gi({
    values: n,
    children: e
}) {
    for (let [t, r] of n) e = W.createElement(t.Provider, {
        value: r
    }, e);
    return e
}

function sn(n) {
    let {
        className: e,
        style: t,
        children: r,
        defaultClassName: i,
        defaultChildren: o,
        defaultStyle: s,
        values: l
    } = n;
    return c.useMemo(() => {
        let a, u, d;
        return typeof e == "function" ? a = e({ ...l,
            defaultClassName: i
        }) : a = e, typeof t == "function" ? u = t({ ...l,
            defaultStyle: s || {}
        }) : u = t, typeof r == "function" ? d = r({ ...l,
            defaultChildren: o
        }) : r == null ? d = o : d = r, {
            className: a ? ? i,
            style: u || s ? { ...s,
                ...u
            } : void 0,
            children: d ? ? o,
            "data-rac": ""
        }
    }, [e, t, r, i, o, s, l])
}

function Xi(n, e) {
    let t = c.useContext(n);
    if (e === null) return null;
    if (t && typeof t == "object" && "slots" in t && t.slots) {
        let r = new Intl.ListFormat().format(Object.keys(t.slots).map(o => `"${o}"`));
        if (!e && !t.slots[Lo]) throw new Error(`A slot prop is required. Valid slot names are ${r}.`);
        let i = e || Lo;
        if (!t.slots[i]) throw new Error(`Invalid slot "${e}". Valid slot names are ${r}.`);
        return t.slots[i]
    }
    return t
}

function nr(n, e, t) {
    let r = Xi(t, n.slot) || {},
        {
            ref: i,
            ...o
        } = r,
        s = Nr(c.useMemo(() => Ns(e, i), [e, i])),
        l = Oe(o, n);
    return "style" in o && o.style && "style" in n && n.style && (typeof o.style == "function" || typeof n.style == "function" ? l.style = a => {
        let u = typeof o.style == "function" ? o.style(a) : o.style,
            d = { ...a.defaultStyle,
                ...u
            },
            h = typeof n.style == "function" ? n.style({ ...a,
                defaultStyle: d
            }) : n.style;
        return { ...d,
            ...h
        }
    } : l.style = { ...o.style,
        ...n.style
    }), [l, s]
}

function Xs() {
    let [n, e] = c.useState(!0), t = c.useRef(!1), r = c.useCallback(i => {
        t.current = !0, e(!!i)
    }, []);
    return Fe(() => {
        t.current || e(!1)
    }, []), [r, n]
}

function jd(n) {
    const e = /^(data-.*)$/;
    let t = {};
    for (const r in n) e.test(r) || (t[r] = n[r]);
    return t
}
class qi {
    get childNodes() {
        throw new Error("childNodes is not supported")
    }
    clone() {
        let e = new qi(this.type, this.key);
        return e.value = this.value, e.level = this.level, e.hasChildNodes = this.hasChildNodes, e.rendered = this.rendered, e.textValue = this.textValue, e["aria-label"] = this["aria-label"], e.index = this.index, e.parentKey = this.parentKey, e.prevKey = this.prevKey, e.nextKey = this.nextKey, e.firstChildKey = this.firstChildKey, e.lastChildKey = this.lastChildKey, e.props = this.props, e.render = this.render, e
    }
    constructor(e, t) {
        this.value = null, this.level = 0, this.hasChildNodes = !1, this.rendered = null, this.textValue = "", this["aria-label"] = void 0, this.index = 0, this.parentKey = null, this.prevKey = null, this.nextKey = null, this.firstChildKey = null, this.lastChildKey = null, this.props = {}, this.type = e, this.key = t
    }
}
class Yi {
    get size() {
        return this.keyMap.size
    }
    getKeys() {
        return this.keyMap.keys()
    }*[Symbol.iterator]() {
        let e = this.firstKey != null ? this.keyMap.get(this.firstKey) : void 0;
        for (; e;) yield e, e = e.nextKey != null ? this.keyMap.get(e.nextKey) : void 0
    }
    getChildren(e) {
        let t = this.keyMap;
        return {*[Symbol.iterator]() {
                let r = t.get(e),
                    i = (r == null ? void 0 : r.firstChildKey) != null ? t.get(r.firstChildKey) : null;
                for (; i;) yield i, i = i.nextKey != null ? t.get(i.nextKey) : void 0
            }
        }
    }
    getKeyBefore(e) {
        let t = this.keyMap.get(e);
        if (!t) return null;
        if (t.prevKey != null) {
            for (t = this.keyMap.get(t.prevKey); t && t.type !== "item" && t.lastChildKey != null;) t = this.keyMap.get(t.lastChildKey);
            var r;
            return (r = t == null ? void 0 : t.key) !== null && r !== void 0 ? r : null
        }
        return t.parentKey
    }
    getKeyAfter(e) {
        let t = this.keyMap.get(e);
        if (!t) return null;
        if (t.type !== "item" && t.firstChildKey != null) return t.firstChildKey;
        for (; t;) {
            if (t.nextKey != null) return t.nextKey;
            if (t.parentKey != null) t = this.keyMap.get(t.parentKey);
            else return null
        }
        return null
    }
    getFirstKey() {
        return this.firstKey
    }
    getLastKey() {
        let e = this.lastKey != null ? this.keyMap.get(this.lastKey) : null;
        for (;
            (e == null ? void 0 : e.lastChildKey) != null;) e = this.keyMap.get(e.lastChildKey);
        var t;
        return (t = e == null ? void 0 : e.key) !== null && t !== void 0 ? t : null
    }
    getItem(e) {
        var t;
        return (t = this.keyMap.get(e)) !== null && t !== void 0 ? t : null
    }
    at() {
        throw new Error("Not implemented")
    }
    clone() {
        let e = this.constructor,
            t = new e;
        return t.keyMap = new Map(this.keyMap), t.firstKey = this.firstKey, t.lastKey = this.lastKey, t
    }
    addNode(e) {
        if (this.frozen) throw new Error("Cannot add a node to a frozen collection");
        this.keyMap.set(e.key, e)
    }
    removeNode(e) {
        if (this.frozen) throw new Error("Cannot remove a node to a frozen collection");
        this.keyMap.delete(e)
    }
    commit(e, t, r = !1) {
        if (this.frozen) throw new Error("Cannot commit a frozen collection");
        this.firstKey = e, this.lastKey = t, this.frozen = !r
    }
    filter(e) {
        let t = new Yi,
            r = null;
        for (let i of this)
            if (i.type === "section" && i.hasChildNodes) {
                let o = i.clone(),
                    s = null;
                for (let l of this.getChildren(i.key))
                    if (e(l.textValue) || l.type === "header") {
                        let a = l.clone();
                        s == null && (o.firstChildKey = a.key), t.firstKey == null && (t.firstKey = o.key), s && s.parentKey === a.parentKey ? (s.nextKey = a.key, a.prevKey = s.key) : a.prevKey = null, a.nextKey = null, t.addNode(a), s = a
                    }
                s && (s.type !== "header" ? (o.lastChildKey = s.key, r == null ? o.prevKey = null : (r.type === "section" || r.type === "separator") && (r.nextKey = o.key, o.prevKey = r.key), o.nextKey = null, r = o, t.addNode(o)) : (t.firstKey === o.key && (t.firstKey = null), t.removeNode(s.key)))
            } else if (i.type === "separator") {
            let o = i.clone();
            o.nextKey = null, (r == null ? void 0 : r.type) === "section" && (r.nextKey = o.key, o.prevKey = r.key, r = o, t.addNode(o))
        } else if (e(i.textValue)) {
            let o = i.clone();
            t.firstKey == null && (t.firstKey = o.key), r != null && r.type !== "section" && r.type !== "separator" && r.parentKey === o.parentKey ? (r.nextKey = o.key, o.prevKey = r.key) : o.prevKey = null, o.nextKey = null, t.addNode(o), r = o
        }
        if ((r == null ? void 0 : r.type) === "separator" && r.nextKey === null) {
            let i;
            r.prevKey != null && (i = t.getItem(r.prevKey), i.nextKey = null), t.removeNode(r.key), r = i
        }
        return t.lastKey = (r == null ? void 0 : r.key) || null, t
    }
    constructor() {
        this.keyMap = new Map, this.firstKey = null, this.lastKey = null, this.frozen = !1
    }
}
class qs {*[Symbol.iterator]() {
        let e = this.firstChild;
        for (; e;) yield e, e = e.nextSibling
    }
    get firstChild() {
        return this._firstChild
    }
    set firstChild(e) {
        this._firstChild = e, this.ownerDocument.markDirty(this)
    }
    get lastChild() {
        return this._lastChild
    }
    set lastChild(e) {
        this._lastChild = e, this.ownerDocument.markDirty(this)
    }
    get previousSibling() {
        return this._previousSibling
    }
    set previousSibling(e) {
        this._previousSibling = e, this.ownerDocument.markDirty(this)
    }
    get nextSibling() {
        return this._nextSibling
    }
    set nextSibling(e) {
        this._nextSibling = e, this.ownerDocument.markDirty(this)
    }
    get parentNode() {
        return this._parentNode
    }
    set parentNode(e) {
        this._parentNode = e, this.ownerDocument.markDirty(this)
    }
    get isConnected() {
        var e;
        return ((e = this.parentNode) === null || e === void 0 ? void 0 : e.isConnected) || !1
    }
    appendChild(e) {
        this.ownerDocument.startTransaction(), e.parentNode && e.parentNode.removeChild(e), this.firstChild == null && (this.firstChild = e), this.lastChild ? (this.lastChild.nextSibling = e, e.index = this.lastChild.index + 1, e.previousSibling = this.lastChild) : (e.previousSibling = null, e.index = 0), e.parentNode = this, e.nextSibling = null, this.lastChild = e, this.ownerDocument.markDirty(this), e.hasSetProps && this.ownerDocument.addNode(e), this.ownerDocument.endTransaction(), this.ownerDocument.queueUpdate()
    }
    insertBefore(e, t) {
        if (t == null) return this.appendChild(e);
        this.ownerDocument.startTransaction(), e.parentNode && e.parentNode.removeChild(e), e.nextSibling = t, e.previousSibling = t.previousSibling, e.index = t.index, this.firstChild === t ? this.firstChild = e : t.previousSibling && (t.previousSibling.nextSibling = e), t.previousSibling = e, e.parentNode = t.parentNode;
        let r = t;
        for (; r;) r.index++, r = r.nextSibling;
        e.hasSetProps && this.ownerDocument.addNode(e), this.ownerDocument.endTransaction(), this.ownerDocument.queueUpdate()
    }
    removeChild(e) {
        if (e.parentNode !== this || !this.ownerDocument.isMounted) return;
        this.ownerDocument.startTransaction();
        let t = e.nextSibling;
        for (; t;) t.index--, t = t.nextSibling;
        e.nextSibling && (e.nextSibling.previousSibling = e.previousSibling), e.previousSibling && (e.previousSibling.nextSibling = e.nextSibling), this.firstChild === e && (this.firstChild = e.nextSibling), this.lastChild === e && (this.lastChild = e.previousSibling), e.parentNode = null, e.nextSibling = null, e.previousSibling = null, e.index = 0, this.ownerDocument.removeNode(e), this.ownerDocument.endTransaction(), this.ownerDocument.queueUpdate()
    }
    addEventListener() {}
    removeEventListener() {}
    constructor(e) {
        this._firstChild = null, this._lastChild = null, this._previousSibling = null, this._nextSibling = null, this._parentNode = null, this.ownerDocument = e
    }
}
class Yn extends qs {
    get index() {
        return this._index
    }
    set index(e) {
        this._index = e, this.ownerDocument.markDirty(this)
    }
    get level() {
        return this.parentNode instanceof Yn ? this.parentNode.level + (this.node.type === "item" ? 1 : 0) : 0
    }
    updateNode() {
        var e, t, r, i;
        let o = this.ownerDocument.getMutableNode(this);
        o.index = this.index, o.level = this.level, o.parentKey = this.parentNode instanceof Yn ? this.parentNode.node.key : null;
        var s;
        o.prevKey = (s = (e = this.previousSibling) === null || e === void 0 ? void 0 : e.node.key) !== null && s !== void 0 ? s : null;
        var l;
        o.nextKey = (l = (t = this.nextSibling) === null || t === void 0 ? void 0 : t.node.key) !== null && l !== void 0 ? l : null, o.hasChildNodes = !!this.firstChild;
        var a;
        o.firstChildKey = (a = (r = this.firstChild) === null || r === void 0 ? void 0 : r.node.key) !== null && a !== void 0 ? a : null;
        var u;
        o.lastChildKey = (u = (i = this.lastChild) === null || i === void 0 ? void 0 : i.node.key) !== null && u !== void 0 ? u : null
    }
    setProps(e, t, r, i) {
        let o = this.ownerDocument.getMutableNode(this),
            {
                value: s,
                textValue: l,
                id: a,
                ...u
            } = e;
        if (u.ref = t, o.props = u, o.rendered = r, o.render = i, o.value = s, o.textValue = l || (typeof u.children == "string" ? u.children : "") || e["aria-label"] || "", a != null && a !== o.key) {
            if (this.hasSetProps) throw new Error("Cannot change the id of an item");
            o.key = a
        }
        this.hasSetProps || (this.ownerDocument.addNode(this), this.ownerDocument.endTransaction(), this.hasSetProps = !0), this.ownerDocument.queueUpdate()
    }
    get style() {
        return {}
    }
    hasAttribute() {}
    setAttribute() {}
    setAttributeNS() {}
    removeAttribute() {}
    constructor(e, t) {
        super(t), this.nodeType = 8, this._index = 0, this.hasSetProps = !1, this.node = new qi(e, `react-aria-${++t.nodeId}`), this.ownerDocument.startTransaction()
    }
}
class zd extends qs {
    get isConnected() {
        return this.isMounted
    }
    createElement(e) {
        return new Yn(e, this)
    }
    getMutableNode(e) {
        let t = e.node;
        return this.mutatedNodes.has(e) || (t = e.node.clone(), this.mutatedNodes.add(e), e.node = t), this.markDirty(e), t
    }
    getMutableCollection() {
        return !this.isSSR && !this.collectionMutated && (this.collection = this.collection.clone(), this.collectionMutated = !0), this.collection
    }
    markDirty(e) {
        this.dirtyNodes.add(e)
    }
    startTransaction() {
        this.transactionCount++
    }
    endTransaction() {
        this.transactionCount--
    }
    addNode(e) {
        let t = this.getMutableCollection();
        if (!t.getItem(e.node.key)) {
            t.addNode(e.node);
            for (let r of e) this.addNode(r)
        }
        this.markDirty(e)
    }
    removeNode(e) {
        for (let r of e) this.removeNode(r);
        this.getMutableCollection().removeNode(e.node.key), this.markDirty(e)
    }
    getCollection() {
        return this.transactionCount > 0 ? this.collection : (this.updateCollection(), this.collection)
    }
    updateCollection() {
        for (let o of this.dirtyNodes) o instanceof Yn && o.isConnected && o.updateNode();
        if (this.dirtyNodes.clear(), this.mutatedNodes.size || this.collectionMutated) {
            var e, t;
            let o = this.getMutableCollection();
            for (let s of this.mutatedNodes) s.isConnected && o.addNode(s.node);
            var r, i;
            o.commit((r = (e = this.firstChild) === null || e === void 0 ? void 0 : e.node.key) !== null && r !== void 0 ? r : null, (i = (t = this.lastChild) === null || t === void 0 ? void 0 : t.node.key) !== null && i !== void 0 ? i : null, this.isSSR), this.mutatedNodes.clear()
        }
        this.collectionMutated = !1
    }
    queueUpdate() {
        if (!(this.dirtyNodes.size === 0 || this.transactionCount > 0))
            for (let e of this.subscriptions) e()
    }
    subscribe(e) {
        return this.subscriptions.add(e), () => this.subscriptions.delete(e)
    }
    resetAfterSSR() {
        this.isSSR && (this.isSSR = !1, this.firstChild = null, this.lastChild = null, this.nodeId = 0)
    }
    constructor(e) {
        super(null), this.nodeType = 11, this.ownerDocument = this, this.dirtyNodes = new Set, this.isSSR = !1, this.nodeId = 0, this.nodesByProps = new WeakMap, this.isMounted = !0, this.mutatedNodes = new Set, this.subscriptions = new Set, this.transactionCount = 0, this.collection = e, this.collectionMutated = !0
    }
}

function Ys(n) {
    let {
        children: e,
        items: t,
        idScope: r,
        addIdAndValue: i,
        dependencies: o = []
    } = n, s = c.useMemo(() => new WeakMap, o);
    return c.useMemo(() => {
        if (t && typeof e == "function") {
            let u = [];
            for (let d of t) {
                let h = s.get(d);
                if (!h) {
                    h = e(d);
                    var l, a;
                    let D = (a = (l = h.props.id) !== null && l !== void 0 ? l : d.key) !== null && a !== void 0 ? a : d.id;
                    if (D == null) throw new Error("Could not determine key for item");
                    r && (D = r + ":" + D), h = c.cloneElement(h, i ? {
                        key: D,
                        id: D,
                        value: d
                    } : {
                        key: D
                    }), s.set(d, h)
                }
                u.push(h)
            }
            return u
        } else if (typeof e != "function") return e
    }, [e, t, s, r, i])
}
if (typeof HTMLTemplateElement < "u") {
    const n = Object.getOwnPropertyDescriptor(Node.prototype, "firstChild").get;
    Object.defineProperty(HTMLTemplateElement.prototype, "firstChild", {
        configurable: !0,
        enumerable: !0,
        get: function() {
            return this.dataset.reactAriaHidden ? this.content.firstChild : n.call(this)
        }
    })
}
const wr = c.createContext(!1),
    Vd = typeof DocumentFragment < "u" ? new DocumentFragment : null;

function Wd(n) {
    let e = c.useContext(wr),
        t = Ln();
    if (e) return W.createElement(W.Fragment, null, n.children);
    let r = W.createElement(wr.Provider, {
        value: !0
    }, n.children);
    return t ? W.createElement("template", {
        "data-react-aria-hidden": !0
    }, r) : Ar.createPortal(r, Vd)
}

function Hd(n) {
    let e = (t, r) => c.useContext(wr) ? null : n(t, r);
    return e.displayName = n.displayName || n.name, c.forwardRef(e)
}

function Ud() {
    return c.useContext(wr)
}
const Zs = c.createContext(!1),
    Zn = c.createContext(null);

function Js(n) {
    if (c.useContext(Zn)) return n.content;
    let {
        collection: t,
        document: r
    } = Yd(n.createCollection);
    return W.createElement(W.Fragment, null, W.createElement(Wd, null, W.createElement(Zn.Provider, {
        value: r
    }, n.content)), W.createElement(Gd, {
        render: n.children,
        collection: t
    }))
}

function Gd({
    collection: n,
    render: e
}) {
    return e(n)
}

function Xd(n, e, t) {
    let r = Ln(),
        i = c.useRef(r);
    i.current = r;
    let o = c.useCallback(() => i.current ? t() : e(), [e, t]);
    return xs.useSyncExternalStore(n, o)
}
const qd = typeof W.useSyncExternalStore == "function" ? W.useSyncExternalStore : Xd;

function Yd(n) {
    let [e] = c.useState(() => new zd((n == null ? void 0 : n()) || new Yi)), t = c.useCallback(s => e.subscribe(s), [e]), r = c.useCallback(() => {
        let s = e.getCollection();
        return e.isSSR && e.resetAfterSSR(), s
    }, [e]), i = c.useCallback(() => (e.isSSR = !0, e.getCollection()), [e]), o = qd(t, r, i);
    return Fe(() => (e.isMounted = !0, () => {
        e.isMounted = !1
    }), [e]), {
        collection: o,
        document: e
    }
}
const $i = c.createContext(null);

function Zd(n, e, t, r, i, o) {
    let s = c.useCallback(a => {
            a == null || a.setProps(e, t, r, o)
        }, [e, t, r, o]),
        l = c.useContext($i);
    if (l) {
        let a = l.ownerDocument.nodesByProps.get(e);
        return a || (a = l.ownerDocument.createElement(n), a.setProps(e, t, r, o), l.appendChild(a), l.ownerDocument.updateCollection(), l.ownerDocument.nodesByProps.set(e, a)), i ? W.createElement($i.Provider, {
            value: a
        }, i) : null
    }
    return W.createElement(n, {
        ref: s
    }, i)
}

function Jd(n, e) {
    let t = ({
            node: i
        }) => e(i.props, i.props.ref, i),
        r = c.forwardRef((i, o) => {
            if (!c.useContext(Zs)) {
                if (e.length >= 3) throw new Error(e.name + " cannot be rendered outside a collection.");
                return e(i, o)
            }
            return Zd(n, i, o, "children" in i ? i.children : null, null, l => W.createElement(t, {
                node: l
            }))
        });
    return r.displayName = e.name, r
}

function Qd(n) {
    return Ys({ ...n,
        addIdAndValue: !0
    })
}
const Bo = c.createContext(null);

function ef(n) {
    let e = c.useContext(Bo),
        t = ((e == null ? void 0 : e.dependencies) || []).concat(n.dependencies),
        r = n.idScope || (e == null ? void 0 : e.idScope),
        i = Qd({ ...n,
            idScope: r,
            dependencies: t
        });
    return c.useContext(Zn) && (i = W.createElement(tf, null, i)), e = c.useMemo(() => ({
        dependencies: t,
        idScope: r
    }), [r, ...t]), W.createElement(Bo.Provider, {
        value: e
    }, i)
}

function tf({
    children: n
}) {
    let e = c.useContext(Zn),
        t = c.useMemo(() => W.createElement(Zn.Provider, {
            value: null
        }, W.createElement(Zs.Provider, {
            value: !0
        }, n)), [n]);
    return Ln() ? W.createElement($i.Provider, {
        value: e
    }, t) : Ar.createPortal(t, e)
}
const nf = c.createContext({});
let Fn = "default",
    wi = "",
    Er = new WeakMap;

function Ro(n) {
    if (Mr()) {
        if (Fn === "default") {
            const e = Ne(n);
            wi = e.documentElement.style.webkitUserSelect, e.documentElement.style.webkitUserSelect = "none"
        }
        Fn = "disabled"
    } else(n instanceof HTMLElement || n instanceof SVGElement) && (Er.set(n, n.style.userSelect), n.style.userSelect = "none")
}

function hr(n) {
    if (Mr()) {
        if (Fn !== "disabled") return;
        Fn = "restoring", setTimeout(() => {
            Os(() => {
                if (Fn === "restoring") {
                    const e = Ne(n);
                    e.documentElement.style.webkitUserSelect === "none" && (e.documentElement.style.webkitUserSelect = wi || ""), wi = "", Fn = "default"
                }
            })
        }, 300)
    } else if ((n instanceof HTMLElement || n instanceof SVGElement) && n && Er.has(n)) {
        let e = Er.get(n);
        n.style.userSelect === "none" && (n.style.userSelect = e), n.getAttribute("style") === "" && n.removeAttribute("style"), Er.delete(n)
    }
}
const Zi = W.createContext({
    register: () => {}
});
Zi.displayName = "PressResponderContext";

function rf(n, e) {
    return e.get ? e.get.call(n) : e.value
}

function Qs(n, e, t) {
    if (!e.has(n)) throw new TypeError("attempted to " + t + " private field on non-instance");
    return e.get(n)
}

function of (n, e) {
    var t = Qs(n, e, "get");
    return rf(n, t)
}

function sf(n, e) {
    if (e.has(n)) throw new TypeError("Cannot initialize the same private elements twice on an object")
}

function lf(n, e, t) {
    sf(n, e), e.set(n, t)
}

function af(n, e, t) {
    if (e.set) e.set.call(n, t);
    else {
        if (!e.writable) throw new TypeError("attempted to set read only private field");
        e.value = t
    }
}

function Mo(n, e, t) {
    var r = Qs(n, e, "set");
    return af(n, r, t), t
}

function uf(n) {
    let e = c.useContext(Zi);
    if (e) {
        let {
            register: t,
            ...r
        } = e;
        n = Oe(r, n), t()
    }
    return Vs(e, n.ref), n
}
var Dr = new WeakMap;
class vr {
    continuePropagation() {
        Mo(this, Dr, !1)
    }
    get shouldStopPropagation() {
        return of(this, Dr)
    }
    constructor(e, t, r, i) {
        lf(this, Dr, {
            writable: !0,
            value: void 0
        }), Mo(this, Dr, !0);
        var o;
        let s = (o = i == null ? void 0 : i.target) !== null && o !== void 0 ? o : r.currentTarget;
        const l = s == null ? void 0 : s.getBoundingClientRect();
        let a, u = 0,
            d, h = null;
        r.clientX != null && r.clientY != null && (d = r.clientX, h = r.clientY), l && (d != null && h != null ? (a = d - l.left, u = h - l.top) : (a = l.width / 2, u = l.height / 2)), this.type = e, this.pointerType = t, this.target = r.currentTarget, this.shiftKey = r.shiftKey, this.metaKey = r.metaKey, this.ctrlKey = r.ctrlKey, this.altKey = r.altKey, this.x = a, this.y = u
    }
}
const No = Symbol("linkClicked");

function Ji(n) {
    let {
        onPress: e,
        onPressChange: t,
        onPressStart: r,
        onPressEnd: i,
        onPressUp: o,
        isDisabled: s,
        isPressed: l,
        preventFocusOnPress: a,
        shouldCancelOnPointerExit: u,
        allowTextSelectionOnPress: d,
        ref: h,
        ...D
    } = uf(n), [g, x] = c.useState(!1), P = c.useRef({
        isPressed: !1,
        ignoreEmulatedMouseEvents: !1,
        ignoreClickAfterPress: !1,
        didFirePressStart: !1,
        isTriggeringEvent: !1,
        activePointerId: null,
        target: null,
        isOverTarget: !1,
        pointerType: null
    }), {
        addGlobalListener: L,
        removeAllGlobalListeners: R
    } = js(), N = it((f, I) => {
        let O = P.current;
        if (s || O.didFirePressStart) return !1;
        let T = !0;
        if (O.isTriggeringEvent = !0, r) {
            let K = new vr("pressstart", I, f);
            r(K), T = K.shouldStopPropagation
        }
        return t && t(!0), O.isTriggeringEvent = !1, O.didFirePressStart = !0, x(!0), T
    }), S = it((f, I, O = !0) => {
        let T = P.current;
        if (!T.didFirePressStart) return !1;
        T.ignoreClickAfterPress = !0, T.didFirePressStart = !1, T.isTriggeringEvent = !0;
        let K = !0;
        if (i) {
            let m = new vr("pressend", I, f);
            i(m), K = m.shouldStopPropagation
        }
        if (t && t(!1), x(!1), e && O && !s) {
            let m = new vr("press", I, f);
            e(m), K && (K = m.shouldStopPropagation)
        }
        return T.isTriggeringEvent = !1, K
    }), j = it((f, I) => {
        let O = P.current;
        if (s) return !1;
        if (o) {
            O.isTriggeringEvent = !0;
            let T = new vr("pressup", I, f);
            return o(T), O.isTriggeringEvent = !1, T.shouldStopPropagation
        }
        return !0
    }), k = it(f => {
        let I = P.current;
        I.isPressed && I.target && (I.isOverTarget && I.pointerType != null && S(Vt(I.target, f), I.pointerType, !1), I.isPressed = !1, I.isOverTarget = !1, I.activePointerId = null, I.pointerType = null, R(), d || hr(I.target))
    }), B = it(f => {
        u && k(f)
    }), M = c.useMemo(() => {
        let f = P.current,
            I = {
                onKeyDown(T) {
                    if (ti(T.nativeEvent, T.currentTarget) && T.currentTarget.contains(T.target)) {
                        var K;
                        Ko(T.target, T.key) && T.preventDefault();
                        let m = !0;
                        if (!f.isPressed && !T.repeat) {
                            f.target = T.currentTarget, f.isPressed = !0, m = N(T, "keyboard");
                            let p = T.currentTarget,
                                w = C => {
                                    ti(C, p) && !C.repeat && p.contains(C.target) && f.target && j(Vt(f.target, C), "keyboard")
                                };
                            L(Ne(T.currentTarget), "keyup", hn(w, O), !0)
                        }
                        m && T.stopPropagation(), T.metaKey && rn() && ((K = f.metaKeyEvents) === null || K === void 0 || K.set(T.key, T.nativeEvent))
                    } else T.key === "Meta" && (f.metaKeyEvents = new Map)
                },
                onClick(T) {
                    if (!(T && !T.currentTarget.contains(T.target)) && T && T.button === 0 && !f.isTriggeringEvent && !Dn.isOpening) {
                        let K = !0;
                        if (s && T.preventDefault(), !f.ignoreClickAfterPress && !f.ignoreEmulatedMouseEvents && !f.isPressed && (f.pointerType === "virtual" || Ci(T.nativeEvent))) {
                            !s && !a && Ht(T.currentTarget);
                            let m = N(T, "virtual"),
                                p = j(T, "virtual"),
                                w = S(T, "virtual");
                            K = m && p && w
                        }
                        f.ignoreEmulatedMouseEvents = !1, f.ignoreClickAfterPress = !1, K && T.stopPropagation()
                    }
                }
            },
            O = T => {
                var K;
                if (f.isPressed && f.target && ti(T, f.target)) {
                    var m;
                    Ko(T.target, T.key) && T.preventDefault();
                    let w = T.target;
                    S(Vt(f.target, T), "keyboard", f.target.contains(w)), R(), T.key !== "Enter" && Qi(f.target) && f.target.contains(w) && !T[No] && (T[No] = !0, Dn(f.target, T, !1)), f.isPressed = !1, (m = f.metaKeyEvents) === null || m === void 0 || m.delete(T.key)
                } else if (T.key === "Meta" && (!((K = f.metaKeyEvents) === null || K === void 0) && K.size)) {
                    var p;
                    let w = f.metaKeyEvents;
                    f.metaKeyEvents = void 0;
                    for (let C of w.values())(p = f.target) === null || p === void 0 || p.dispatchEvent(new KeyboardEvent("keyup", C))
                }
            };
        if (typeof PointerEvent < "u") {
            I.onPointerDown = p => {
                if (p.button !== 0 || !p.currentTarget.contains(p.target)) return;
                if (Rd(p.nativeEvent)) {
                    f.pointerType = "virtual";
                    return
                }
                ri(p.currentTarget) && p.preventDefault(), f.pointerType = p.pointerType;
                let w = !0;
                if (!f.isPressed) {
                    f.isPressed = !0, f.isOverTarget = !0, f.activePointerId = p.pointerId, f.target = p.currentTarget, !s && !a && Ht(p.currentTarget), d || Ro(f.target), w = N(p, f.pointerType);
                    let C = p.target;
                    "releasePointerCapture" in C && C.releasePointerCapture(p.pointerId), L(Ne(p.currentTarget), "pointerup", T, !1), L(Ne(p.currentTarget), "pointercancel", m, !1)
                }
                w && p.stopPropagation()
            }, I.onMouseDown = p => {
                p.currentTarget.contains(p.target) && p.button === 0 && (ri(p.currentTarget) && p.preventDefault(), p.stopPropagation())
            }, I.onPointerUp = p => {
                !p.currentTarget.contains(p.target) || f.pointerType === "virtual" || p.button === 0 && j(p, f.pointerType || p.pointerType)
            }, I.onPointerEnter = p => {
                p.pointerId === f.activePointerId && f.target && !f.isOverTarget && f.pointerType != null && (f.isOverTarget = !0, N(Vt(f.target, p), f.pointerType))
            }, I.onPointerLeave = p => {
                p.pointerId === f.activePointerId && f.target && f.isOverTarget && f.pointerType != null && (f.isOverTarget = !1, S(Vt(f.target, p), f.pointerType, !1), B(p))
            };
            let T = p => {
                    p.pointerId === f.activePointerId && f.isPressed && p.button === 0 && f.target && (f.target.contains(p.target) && f.pointerType != null ? S(Vt(f.target, p), f.pointerType) : f.isOverTarget && f.pointerType != null && S(Vt(f.target, p), f.pointerType, !1), f.isPressed = !1, f.isOverTarget = !1, f.activePointerId = null, f.pointerType = null, R(), d || hr(f.target), "ontouchend" in f.target && p.pointerType !== "mouse" && L(f.target, "touchend", K, {
                        once: !0
                    }))
                },
                K = p => {
                    el(p.currentTarget) && p.preventDefault()
                },
                m = p => {
                    k(p)
                };
            I.onDragStart = p => {
                p.currentTarget.contains(p.target) && k(p)
            }
        } else {
            I.onMouseDown = m => {
                if (m.button !== 0 || !m.currentTarget.contains(m.target)) return;
                if (ri(m.currentTarget) && m.preventDefault(), f.ignoreEmulatedMouseEvents) {
                    m.stopPropagation();
                    return
                }
                f.isPressed = !0, f.isOverTarget = !0, f.target = m.currentTarget, f.pointerType = Ci(m.nativeEvent) ? "virtual" : "mouse", !s && !a && Ht(m.currentTarget), N(m, f.pointerType) && m.stopPropagation(), L(Ne(m.currentTarget), "mouseup", T, !1)
            }, I.onMouseEnter = m => {
                if (!m.currentTarget.contains(m.target)) return;
                let p = !0;
                f.isPressed && !f.ignoreEmulatedMouseEvents && f.pointerType != null && (f.isOverTarget = !0, p = N(m, f.pointerType)), p && m.stopPropagation()
            }, I.onMouseLeave = m => {
                if (!m.currentTarget.contains(m.target)) return;
                let p = !0;
                f.isPressed && !f.ignoreEmulatedMouseEvents && f.pointerType != null && (f.isOverTarget = !1, p = S(m, f.pointerType, !1), B(m)), p && m.stopPropagation()
            }, I.onMouseUp = m => {
                m.currentTarget.contains(m.target) && !f.ignoreEmulatedMouseEvents && m.button === 0 && j(m, f.pointerType || "mouse")
            };
            let T = m => {
                if (m.button === 0) {
                    if (f.isPressed = !1, R(), f.ignoreEmulatedMouseEvents) {
                        f.ignoreEmulatedMouseEvents = !1;
                        return
                    }
                    f.target && ni(m, f.target) && f.pointerType != null ? S(Vt(f.target, m), f.pointerType) : f.target && f.isOverTarget && f.pointerType != null && S(Vt(f.target, m), f.pointerType, !1), f.isOverTarget = !1
                }
            };
            I.onTouchStart = m => {
                if (!m.currentTarget.contains(m.target)) return;
                let p = cf(m.nativeEvent);
                if (!p) return;
                f.activePointerId = p.identifier, f.ignoreEmulatedMouseEvents = !0, f.isOverTarget = !0, f.isPressed = !0, f.target = m.currentTarget, f.pointerType = "touch", !s && !a && Ht(m.currentTarget), d || Ro(f.target), N(Qt(f.target, m), f.pointerType) && m.stopPropagation(), L(Pt(m.currentTarget), "scroll", K, !0)
            }, I.onTouchMove = m => {
                if (!m.currentTarget.contains(m.target)) return;
                if (!f.isPressed) {
                    m.stopPropagation();
                    return
                }
                let p = Io(m.nativeEvent, f.activePointerId),
                    w = !0;
                p && ni(p, m.currentTarget) ? !f.isOverTarget && f.pointerType != null && (f.isOverTarget = !0, w = N(Qt(f.target, m), f.pointerType)) : f.isOverTarget && f.pointerType != null && (f.isOverTarget = !1, w = S(Qt(f.target, m), f.pointerType, !1), B(Qt(f.target, m))), w && m.stopPropagation()
            }, I.onTouchEnd = m => {
                if (!m.currentTarget.contains(m.target)) return;
                if (!f.isPressed) {
                    m.stopPropagation();
                    return
                }
                let p = Io(m.nativeEvent, f.activePointerId),
                    w = !0;
                p && ni(p, m.currentTarget) && f.pointerType != null ? (j(Qt(f.target, m), f.pointerType), w = S(Qt(f.target, m), f.pointerType)) : f.isOverTarget && f.pointerType != null && (w = S(Qt(f.target, m), f.pointerType, !1)), w && m.stopPropagation(), f.isPressed = !1, f.activePointerId = null, f.isOverTarget = !1, f.ignoreEmulatedMouseEvents = !0, f.target && !d && hr(f.target), R()
            }, I.onTouchCancel = m => {
                m.currentTarget.contains(m.target) && (m.stopPropagation(), f.isPressed && k(Qt(f.target, m)))
            };
            let K = m => {
                f.isPressed && m.target.contains(f.target) && k({
                    currentTarget: f.target,
                    shiftKey: !1,
                    ctrlKey: !1,
                    metaKey: !1,
                    altKey: !1
                })
            };
            I.onDragStart = m => {
                m.currentTarget.contains(m.target) && k(m)
            }
        }
        return I
    }, [L, s, a, R, d, k, B, S, N, j]);
    return c.useEffect(() => () => {
        var f;
        d || hr((f = P.current.target) !== null && f !== void 0 ? f : void 0)
    }, [d]), {
        isPressed: l || g,
        pressProps: Oe(D, M)
    }
}

function Qi(n) {
    return n.tagName === "A" && n.hasAttribute("href")
}

function ti(n, e) {
    const {
        key: t,
        code: r
    } = n, i = e, o = i.getAttribute("role");
    return (t === "Enter" || t === " " || t === "Spacebar" || r === "Space") && !(i instanceof Pt(i).HTMLInputElement && !tl(i, t) || i instanceof Pt(i).HTMLTextAreaElement || i.isContentEditable) && !((o === "link" || !o && Qi(i)) && t !== "Enter")
}

function cf(n) {
    const {
        targetTouches: e
    } = n;
    return e.length > 0 ? e[0] : null
}

function Io(n, e) {
    const t = n.changedTouches;
    for (let r = 0; r < t.length; r++) {
        const i = t[r];
        if (i.identifier === e) return i
    }
    return null
}

function Qt(n, e) {
    let t = 0,
        r = 0;
    return e.targetTouches && e.targetTouches.length === 1 && (t = e.targetTouches[0].clientX, r = e.targetTouches[0].clientY), {
        currentTarget: n,
        shiftKey: e.shiftKey,
        ctrlKey: e.ctrlKey,
        metaKey: e.metaKey,
        altKey: e.altKey,
        clientX: t,
        clientY: r
    }
}

function Vt(n, e) {
    let t = e.clientX,
        r = e.clientY;
    return {
        currentTarget: n,
        shiftKey: e.shiftKey,
        ctrlKey: e.ctrlKey,
        metaKey: e.metaKey,
        altKey: e.altKey,
        clientX: t,
        clientY: r
    }
}

function df(n) {
    let e = 0,
        t = 0;
    return n.width !== void 0 ? e = n.width / 2 : n.radiusX !== void 0 && (e = n.radiusX), n.height !== void 0 ? t = n.height / 2 : n.radiusY !== void 0 && (t = n.radiusY), {
        top: n.clientY - t,
        right: n.clientX + e,
        bottom: n.clientY + t,
        left: n.clientX - e
    }
}

function ff(n, e) {
    return !(n.left > e.right || e.left > n.right || n.top > e.bottom || e.top > n.bottom)
}

function ni(n, e) {
    let t = e.getBoundingClientRect(),
        r = df(n);
    return ff(t, r)
}

function ri(n) {
    return !(n instanceof HTMLElement) || !n.hasAttribute("draggable")
}

function el(n) {
    return n instanceof HTMLInputElement ? !1 : n instanceof HTMLButtonElement ? n.type !== "submit" && n.type !== "reset" : !Qi(n)
}

function Ko(n, e) {
    return n instanceof HTMLInputElement ? !tl(n, e) : el(n)
}
const pf = new Set(["checkbox", "radio", "range", "color", "file", "image", "button", "submit", "reset"]);

function tl(n, e) {
    return n.type === "checkbox" || n.type === "radio" ? e === " " : pf.has(n.type)
}

function hf({
    children: n
}) {
    let e = c.useMemo(() => ({
        register: () => {}
    }), []);
    return W.createElement(Zi.Provider, {
        value: e
    }, n)
}
class Df {
    isDefaultPrevented() {
        return this.nativeEvent.defaultPrevented
    }
    preventDefault() {
        this.defaultPrevented = !0, this.nativeEvent.preventDefault()
    }
    stopPropagation() {
        this.nativeEvent.stopPropagation(), this.isPropagationStopped = () => !0
    }
    isPropagationStopped() {
        return !1
    }
    persist() {}
    constructor(e, t) {
        this.nativeEvent = t, this.target = t.target, this.currentTarget = t.currentTarget, this.relatedTarget = t.relatedTarget, this.bubbles = t.bubbles, this.cancelable = t.cancelable, this.defaultPrevented = t.defaultPrevented, this.eventPhase = t.eventPhase, this.isTrusted = t.isTrusted, this.timeStamp = t.timeStamp, this.type = e
    }
}

function nl(n) {
    let e = c.useRef({
        isFocused: !1,
        observer: null
    });
    Fe(() => {
        const r = e.current;
        return () => {
            r.observer && (r.observer.disconnect(), r.observer = null)
        }
    }, []);
    let t = it(r => {
        n == null || n(r)
    });
    return c.useCallback(r => {
        if (r.target instanceof HTMLButtonElement || r.target instanceof HTMLInputElement || r.target instanceof HTMLTextAreaElement || r.target instanceof HTMLSelectElement) {
            e.current.isFocused = !0;
            let i = r.target,
                o = s => {
                    e.current.isFocused = !1, i.disabled && t(new Df("blur", s)), e.current.observer && (e.current.observer.disconnect(), e.current.observer = null)
                };
            i.addEventListener("focusout", o, {
                once: !0
            }), e.current.observer = new MutationObserver(() => {
                if (e.current.isFocused && i.disabled) {
                    var s;
                    (s = e.current.observer) === null || s === void 0 || s.disconnect();
                    let l = i === document.activeElement ? null : document.activeElement;
                    i.dispatchEvent(new FocusEvent("blur", {
                        relatedTarget: l
                    })), i.dispatchEvent(new FocusEvent("focusout", {
                        bubbles: !0,
                        relatedTarget: l
                    }))
                }
            }), e.current.observer.observe(i, {
                attributes: !0,
                attributeFilter: ["disabled"]
            })
        }
    }, [t])
}

function rl(n) {
    let {
        isDisabled: e,
        onFocus: t,
        onBlur: r,
        onFocusChange: i
    } = n;
    const o = c.useCallback(a => {
            if (a.target === a.currentTarget) return r && r(a), i && i(!1), !0
        }, [r, i]),
        s = nl(o),
        l = c.useCallback(a => {
            const u = Ne(a.target);
            a.target === a.currentTarget && u.activeElement === a.target && (t && t(a), i && i(!0), s(a))
        }, [i, t, s]);
    return {
        focusProps: {
            onFocus: !e && (t || i || r) ? l : void 0,
            onBlur: !e && (r || i) ? o : void 0
        }
    }
}
let gn = null,
    Fi = new Set,
    Un = new Map,
    vn = !1,
    Si = !1;
const vf = {
    Tab: !0,
    Escape: !0
};

function Ir(n, e) {
    for (let t of Fi) t(n, e)
}

function gf(n) {
    return !(n.metaKey || !rn() && n.altKey || n.ctrlKey || n.key === "Control" || n.key === "Shift" || n.key === "Meta")
}

function Fr(n) {
    vn = !0, gf(n) && (gn = "keyboard", Ir("keyboard", n))
}

function yt(n) {
    gn = "pointer", (n.type === "mousedown" || n.type === "pointerdown") && (vn = !0, Ir("pointer", n))
}

function il(n) {
    Ci(n) && (vn = !0, gn = "virtual")
}

function ol(n) {
    n.target === window || n.target === document || (!vn && !Si && (gn = "virtual", Ir("virtual", n)), vn = !1, Si = !1)
}

function sl() {
    vn = !1, Si = !0
}

function _i(n) {
    if (typeof window > "u" || Un.get(Pt(n))) return;
    const e = Pt(n),
        t = Ne(n);
    let r = e.HTMLElement.prototype.focus;
    e.HTMLElement.prototype.focus = function() {
        vn = !0, r.apply(this, arguments)
    }, t.addEventListener("keydown", Fr, !0), t.addEventListener("keyup", Fr, !0), t.addEventListener("click", il, !0), e.addEventListener("focus", ol, !0), e.addEventListener("blur", sl, !1), typeof PointerEvent < "u" ? (t.addEventListener("pointerdown", yt, !0), t.addEventListener("pointermove", yt, !0), t.addEventListener("pointerup", yt, !0)) : (t.addEventListener("mousedown", yt, !0), t.addEventListener("mousemove", yt, !0), t.addEventListener("mouseup", yt, !0)), e.addEventListener("beforeunload", () => {
        ll(n)
    }, {
        once: !0
    }), Un.set(e, {
        focus: r
    })
}
const ll = (n, e) => {
    const t = Pt(n),
        r = Ne(n);
    e && r.removeEventListener("DOMContentLoaded", e), Un.has(t) && (t.HTMLElement.prototype.focus = Un.get(t).focus, r.removeEventListener("keydown", Fr, !0), r.removeEventListener("keyup", Fr, !0), r.removeEventListener("click", il, !0), t.removeEventListener("focus", ol, !0), t.removeEventListener("blur", sl, !1), typeof PointerEvent < "u" ? (r.removeEventListener("pointerdown", yt, !0), r.removeEventListener("pointermove", yt, !0), r.removeEventListener("pointerup", yt, !0)) : (r.removeEventListener("mousedown", yt, !0), r.removeEventListener("mousemove", yt, !0), r.removeEventListener("mouseup", yt, !0)), Un.delete(t))
};

function mf(n) {
    const e = Ne(n);
    let t;
    return e.readyState !== "loading" ? _i(n) : (t = () => {
        _i(n)
    }, e.addEventListener("DOMContentLoaded", t)), () => ll(n, t)
}
typeof document < "u" && mf();

function Sr() {
    return gn !== "pointer"
}

function _r() {
    return gn
}

function al(n) {
    gn = n, Ir(n, null)
}
const bf = new Set(["checkbox", "radio", "range", "color", "file", "image", "button", "submit", "reset"]);

function yf(n, e, t) {
    var r;
    const i = typeof window < "u" ? Pt(t == null ? void 0 : t.target).HTMLInputElement : HTMLInputElement,
        o = typeof window < "u" ? Pt(t == null ? void 0 : t.target).HTMLTextAreaElement : HTMLTextAreaElement,
        s = typeof window < "u" ? Pt(t == null ? void 0 : t.target).HTMLElement : HTMLElement,
        l = typeof window < "u" ? Pt(t == null ? void 0 : t.target).KeyboardEvent : KeyboardEvent;
    return n = n || (t == null ? void 0 : t.target) instanceof i && !bf.has(t == null || (r = t.target) === null || r === void 0 ? void 0 : r.type) || (t == null ? void 0 : t.target) instanceof o || (t == null ? void 0 : t.target) instanceof s && (t == null ? void 0 : t.target.isContentEditable), !(n && e === "keyboard" && t instanceof l && !vf[t.key])
}

function Ef(n, e, t) {
    _i(), c.useEffect(() => {
        let r = (i, o) => {
            yf(!!(t != null && t.isTextInput), i, o) && n(Sr())
        };
        return Fi.add(r), () => {
            Fi.delete(r)
        }
    }, e)
}

function Kr(n) {
    let {
        isDisabled: e,
        onBlurWithin: t,
        onFocusWithin: r,
        onFocusWithinChange: i
    } = n, o = c.useRef({
        isFocusWithin: !1
    }), s = c.useCallback(u => {
        o.current.isFocusWithin && !u.currentTarget.contains(u.relatedTarget) && (o.current.isFocusWithin = !1, t && t(u), i && i(!1))
    }, [t, i, o]), l = nl(s), a = c.useCallback(u => {
        !o.current.isFocusWithin && document.activeElement === u.target && (r && r(u), i && i(!0), o.current.isFocusWithin = !0, l(u))
    }, [r, i, l]);
    return e ? {
        focusWithinProps: {
            onFocus: void 0,
            onBlur: void 0
        }
    } : {
        focusWithinProps: {
            onFocus: a,
            onBlur: s
        }
    }
}
let Pr = !1,
    ii = 0;

function Pi() {
    Pr = !0, setTimeout(() => {
        Pr = !1
    }, 50)
}

function Oo(n) {
    n.pointerType === "touch" && Pi()
}

function Cf() {
    if (!(typeof document > "u")) return typeof PointerEvent < "u" ? document.addEventListener("pointerup", Oo) : document.addEventListener("touchend", Pi), ii++, () => {
        ii--, !(ii > 0) && (typeof PointerEvent < "u" ? document.removeEventListener("pointerup", Oo) : document.removeEventListener("touchend", Pi))
    }
}

function eo(n) {
    let {
        onHoverStart: e,
        onHoverChange: t,
        onHoverEnd: r,
        isDisabled: i
    } = n, [o, s] = c.useState(!1), l = c.useRef({
        isHovered: !1,
        ignoreEmulatedMouseEvents: !1,
        pointerType: "",
        target: null
    }).current;
    c.useEffect(Cf, []);
    let {
        hoverProps: a,
        triggerHoverEnd: u
    } = c.useMemo(() => {
        let d = (g, x) => {
                if (l.pointerType = x, i || x === "touch" || l.isHovered || !g.currentTarget.contains(g.target)) return;
                l.isHovered = !0;
                let P = g.currentTarget;
                l.target = P, e && e({
                    type: "hoverstart",
                    target: P,
                    pointerType: x
                }), t && t(!0), s(!0)
            },
            h = (g, x) => {
                if (l.pointerType = "", l.target = null, x === "touch" || !l.isHovered) return;
                l.isHovered = !1;
                let P = g.currentTarget;
                r && r({
                    type: "hoverend",
                    target: P,
                    pointerType: x
                }), t && t(!1), s(!1)
            },
            D = {};
        return typeof PointerEvent < "u" ? (D.onPointerEnter = g => {
            Pr && g.pointerType === "mouse" || d(g, g.pointerType)
        }, D.onPointerLeave = g => {
            !i && g.currentTarget.contains(g.target) && h(g, g.pointerType)
        }) : (D.onTouchStart = () => {
            l.ignoreEmulatedMouseEvents = !0
        }, D.onMouseEnter = g => {
            !l.ignoreEmulatedMouseEvents && !Pr && d(g, "mouse"), l.ignoreEmulatedMouseEvents = !1
        }, D.onMouseLeave = g => {
            !i && g.currentTarget.contains(g.target) && h(g, "mouse")
        }), {
            hoverProps: D,
            triggerHoverEnd: h
        }
    }, [e, t, r, i, l]);
    return c.useEffect(() => {
        i && u({
            currentTarget: l.target
        }, l.pointerType)
    }, [i]), {
        hoverProps: a,
        isHovered: o
    }
}

function xf(n) {
    let {
        ref: e,
        onInteractOutside: t,
        isDisabled: r,
        onInteractOutsideStart: i
    } = n, o = c.useRef({
        isPointerDown: !1,
        ignoreEmulatedMouseEvents: !1
    }), s = it(a => {
        t && gr(a, e) && (i && i(a), o.current.isPointerDown = !0)
    }), l = it(a => {
        t && t(a)
    });
    c.useEffect(() => {
        let a = o.current;
        if (r) return;
        const u = e.current,
            d = Ne(u);
        if (typeof PointerEvent < "u") {
            let h = D => {
                a.isPointerDown && gr(D, e) && l(D), a.isPointerDown = !1
            };
            return d.addEventListener("pointerdown", s, !0), d.addEventListener("pointerup", h, !0), () => {
                d.removeEventListener("pointerdown", s, !0), d.removeEventListener("pointerup", h, !0)
            }
        } else {
            let h = g => {
                    a.ignoreEmulatedMouseEvents ? a.ignoreEmulatedMouseEvents = !1 : a.isPointerDown && gr(g, e) && l(g), a.isPointerDown = !1
                },
                D = g => {
                    a.ignoreEmulatedMouseEvents = !0, a.isPointerDown && gr(g, e) && l(g), a.isPointerDown = !1
                };
            return d.addEventListener("mousedown", s, !0), d.addEventListener("mouseup", h, !0), d.addEventListener("touchstart", s, !0), d.addEventListener("touchend", D, !0), () => {
                d.removeEventListener("mousedown", s, !0), d.removeEventListener("mouseup", h, !0), d.removeEventListener("touchstart", s, !0), d.removeEventListener("touchend", D, !0)
            }
        }
    }, [e, r, s, l])
}

function gr(n, e) {
    if (n.button > 0) return !1;
    if (n.target) {
        const t = n.target.ownerDocument;
        if (!t || !t.documentElement.contains(n.target) || n.target.closest("[data-react-aria-top-layer]")) return !1
    }
    return e.current && !e.current.contains(n.target)
}

function jo(n) {
    if (!n) return;
    let e = !0;
    return t => {
        let r = { ...t,
            preventDefault() {
                t.preventDefault()
            },
            isDefaultPrevented() {
                return t.isDefaultPrevented()
            },
            stopPropagation() {
                e ? console.error("stopPropagation is now the default behavior for events in React Spectrum. You can use continuePropagation() to revert this behavior.") : e = !0
            },
            continuePropagation() {
                e = !1
            },
            isPropagationStopped() {
                return e
            }
        };
        n(r), e && t.stopPropagation()
    }
}

function $f(n) {
    return {
        keyboardProps: n.isDisabled ? {} : {
            onKeyDown: jo(n.onKeyDown),
            onKeyUp: jo(n.onKeyUp)
        }
    }
}
const wf = 500;

function ul(n) {
    let {
        isDisabled: e,
        onLongPressStart: t,
        onLongPressEnd: r,
        onLongPress: i,
        threshold: o = wf,
        accessibilityDescription: s
    } = n;
    const l = c.useRef(void 0);
    let {
        addGlobalListener: a,
        removeGlobalListener: u
    } = js(), {
        pressProps: d
    } = Ji({
        isDisabled: e,
        onPressStart(D) {
            if (D.continuePropagation(), (D.pointerType === "mouse" || D.pointerType === "touch") && (t && t({ ...D,
                    type: "longpressstart"
                }), l.current = setTimeout(() => {
                    D.target.dispatchEvent(new PointerEvent("pointercancel", {
                        bubbles: !0
                    })), i && i({ ...D,
                        type: "longpress"
                    }), l.current = void 0
                }, o), D.pointerType === "touch")) {
                let g = x => {
                    x.preventDefault()
                };
                a(D.target, "contextmenu", g, {
                    once: !0
                }), a(window, "pointerup", () => {
                    setTimeout(() => {
                        u(D.target, "contextmenu", g)
                    }, 30)
                }, {
                    once: !0
                })
            }
        },
        onPressEnd(D) {
            l.current && clearTimeout(l.current), r && (D.pointerType === "mouse" || D.pointerType === "touch") && r({ ...D,
                type: "longpressend"
            })
        }
    }), h = Bd(i && !e ? s : void 0);
    return {
        longPressProps: Oe(d, h)
    }
}

function Jn(n) {
    const e = Ne(n);
    if (_r() === "virtual") {
        let t = e.activeElement;
        Os(() => {
            e.activeElement === t && n.isConnected && Ht(n)
        })
    } else Ht(n)
}

function Ff(n) {
    const e = Pt(n);
    if (!(n instanceof e.HTMLElement) && !(n instanceof e.SVGElement)) return !1;
    let {
        display: t,
        visibility: r
    } = n.style, i = t !== "none" && r !== "hidden" && r !== "collapse";
    if (i) {
        const {
            getComputedStyle: o
        } = n.ownerDocument.defaultView;
        let {
            display: s,
            visibility: l
        } = o(n);
        i = s !== "none" && l !== "hidden" && l !== "collapse"
    }
    return i
}

function Sf(n, e) {
    return !n.hasAttribute("hidden") && !n.hasAttribute("data-react-aria-prevent-focus") && (n.nodeName === "DETAILS" && e && e.nodeName !== "SUMMARY" ? n.hasAttribute("open") : !0)
}

function cl(n, e) {
    return n.nodeName !== "#comment" && Ff(n) && Sf(n, e) && (!n.parentElement || cl(n.parentElement, n))
}
const zo = W.createContext(null),
    Ti = "react-aria-focus-scope-restore";
let Re = null;

function to(n) {
    let {
        children: e,
        contain: t,
        restoreFocus: r,
        autoFocus: i
    } = n, o = c.useRef(null), s = c.useRef(null), l = c.useRef([]), {
        parentNode: a
    } = c.useContext(zo) || {}, u = c.useMemo(() => new Ai({
        scopeRef: l
    }), [l]);
    Fe(() => {
        let D = a || qe.root;
        if (qe.getTreeNode(D.scopeRef) && Re && !Tr(Re, D.scopeRef)) {
            let g = qe.getTreeNode(Re);
            g && (D = g)
        }
        D.addChild(u), qe.addNode(u)
    }, [u, a]), Fe(() => {
        let D = qe.getTreeNode(l);
        D && (D.contain = !!t)
    }, [t]), Fe(() => {
        var D;
        let g = (D = o.current) === null || D === void 0 ? void 0 : D.nextSibling,
            x = [],
            P = L => L.stopPropagation();
        for (; g && g !== s.current;) x.push(g), g.addEventListener(Ti, P), g = g.nextSibling;
        return l.current = x, () => {
            for (let L of x) L.removeEventListener(Ti, P)
        }
    }, [e]), Bf(l, r, t), kf(l, t), Rf(l, r, t), Lf(l, i), c.useEffect(() => {
        const D = Ne(l.current ? l.current[0] : void 0).activeElement;
        let g = null;
        if (xt(D, l.current)) {
            for (let x of qe.traverse()) x.scopeRef && xt(D, x.scopeRef.current) && (g = x);
            g === qe.getTreeNode(l) && (Re = g.scopeRef)
        }
    }, [l]), Fe(() => () => {
        var D, g, x;
        let P = (x = (g = qe.getTreeNode(l)) === null || g === void 0 || (D = g.parent) === null || D === void 0 ? void 0 : D.scopeRef) !== null && x !== void 0 ? x : null;
        (l === Re || Tr(l, Re)) && (!P || qe.getTreeNode(P)) && (Re = P), qe.removeTreeNode(l)
    }, [l]);
    let d = c.useMemo(() => _f(l), []),
        h = c.useMemo(() => ({
            focusManager: d,
            parentNode: u
        }), [u, d]);
    return W.createElement(zo.Provider, {
        value: h
    }, W.createElement("span", {
        "data-focus-scope-start": !0,
        hidden: !0,
        ref: o
    }), e, W.createElement("span", {
        "data-focus-scope-end": !0,
        hidden: !0,
        ref: s
    }))
}

function _f(n) {
    return {
        focusNext(e = {}) {
            let t = n.current,
                {
                    from: r,
                    tabbable: i,
                    wrap: o,
                    accept: s
                } = e,
                l = r || Ne(t[0]).activeElement,
                a = t[0].previousElementSibling,
                u = pn(t),
                d = Gt(u, {
                    tabbable: i,
                    accept: s
                }, t);
            d.currentNode = xt(l, t) ? l : a;
            let h = d.nextNode();
            return !h && o && (d.currentNode = a, h = d.nextNode()), h && Ut(h, !0), h
        },
        focusPrevious(e = {}) {
            let t = n.current,
                {
                    from: r,
                    tabbable: i,
                    wrap: o,
                    accept: s
                } = e,
                l = r || Ne(t[0]).activeElement,
                a = t[t.length - 1].nextElementSibling,
                u = pn(t),
                d = Gt(u, {
                    tabbable: i,
                    accept: s
                }, t);
            d.currentNode = xt(l, t) ? l : a;
            let h = d.previousNode();
            return !h && o && (d.currentNode = a, h = d.previousNode()), h && Ut(h, !0), h
        },
        focusFirst(e = {}) {
            let t = n.current,
                {
                    tabbable: r,
                    accept: i
                } = e,
                o = pn(t),
                s = Gt(o, {
                    tabbable: r,
                    accept: i
                }, t);
            s.currentNode = t[0].previousElementSibling;
            let l = s.nextNode();
            return l && Ut(l, !0), l
        },
        focusLast(e = {}) {
            let t = n.current,
                {
                    tabbable: r,
                    accept: i
                } = e,
                o = pn(t),
                s = Gt(o, {
                    tabbable: r,
                    accept: i
                }, t);
            s.currentNode = t[t.length - 1].nextElementSibling;
            let l = s.previousNode();
            return l && Ut(l, !0), l
        }
    }
}
const no = ["input:not([disabled]):not([type=hidden])", "select:not([disabled])", "textarea:not([disabled])", "button:not([disabled])", "a[href]", "area[href]", "summary", "iframe", "object", "embed", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable^="false"])'],
    Pf = no.join(":not([hidden]),") + ",[tabindex]:not([disabled]):not([hidden])";
no.push('[tabindex]:not([tabindex="-1"]):not([disabled])');
const Tf = no.join(':not([hidden]):not([tabindex="-1"]),');

function pn(n) {
    return n[0].parentElement
}

function Wn(n) {
    let e = qe.getTreeNode(Re);
    for (; e && e.scopeRef !== n;) {
        if (e.contain) return !1;
        e = e.parent
    }
    return !0
}

function kf(n, e) {
    let t = c.useRef(void 0),
        r = c.useRef(void 0);
    Fe(() => {
        let i = n.current;
        if (!e) {
            r.current && (cancelAnimationFrame(r.current), r.current = void 0);
            return
        }
        const o = Ne(i ? i[0] : void 0);
        let s = u => {
                if (u.key !== "Tab" || u.altKey || u.ctrlKey || u.metaKey || !Wn(n) || u.isComposing) return;
                let d = o.activeElement,
                    h = n.current;
                if (!h || !xt(d, h)) return;
                let D = pn(h),
                    g = Gt(D, {
                        tabbable: !0
                    }, h);
                if (!d) return;
                g.currentNode = d;
                let x = u.shiftKey ? g.previousNode() : g.nextNode();
                x || (g.currentNode = u.shiftKey ? h[h.length - 1].nextElementSibling : h[0].previousElementSibling, x = u.shiftKey ? g.previousNode() : g.nextNode()), u.preventDefault(), x && Ut(x, !0)
            },
            l = u => {
                (!Re || Tr(Re, n)) && xt(u.target, n.current) ? (Re = n, t.current = u.target) : Wn(n) && !nn(u.target, n) ? t.current ? t.current.focus() : Re && Re.current && ki(Re.current) : Wn(n) && (t.current = u.target)
            },
            a = u => {
                r.current && cancelAnimationFrame(r.current), r.current = requestAnimationFrame(() => {
                    let d = _r();
                    if (!((d === "virtual" || d === null) && Wi() && Ks()) && o.activeElement && Wn(n) && !nn(o.activeElement, n))
                        if (Re = n, o.body.contains(u.target)) {
                            var D;
                            t.current = u.target, (D = t.current) === null || D === void 0 || D.focus()
                        } else Re.current && ki(Re.current)
                })
            };
        return o.addEventListener("keydown", s, !1), o.addEventListener("focusin", l, !1), i == null || i.forEach(u => u.addEventListener("focusin", l, !1)), i == null || i.forEach(u => u.addEventListener("focusout", a, !1)), () => {
            o.removeEventListener("keydown", s, !1), o.removeEventListener("focusin", l, !1), i == null || i.forEach(u => u.removeEventListener("focusin", l, !1)), i == null || i.forEach(u => u.removeEventListener("focusout", a, !1))
        }
    }, [n, e]), Fe(() => () => {
        r.current && cancelAnimationFrame(r.current)
    }, [r])
}

function dl(n) {
    return nn(n)
}

function xt(n, e) {
    return !n || !e ? !1 : e.some(t => t.contains(n))
}

function nn(n, e = null) {
    if (n instanceof Element && n.closest("[data-react-aria-top-layer]")) return !0;
    for (let {
            scopeRef: t
        } of qe.traverse(qe.getTreeNode(e)))
        if (t && xt(n, t.current)) return !0;
    return !1
}

function Af(n) {
    return nn(n, Re)
}

function Tr(n, e) {
    var t;
    let r = (t = qe.getTreeNode(e)) === null || t === void 0 ? void 0 : t.parent;
    for (; r;) {
        if (r.scopeRef === n) return !0;
        r = r.parent
    }
    return !1
}

function Ut(n, e = !1) {
    if (n != null && !e) try {
        Jn(n)
    } catch {} else if (n != null) try {
        n.focus()
    } catch {}
}

function fl(n, e = !0) {
    let t = n[0].previousElementSibling,
        r = pn(n),
        i = Gt(r, {
            tabbable: e
        }, n);
    i.currentNode = t;
    let o = i.nextNode();
    return e && !o && (r = pn(n), i = Gt(r, {
        tabbable: !1
    }, n), i.currentNode = t, o = i.nextNode()), o
}

function ki(n, e = !0) {
    Ut(fl(n, e))
}

function Lf(n, e) {
    const t = W.useRef(e);
    c.useEffect(() => {
        if (t.current) {
            Re = n;
            const r = Ne(n.current ? n.current[0] : void 0);
            !xt(r.activeElement, Re.current) && n.current && ki(n.current)
        }
        t.current = !1
    }, [n])
}

function Bf(n, e, t) {
    Fe(() => {
        if (e || t) return;
        let r = n.current;
        const i = Ne(r ? r[0] : void 0);
        let o = s => {
            let l = s.target;
            xt(l, n.current) ? Re = n : dl(l) || (Re = null)
        };
        return i.addEventListener("focusin", o, !1), r == null || r.forEach(s => s.addEventListener("focusin", o, !1)), () => {
            i.removeEventListener("focusin", o, !1), r == null || r.forEach(s => s.removeEventListener("focusin", o, !1))
        }
    }, [n, e, t])
}

function Vo(n) {
    let e = qe.getTreeNode(Re);
    for (; e && e.scopeRef !== n;) {
        if (e.nodeToRestore) return !1;
        e = e.parent
    }
    return (e == null ? void 0 : e.scopeRef) === n
}

function Rf(n, e, t) {
    const r = c.useRef(typeof document < "u" ? Ne(n.current ? n.current[0] : void 0).activeElement : null);
    Fe(() => {
        let i = n.current;
        const o = Ne(i ? i[0] : void 0);
        if (!e || t) return;
        let s = () => {
            (!Re || Tr(Re, n)) && xt(o.activeElement, n.current) && (Re = n)
        };
        return o.addEventListener("focusin", s, !1), i == null || i.forEach(l => l.addEventListener("focusin", s, !1)), () => {
            o.removeEventListener("focusin", s, !1), i == null || i.forEach(l => l.removeEventListener("focusin", s, !1))
        }
    }, [n, t]), Fe(() => {
        const i = Ne(n.current ? n.current[0] : void 0);
        if (!e) return;
        let o = s => {
            if (s.key !== "Tab" || s.altKey || s.ctrlKey || s.metaKey || !Wn(n) || s.isComposing) return;
            let l = i.activeElement;
            if (!nn(l, n) || !Vo(n)) return;
            let a = qe.getTreeNode(n);
            if (!a) return;
            let u = a.nodeToRestore,
                d = Gt(i.body, {
                    tabbable: !0
                });
            d.currentNode = l;
            let h = s.shiftKey ? d.previousNode() : d.nextNode();
            if ((!u || !i.body.contains(u) || u === i.body) && (u = void 0, a.nodeToRestore = void 0), (!h || !nn(h, n)) && u) {
                d.currentNode = u;
                do h = s.shiftKey ? d.previousNode() : d.nextNode(); while (nn(h, n));
                s.preventDefault(), s.stopPropagation(), h ? Ut(h, !0) : dl(u) ? Ut(u, !0) : l.blur()
            }
        };
        return t || i.addEventListener("keydown", o, !0), () => {
            t || i.removeEventListener("keydown", o, !0)
        }
    }, [n, e, t]), Fe(() => {
        const i = Ne(n.current ? n.current[0] : void 0);
        if (!e) return;
        let o = qe.getTreeNode(n);
        if (o) {
            var s;
            return o.nodeToRestore = (s = r.current) !== null && s !== void 0 ? s : void 0, () => {
                let l = qe.getTreeNode(n);
                if (!l) return;
                let a = l.nodeToRestore;
                if (e && a && (i.activeElement && nn(i.activeElement, n) || i.activeElement === i.body && Vo(n))) {
                    let u = qe.clone();
                    requestAnimationFrame(() => {
                        if (i.activeElement === i.body) {
                            let d = u.getTreeNode(n);
                            for (; d;) {
                                if (d.nodeToRestore && d.nodeToRestore.isConnected) {
                                    Wo(d.nodeToRestore);
                                    return
                                }
                                d = d.parent
                            }
                            for (d = u.getTreeNode(n); d;) {
                                if (d.scopeRef && d.scopeRef.current && qe.getTreeNode(d.scopeRef)) {
                                    let h = fl(d.scopeRef.current, !0);
                                    Wo(h);
                                    return
                                }
                                d = d.parent
                            }
                        }
                    })
                }
            }
        }
    }, [n, e])
}

function Wo(n) {
    n.dispatchEvent(new CustomEvent(Ti, {
        bubbles: !0,
        cancelable: !0
    })) && Ut(n)
}

function Gt(n, e, t) {
    let r = e != null && e.tabbable ? Tf : Pf,
        i = Ne(n).createTreeWalker(n, NodeFilter.SHOW_ELEMENT, {
            acceptNode(o) {
                var s;
                return !(e == null || (s = e.from) === null || s === void 0) && s.contains(o) ? NodeFilter.FILTER_REJECT : o.matches(r) && cl(o) && (!t || xt(o, t)) && (!(e != null && e.accept) || e.accept(o)) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
            }
        });
    return e != null && e.from && (i.currentNode = e.from), i
}
class ro {
    get size() {
        return this.fastMap.size
    }
    getTreeNode(e) {
        return this.fastMap.get(e)
    }
    addTreeNode(e, t, r) {
        let i = this.fastMap.get(t ? ? null);
        if (!i) return;
        let o = new Ai({
            scopeRef: e
        });
        i.addChild(o), o.parent = i, this.fastMap.set(e, o), r && (o.nodeToRestore = r)
    }
    addNode(e) {
        this.fastMap.set(e.scopeRef, e)
    }
    removeTreeNode(e) {
        if (e === null) return;
        let t = this.fastMap.get(e);
        if (!t) return;
        let r = t.parent;
        for (let o of this.traverse()) o !== t && t.nodeToRestore && o.nodeToRestore && t.scopeRef && t.scopeRef.current && xt(o.nodeToRestore, t.scopeRef.current) && (o.nodeToRestore = t.nodeToRestore);
        let i = t.children;
        r && (r.removeChild(t), i.size > 0 && i.forEach(o => r && r.addChild(o))), this.fastMap.delete(t.scopeRef)
    }* traverse(e = this.root) {
        if (e.scopeRef != null && (yield e), e.children.size > 0)
            for (let t of e.children) yield* this.traverse(t)
    }
    clone() {
        var e;
        let t = new ro;
        var r;
        for (let i of this.traverse()) t.addTreeNode(i.scopeRef, (r = (e = i.parent) === null || e === void 0 ? void 0 : e.scopeRef) !== null && r !== void 0 ? r : null, i.nodeToRestore);
        return t
    }
    constructor() {
        this.fastMap = new Map, this.root = new Ai({
            scopeRef: null
        }), this.fastMap.set(null, this.root)
    }
}
class Ai {
    addChild(e) {
        this.children.add(e), e.parent = this
    }
    removeChild(e) {
        this.children.delete(e), e.parent = void 0
    }
    constructor(e) {
        this.children = new Set, this.contain = !1, this.scopeRef = e.scopeRef
    }
}
let qe = new ro;

function io(n = {}) {
    let {
        autoFocus: e = !1,
        isTextInput: t,
        within: r
    } = n, i = c.useRef({
        isFocused: !1,
        isFocusVisible: e || Sr()
    }), [o, s] = c.useState(!1), [l, a] = c.useState(() => i.current.isFocused && i.current.isFocusVisible), u = c.useCallback(() => a(i.current.isFocused && i.current.isFocusVisible), []), d = c.useCallback(g => {
        i.current.isFocused = g, s(g), u()
    }, [u]);
    Ef(g => {
        i.current.isFocusVisible = g, u()
    }, [], {
        isTextInput: t
    });
    let {
        focusProps: h
    } = rl({
        isDisabled: r,
        onFocusChange: d
    }), {
        focusWithinProps: D
    } = Kr({
        isDisabled: !r,
        onFocusWithinChange: d
    });
    return {
        isFocused: o,
        isFocusVisible: l,
        focusProps: r ? D : h
    }
}
let Mf = W.createContext(null);

function Nf(n) {
    let e = c.useContext(Mf) || {};
    Vs(e, n);
    let {
        ref: t,
        ...r
    } = e;
    return r
}

function If(n, e) {
    let {
        focusProps: t
    } = rl(n), {
        keyboardProps: r
    } = $f(n), i = Oe(t, r), o = Nf(e), s = n.isDisabled ? {} : o, l = c.useRef(n.autoFocus);
    return c.useEffect(() => {
        l.current && e.current && Jn(e.current), l.current = !1
    }, [e]), {
        focusableProps: Oe({ ...i,
            tabIndex: n.excludeFromTabOrder && !n.isDisabled ? -1 : void 0
        }, s)
    }
}
const Kf = new Set(["Arab", "Syrc", "Samr", "Mand", "Thaa", "Mend", "Nkoo", "Adlm", "Rohg", "Hebr"]),
    Of = new Set(["ae", "ar", "arc", "bcc", "bqi", "ckb", "dv", "fa", "glk", "he", "ku", "mzn", "nqo", "pnb", "ps", "sd", "ug", "ur", "yi"]);

function jf(n) {
    if (Intl.Locale) {
        let t = new Intl.Locale(n).maximize(),
            r = typeof t.getTextInfo == "function" ? t.getTextInfo() : t.textInfo;
        if (r) return r.direction === "rtl";
        if (t.script) return Kf.has(t.script)
    }
    let e = n.split("-")[0];
    return Of.has(e)
}
const zf = Symbol.for("react-aria.i18n.locale");

function pl() {
    let n = typeof window < "u" && window[zf] || typeof navigator < "u" && (navigator.language || navigator.userLanguage) || "en-US";
    try {
        Intl.DateTimeFormat.supportedLocalesOf([n])
    } catch {
        n = "en-US"
    }
    return {
        locale: n,
        direction: jf(n) ? "rtl" : "ltr"
    }
}
let Li = pl(),
    Hn = new Set;

function Ho() {
    Li = pl();
    for (let n of Hn) n(Li)
}

function Vf() {
    let n = Ln(),
        [e, t] = c.useState(Li);
    return c.useEffect(() => (Hn.size === 0 && window.addEventListener("languagechange", Ho), Hn.add(t), () => {
        Hn.delete(t), Hn.size === 0 && window.removeEventListener("languagechange", Ho)
    }), []), n ? {
        locale: "en-US",
        direction: "ltr"
    } : e
}
const Wf = W.createContext(null);

function rr() {
    let n = Vf();
    return c.useContext(Wf) || n
}
const Hf = Symbol.for("react-aria.i18n.locale"),
    Uf = Symbol.for("react-aria.i18n.strings");
let Cn;
class Or {
    getStringForLocale(e, t) {
        let i = this.getStringsForLocale(t)[e];
        if (!i) throw new Error(`Could not find intl message ${e} in ${t} locale`);
        return i
    }
    getStringsForLocale(e) {
        let t = this.strings[e];
        return t || (t = Gf(e, this.strings, this.defaultLocale), this.strings[e] = t), t
    }
    static getGlobalDictionaryForPackage(e) {
        if (typeof window > "u") return null;
        let t = window[Hf];
        if (Cn === void 0) {
            let i = window[Uf];
            if (!i) return null;
            Cn = {};
            for (let o in i) Cn[o] = new Or({
                [t]: i[o]
            }, t)
        }
        let r = Cn == null ? void 0 : Cn[e];
        if (!r) throw new Error(`Strings for package "${e}" were not included by LocalizedStringProvider. Please add it to the list passed to createLocalizedStringDictionary.`);
        return r
    }
    constructor(e, t = "en-US") {
        this.strings = Object.fromEntries(Object.entries(e).filter(([, r]) => r)), this.defaultLocale = t
    }
}

function Gf(n, e, t = "en-US") {
    if (e[n]) return e[n];
    let r = Xf(n);
    if (e[r]) return e[r];
    for (let i in e)
        if (i.startsWith(r + "-")) return e[i];
    return e[t]
}

function Xf(n) {
    return Intl.Locale ? new Intl.Locale(n).language : n.split("-")[0]
}
const Uo = new Map,
    Go = new Map;
class qf {
    format(e, t) {
        let r = this.strings.getStringForLocale(e, this.locale);
        return typeof r == "function" ? r(t, this) : r
    }
    plural(e, t, r = "cardinal") {
        let i = t["=" + e];
        if (i) return typeof i == "function" ? i() : i;
        let o = this.locale + ":" + r,
            s = Uo.get(o);
        s || (s = new Intl.PluralRules(this.locale, {
            type: r
        }), Uo.set(o, s));
        let l = s.select(e);
        return i = t[l] || t.other, typeof i == "function" ? i() : i
    }
    number(e) {
        let t = Go.get(this.locale);
        return t || (t = new Intl.NumberFormat(this.locale), Go.set(this.locale, t)), t.format(e)
    }
    select(e, t) {
        let r = e[t] || e.other;
        return typeof r == "function" ? r() : r
    }
    constructor(e, t) {
        this.locale = e, this.strings = t
    }
}
const Xo = new WeakMap;

function Yf(n) {
    let e = Xo.get(n);
    return e || (e = new Or(n), Xo.set(n, e)), e
}

function Zf(n, e) {
    return e && Or.getGlobalDictionaryForPackage(e) || Yf(n)
}

function oo(n, e) {
    let {
        locale: t
    } = rr(), r = Zf(n, e);
    return c.useMemo(() => new qf(t, r), [t, r])
}
let oi = new Map;

function so(n) {
    let {
        locale: e
    } = rr(), t = e + (n ? Object.entries(n).sort((i, o) => i[0] < o[0] ? -1 : 1).join() : "");
    if (oi.has(t)) return oi.get(t);
    let r = new Intl.Collator(e, n);
    return oi.set(t, r), r
}

function Jf(n, e) {
    let {
        elementType: t = "button",
        isDisabled: r,
        onPress: i,
        onPressStart: o,
        onPressEnd: s,
        onPressUp: l,
        onPressChange: a,
        preventFocusOnPress: u,
        allowFocusWhenDisabled: d,
        onClick: h,
        href: D,
        target: g,
        rel: x,
        type: P = "button"
    } = n, L;
    t === "button" ? L = {
        type: P,
        disabled: r
    } : L = {
        role: "button",
        tabIndex: r ? void 0 : 0,
        href: t === "a" && !r ? D : void 0,
        target: t === "a" ? g : void 0,
        type: t === "input" ? P : void 0,
        disabled: t === "input" ? r : void 0,
        "aria-disabled": !r || t === "input" ? void 0 : r,
        rel: t === "a" ? x : void 0
    };
    let {
        pressProps: R,
        isPressed: N
    } = Ji({
        onPressStart: o,
        onPressEnd: s,
        onPressChange: a,
        onPress: i,
        onPressUp: l,
        isDisabled: r,
        preventFocusOnPress: u,
        ref: e
    }), {
        focusableProps: S
    } = If(n, e);
    d && (S.tabIndex = r ? -1 : S.tabIndex);
    let j = Oe(S, R, Nt(n, {
        labelable: !0
    }));
    return {
        isPressed: N,
        buttonProps: Oe(L, j, {
            "aria-haspopup": n["aria-haspopup"],
            "aria-expanded": n["aria-expanded"],
            "aria-controls": n["aria-controls"],
            "aria-pressed": n["aria-pressed"],
            onClick: k => {
                h && (h(k), console.warn("onClick is deprecated, please use onPress"))
            }
        })
    }
}
const hl = 7e3;
let Bt = null;

function qo(n, e = "assertive", t = hl) {
    Bt ? Bt.announce(n, e, t) : (Bt = new Qf, (typeof IS_REACT_ACT_ENVIRONMENT == "boolean" ? IS_REACT_ACT_ENVIRONMENT : typeof jest < "u") ? Bt.announce(n, e, t) : setTimeout(() => {
        Bt != null && Bt.isAttached() && (Bt == null || Bt.announce(n, e, t))
    }, 100))
}
class Qf {
    isAttached() {
        var e;
        return (e = this.node) === null || e === void 0 ? void 0 : e.isConnected
    }
    createLog(e) {
        let t = document.createElement("div");
        return t.setAttribute("role", "log"), t.setAttribute("aria-live", e), t.setAttribute("aria-relevant", "additions"), t
    }
    destroy() {
        this.node && (document.body.removeChild(this.node), this.node = null)
    }
    announce(e, t = "assertive", r = hl) {
        var i, o;
        if (!this.node) return;
        let s = document.createElement("div");
        typeof e == "object" ? (s.setAttribute("role", "img"), s.setAttribute("aria-labelledby", e["aria-labelledby"])) : s.textContent = e, t === "assertive" ? (i = this.assertiveLog) === null || i === void 0 || i.appendChild(s) : (o = this.politeLog) === null || o === void 0 || o.appendChild(s), e !== "" && setTimeout(() => {
            s.remove()
        }, r)
    }
    clear(e) {
        this.node && ((!e || e === "assertive") && this.assertiveLog && (this.assertiveLog.innerHTML = ""), (!e || e === "polite") && this.politeLog && (this.politeLog.innerHTML = ""))
    }
    constructor() {
        this.node = null, this.assertiveLog = null, this.politeLog = null, typeof document < "u" && (this.node = document.createElement("div"), this.node.dataset.liveAnnouncer = "true", Object.assign(this.node.style, {
            border: 0,
            clip: "rect(0 0 0 0)",
            clipPath: "inset(50%)",
            height: "1px",
            margin: "-1px",
            overflow: "hidden",
            padding: 0,
            position: "absolute",
            width: "1px",
            whiteSpace: "nowrap"
        }), this.assertiveLog = this.createLog("assertive"), this.node.appendChild(this.assertiveLog), this.politeLog = this.createLog("polite"), this.node.appendChild(this.politeLog), document.body.prepend(this.node))
    }
}
const Dl = {
        badInput: !1,
        customError: !1,
        patternMismatch: !1,
        rangeOverflow: !1,
        rangeUnderflow: !1,
        stepMismatch: !1,
        tooLong: !1,
        tooShort: !1,
        typeMismatch: !1,
        valueMissing: !1,
        valid: !0
    },
    vl = { ...Dl,
        customError: !0,
        valid: !1
    },
    In = {
        isInvalid: !1,
        validationDetails: Dl,
        validationErrors: []
    },
    ep = c.createContext({}),
    Yo = "__formValidationState" + Date.now();

function tp(n) {
    if (n[Yo]) {
        let {
            realtimeValidation: e,
            displayValidation: t,
            updateValidation: r,
            resetValidation: i,
            commitValidation: o
        } = n[Yo];
        return {
            realtimeValidation: e,
            displayValidation: t,
            updateValidation: r,
            resetValidation: i,
            commitValidation: o
        }
    }
    return np(n)
}

function np(n) {
    let {
        isInvalid: e,
        validationState: t,
        name: r,
        value: i,
        builtinValidation: o,
        validate: s,
        validationBehavior: l = "aria"
    } = n;
    t && (e || (e = t === "invalid"));
    let a = e !== void 0 ? {
            isInvalid: e,
            validationErrors: [],
            validationDetails: vl
        } : null,
        u = c.useMemo(() => {
            if (!s || i == null) return null;
            let O = rp(s, i);
            return Zo(O)
        }, [s, i]);
    o != null && o.validationDetails.valid && (o = void 0);
    let d = c.useContext(ep),
        h = c.useMemo(() => r ? Array.isArray(r) ? r.flatMap(O => Bi(d[O])) : Bi(d[r]) : [], [d, r]),
        [D, g] = c.useState(d),
        [x, P] = c.useState(!1);
    d !== D && (g(d), P(!1));
    let L = c.useMemo(() => Zo(x ? [] : h), [x, h]),
        R = c.useRef(In),
        [N, S] = c.useState(In),
        j = c.useRef(In),
        k = () => {
            if (!B) return;
            M(!1);
            let O = u || o || R.current;
            si(O, j.current) || (j.current = O, S(O))
        },
        [B, M] = c.useState(!1);
    return c.useEffect(k), {
        realtimeValidation: a || L || u || o || In,
        displayValidation: l === "native" ? a || L || N : a || L || u || o || N,
        updateValidation(O) {
            l === "aria" && !si(N, O) ? S(O) : R.current = O
        },
        resetValidation() {
            let O = In;
            si(O, j.current) || (j.current = O, S(O)), l === "native" && M(!1), P(!0)
        },
        commitValidation() {
            l === "native" && M(!0), P(!0)
        }
    }
}

function Bi(n) {
    return n ? Array.isArray(n) ? n : [n] : []
}

function rp(n, e) {
    if (typeof n == "function") {
        let t = n(e);
        if (t && typeof t != "boolean") return Bi(t)
    }
    return []
}

function Zo(n) {
    return n.length ? {
        isInvalid: !0,
        validationErrors: n,
        validationDetails: vl
    } : null
}

function si(n, e) {
    return n === e ? !0 : !!n && !!e && n.isInvalid === e.isInvalid && n.validationErrors.length === e.validationErrors.length && n.validationErrors.every((t, r) => t === e.validationErrors[r]) && Object.entries(n.validationDetails).every(([t, r]) => e.validationDetails[t] === r)
}

function ip(n, e, t) {
    let {
        validationBehavior: r,
        focus: i
    } = n;
    Fe(() => {
        if (r === "native" && (t != null && t.current) && !t.current.disabled) {
            let a = e.realtimeValidation.isInvalid ? e.realtimeValidation.validationErrors.join(" ") || "Invalid value." : "";
            t.current.setCustomValidity(a), t.current.hasAttribute("title") || (t.current.title = ""), e.realtimeValidation.isInvalid || e.updateValidation(sp(t.current))
        }
    });
    let o = it(() => {
            e.resetValidation()
        }),
        s = it(a => {
            var u;
            e.displayValidation.isInvalid || e.commitValidation();
            let d = t == null || (u = t.current) === null || u === void 0 ? void 0 : u.form;
            if (!a.defaultPrevented && t && d && lp(d) === t.current) {
                var h;
                i ? i() : (h = t.current) === null || h === void 0 || h.focus(), al("keyboard")
            }
            a.preventDefault()
        }),
        l = it(() => {
            e.commitValidation()
        });
    c.useEffect(() => {
        let a = t == null ? void 0 : t.current;
        if (!a) return;
        let u = a.form;
        return a.addEventListener("invalid", s), a.addEventListener("change", l), u == null || u.addEventListener("reset", o), () => {
            a.removeEventListener("invalid", s), a.removeEventListener("change", l), u == null || u.removeEventListener("reset", o)
        }
    }, [t, s, l, o, r])
}

function op(n) {
    let e = n.validity;
    return {
        badInput: e.badInput,
        customError: e.customError,
        patternMismatch: e.patternMismatch,
        rangeOverflow: e.rangeOverflow,
        rangeUnderflow: e.rangeUnderflow,
        stepMismatch: e.stepMismatch,
        tooLong: e.tooLong,
        tooShort: e.tooShort,
        typeMismatch: e.typeMismatch,
        valueMissing: e.valueMissing,
        valid: e.valid
    }
}

function sp(n) {
    return {
        isInvalid: !n.validity.valid,
        validationDetails: op(n),
        validationErrors: n.validationMessage ? [n.validationMessage] : []
    }
}

function lp(n) {
    for (let e = 0; e < n.elements.length; e++) {
        let t = n.elements[e];
        if (!t.validity.valid) return t
    }
    return null
}

function gl(n) {
    let {
        id: e,
        label: t,
        "aria-labelledby": r,
        "aria-label": i,
        labelElementType: o = "label"
    } = n;
    e = Ct(e);
    let s = Ct(),
        l = {};
    t ? (r = r ? `${s} ${r}` : s, l = {
        id: s,
        htmlFor: o === "label" ? e : void 0
    }) : !r && !i && console.warn("If you do not provide a visible label, you must specify an aria-label or aria-labelledby attribute for accessibility");
    let a = zs({
        id: e,
        "aria-label": i,
        "aria-labelledby": r
    });
    return {
        labelProps: l,
        fieldProps: a
    }
}

function ap(n) {
    let {
        description: e,
        errorMessage: t,
        isInvalid: r,
        validationState: i
    } = n, {
        labelProps: o,
        fieldProps: s
    } = gl(n), l = $r([!!e, !!t, r, i]), a = $r([!!e, !!t, r, i]);
    return s = Oe(s, {
        "aria-describedby": [l, a, n["aria-describedby"]].filter(Boolean).join(" ") || void 0
    }), {
        labelProps: o,
        fieldProps: s,
        descriptionProps: {
            id: l
        },
        errorMessageProps: {
            id: a
        }
    }
}
const Jo = {
    border: 0,
    clip: "rect(0 0 0 0)",
    clipPath: "inset(50%)",
    height: "1px",
    margin: "-1px",
    overflow: "hidden",
    padding: 0,
    position: "absolute",
    width: "1px",
    whiteSpace: "nowrap"
};

function ml(n = {}) {
    let {
        style: e,
        isFocusable: t
    } = n, [r, i] = c.useState(!1), {
        focusWithinProps: o
    } = Kr({
        isDisabled: !t,
        onFocusWithinChange: l => i(l)
    }), s = c.useMemo(() => r ? e : e ? { ...Jo,
        ...e
    } : Jo, [r]);
    return {
        visuallyHiddenProps: { ...o,
            style: s
        }
    }
}

function up(n) {
    let {
        children: e,
        elementType: t = "div",
        isFocusable: r,
        style: i,
        ...o
    } = n, {
        visuallyHiddenProps: s
    } = ml(n);
    return W.createElement(t, Oe(o, s), e)
}
const Mt = {
        top: "top",
        bottom: "top",
        left: "left",
        right: "left"
    },
    kr = {
        top: "bottom",
        bottom: "top",
        left: "right",
        right: "left"
    },
    cp = {
        top: "left",
        left: "top"
    },
    Ri = {
        top: "height",
        left: "width"
    },
    bl = {
        width: "totalWidth",
        height: "totalHeight"
    },
    mr = {};
let et = typeof document < "u" ? window.visualViewport : null;

function Qo(n) {
    let e = 0,
        t = 0,
        r = 0,
        i = 0,
        o = 0,
        s = 0,
        l = {};
    var a;
    let u = ((a = et == null ? void 0 : et.scale) !== null && a !== void 0 ? a : 1) > 1;
    if (n.tagName === "BODY") {
        let x = document.documentElement;
        r = x.clientWidth, i = x.clientHeight;
        var d;
        e = (d = et == null ? void 0 : et.width) !== null && d !== void 0 ? d : r;
        var h;
        t = (h = et == null ? void 0 : et.height) !== null && h !== void 0 ? h : i, l.top = x.scrollTop || n.scrollTop, l.left = x.scrollLeft || n.scrollLeft, et && (o = et.offsetTop, s = et.offsetLeft)
    } else({
        width: e,
        height: t,
        top: o,
        left: s
    } = Pn(n)), l.top = n.scrollTop, l.left = n.scrollLeft, r = e, i = t;
    if (Vi() && (n.tagName === "BODY" || n.tagName === "HTML") && u) {
        l.top = 0, l.left = 0;
        var D;
        o = (D = et == null ? void 0 : et.pageTop) !== null && D !== void 0 ? D : 0;
        var g;
        s = (g = et == null ? void 0 : et.pageLeft) !== null && g !== void 0 ? g : 0
    }
    return {
        width: e,
        height: t,
        totalWidth: r,
        totalHeight: i,
        scroll: l,
        top: o,
        left: s
    }
}

function dp(n) {
    return {
        top: n.scrollTop,
        left: n.scrollLeft,
        width: n.scrollWidth,
        height: n.scrollHeight
    }
}

function es(n, e, t, r, i, o, s) {
    var l;
    let a = (l = i.scroll[n]) !== null && l !== void 0 ? l : 0,
        u = r[Ri[n]],
        d = r.scroll[Mt[n]] + o,
        h = u + r.scroll[Mt[n]] - o,
        D = e - a + s[n] - r[Mt[n]],
        g = e - a + t + s[n] - r[Mt[n]];
    return D < d ? d - D : g > h ? Math.max(h - g, d - D) : 0
}

function fp(n) {
    let e = window.getComputedStyle(n);
    return {
        top: parseInt(e.marginTop, 10) || 0,
        bottom: parseInt(e.marginBottom, 10) || 0,
        left: parseInt(e.marginLeft, 10) || 0,
        right: parseInt(e.marginRight, 10) || 0
    }
}

function ts(n) {
    if (mr[n]) return mr[n];
    let [e, t] = n.split(" "), r = Mt[e] || "right", i = cp[r];
    Mt[t] || (t = "center");
    let o = Ri[r],
        s = Ri[i];
    return mr[n] = {
        placement: e,
        crossPlacement: t,
        axis: r,
        crossAxis: i,
        size: o,
        crossSize: s
    }, mr[n]
}

function li(n, e, t, r, i, o, s, l, a, u) {
    let {
        placement: d,
        crossPlacement: h,
        axis: D,
        crossAxis: g,
        size: x,
        crossSize: P
    } = r, L = {};
    var R;
    L[g] = (R = n[g]) !== null && R !== void 0 ? R : 0;
    var N, S, j, k;
    h === "center" ? L[g] += (((N = n[P]) !== null && N !== void 0 ? N : 0) - ((S = t[P]) !== null && S !== void 0 ? S : 0)) / 2 : h !== g && (L[g] += ((j = n[P]) !== null && j !== void 0 ? j : 0) - ((k = t[P]) !== null && k !== void 0 ? k : 0)), L[g] += o;
    const B = n[g] - t[P] + a + u,
        M = n[g] + n[P] - a - u;
    if (L[g] = xi(L[g], B, M), d === D) {
        const f = l ? s[x] : e[bl[x]];
        L[kr[D]] = Math.floor(f - n[D] + i)
    } else L[D] = Math.floor(n[D] + n[x] + i);
    return L
}

function pp(n, e, t, r, i, o, s, l) {
    const a = r ? t.height : e[bl.height];
    var u;
    let d = n.top != null ? t.top + n.top : t.top + (a - ((u = n.bottom) !== null && u !== void 0 ? u : 0) - s);
    var h, D, g, x, P, L;
    let R = l !== "top" ? Math.max(0, e.height + e.top + ((h = e.scroll.top) !== null && h !== void 0 ? h : 0) - d - (((D = i.top) !== null && D !== void 0 ? D : 0) + ((g = i.bottom) !== null && g !== void 0 ? g : 0) + o)) : Math.max(0, d + s - (e.top + ((x = e.scroll.top) !== null && x !== void 0 ? x : 0)) - (((P = i.top) !== null && P !== void 0 ? P : 0) + ((L = i.bottom) !== null && L !== void 0 ? L : 0) + o));
    return Math.min(e.height - o * 2, R)
}

function ns(n, e, t, r, i, o) {
    let {
        placement: s,
        axis: l,
        size: a
    } = o;
    var u, d;
    if (s === l) return Math.max(0, t[l] - n[l] - ((u = n.scroll[l]) !== null && u !== void 0 ? u : 0) + e[l] - ((d = r[l]) !== null && d !== void 0 ? d : 0) - r[kr[l]] - i);
    var h;
    return Math.max(0, n[a] + n[l] + n.scroll[l] - e[l] - t[l] - t[a] - ((h = r[l]) !== null && h !== void 0 ? h : 0) - r[kr[l]] - i)
}

function hp(n, e, t, r, i, o, s, l, a, u, d, h, D, g, x, P) {
    let L = ts(n),
        {
            size: R,
            crossAxis: N,
            crossSize: S,
            placement: j,
            crossPlacement: k
        } = L,
        B = li(e, l, t, L, d, h, u, D, x, P),
        M = d,
        f = ns(l, u, e, i, o + d, L);
    if (s && r[R] > f) {
        let te = ts(`${kr[j]} ${k}`),
            se = li(e, l, t, te, d, h, u, D, x, P);
        ns(l, u, e, i, o + d, te) > f && (L = te, B = se, M = d)
    }
    let I = "bottom";
    L.axis === "top" ? L.placement === "top" ? I = "top" : L.placement === "bottom" && (I = "bottom") : L.crossAxis === "top" && (L.crossPlacement === "top" ? I = "bottom" : L.crossPlacement === "bottom" && (I = "top"));
    let O = es(N, B[N], t[S], l, a, o, u);
    B[N] += O;
    let T = pp(B, l, u, D, i, o, t.height, I);
    g && g < T && (T = g), t.height = Math.min(t.height, T), B = li(e, l, t, L, M, h, u, D, x, P), O = es(N, B[N], t[S], l, a, o, u), B[N] += O;
    let K = {},
        m = e[N] + .5 * e[S] - B[N] - i[Mt[N]];
    const p = x / 2 + P;
    var w, C, A, E;
    const H = Mt[N] === "left" ? ((w = i.left) !== null && w !== void 0 ? w : 0) + ((C = i.right) !== null && C !== void 0 ? C : 0) : ((A = i.top) !== null && A !== void 0 ? A : 0) + ((E = i.bottom) !== null && E !== void 0 ? E : 0),
        X = t[S] - H - x / 2 - P,
        q = e[N] + x / 2 - (B[N] + i[Mt[N]]),
        G = e[N] + e[S] - x / 2 - (B[N] + i[Mt[N]]),
        ne = xi(m, q, G);
    return K[N] = xi(ne, p, X), {
        position: B,
        maxHeight: T,
        arrowOffsetLeft: K.left,
        arrowOffsetTop: K.top,
        placement: L.placement
    }
}

function Dp(n) {
    let {
        placement: e,
        targetNode: t,
        overlayNode: r,
        scrollNode: i,
        padding: o,
        shouldFlip: s,
        boundaryElement: l,
        offset: a,
        crossOffset: u,
        maxHeight: d,
        arrowSize: h = 0,
        arrowBoundaryOffset: D = 0
    } = n, g = r instanceof HTMLElement ? vp(r) : document.documentElement, x = g === document.documentElement;
    const P = window.getComputedStyle(g).position;
    let L = !!P && P !== "static",
        R = x ? Pn(t) : rs(t, g);
    if (!x) {
        let {
            marginTop: K,
            marginLeft: m
        } = window.getComputedStyle(t);
        R.top += parseInt(K, 10) || 0, R.left += parseInt(m, 10) || 0
    }
    let N = Pn(r),
        S = fp(r);
    var j, k;
    N.width += ((j = S.left) !== null && j !== void 0 ? j : 0) + ((k = S.right) !== null && k !== void 0 ? k : 0);
    var B, M;
    N.height += ((B = S.top) !== null && B !== void 0 ? B : 0) + ((M = S.bottom) !== null && M !== void 0 ? M : 0);
    let f = dp(i),
        I = Qo(l),
        O = Qo(g),
        T = l.tagName === "BODY" ? Pn(g) : rs(g, l);
    return g.tagName === "HTML" && l.tagName === "BODY" && (O.scroll.top = 0, O.scroll.left = 0), hp(e, R, N, f, S, o, s, I, O, T, a, u, L, d, h, D)
}

function Pn(n) {
    let {
        top: e,
        left: t,
        width: r,
        height: i
    } = n.getBoundingClientRect(), {
        scrollTop: o,
        scrollLeft: s,
        clientTop: l,
        clientLeft: a
    } = document.documentElement;
    return {
        top: e + o - l,
        left: t + s - a,
        width: r,
        height: i
    }
}

function rs(n, e) {
    let t = window.getComputedStyle(n),
        r;
    if (t.position === "fixed") {
        let {
            top: i,
            left: o,
            width: s,
            height: l
        } = n.getBoundingClientRect();
        r = {
            top: i,
            left: o,
            width: s,
            height: l
        }
    } else {
        r = Pn(n);
        let i = Pn(e),
            o = window.getComputedStyle(e);
        i.top += (parseInt(o.borderTopWidth, 10) || 0) - e.scrollTop, i.left += (parseInt(o.borderLeftWidth, 10) || 0) - e.scrollLeft, r.top -= i.top, r.left -= i.left
    }
    return r.top -= parseInt(t.marginTop, 10) || 0, r.left -= parseInt(t.marginLeft, 10) || 0, r
}

function vp(n) {
    let e = n.offsetParent;
    if (e && e === document.body && window.getComputedStyle(e).position === "static" && !is(e) && (e = document.documentElement), e == null)
        for (e = n.parentElement; e && !is(e);) e = e.parentElement;
    return e || document.documentElement
}

function is(n) {
    let e = window.getComputedStyle(n);
    return e.transform !== "none" || /transform|perspective/.test(e.willChange) || e.filter !== "none" || e.contain === "paint" || "backdropFilter" in e && e.backdropFilter !== "none" || "WebkitBackdropFilter" in e && e.WebkitBackdropFilter !== "none"
}
const yl = new WeakMap;

function gp(n) {
    let {
        triggerRef: e,
        isOpen: t,
        onClose: r
    } = n;
    c.useEffect(() => {
        if (!t || r === null) return;
        let i = o => {
            let s = o.target;
            if (!e.current || s instanceof Node && !s.contains(e.current) || o.target instanceof HTMLInputElement || o.target instanceof HTMLTextAreaElement) return;
            let l = r || yl.get(e.current);
            l && l()
        };
        return window.addEventListener("scroll", i, !0), () => {
            window.removeEventListener("scroll", i, !0)
        }
    }, [t, r, e])
}
let He = typeof document < "u" ? window.visualViewport : null;

function mp(n) {
    let {
        direction: e
    } = rr(), {
        arrowSize: t = 0,
        targetRef: r,
        overlayRef: i,
        scrollRef: o = i,
        placement: s = "bottom",
        containerPadding: l = 12,
        shouldFlip: a = !0,
        boundaryElement: u = typeof document < "u" ? document.body : null,
        offset: d = 0,
        crossOffset: h = 0,
        shouldUpdatePosition: D = !0,
        isOpen: g = !0,
        onClose: x,
        maxHeight: P,
        arrowBoundaryOffset: L = 0
    } = n, [R, N] = c.useState(null), S = [D, s, i.current, r.current, o.current, l, a, u, d, h, g, e, P, L, t], j = c.useRef(He == null ? void 0 : He.scale);
    c.useEffect(() => {
        g && (j.current = He == null ? void 0 : He.scale)
    }, [g]);
    let k = c.useCallback(() => {
        if (D === !1 || !g || !i.current || !r.current || !u || (He == null ? void 0 : He.scale) !== j.current) return;
        let O = null;
        if (o.current && o.current.contains(document.activeElement)) {
            var T;
            let E = (T = document.activeElement) === null || T === void 0 ? void 0 : T.getBoundingClientRect(),
                H = o.current.getBoundingClientRect();
            var K;
            if (O = {
                    type: "top",
                    offset: ((K = E == null ? void 0 : E.top) !== null && K !== void 0 ? K : 0) - H.top
                }, O.offset > H.height / 2) {
                O.type = "bottom";
                var m;
                O.offset = ((m = E == null ? void 0 : E.bottom) !== null && m !== void 0 ? m : 0) - H.bottom
            }
        }
        let p = i.current;
        if (!P && i.current) {
            var w;
            p.style.top = "0px", p.style.bottom = "";
            var C;
            p.style.maxHeight = ((C = (w = window.visualViewport) === null || w === void 0 ? void 0 : w.height) !== null && C !== void 0 ? C : window.innerHeight) + "px"
        }
        let A = Dp({
            placement: yp(s, e),
            overlayNode: i.current,
            targetNode: r.current,
            scrollNode: o.current || i.current,
            padding: l,
            shouldFlip: a,
            boundaryElement: u,
            offset: d,
            crossOffset: h,
            maxHeight: P,
            arrowSize: t,
            arrowBoundaryOffset: L
        });
        if (A.position) {
            if (p.style.top = "", p.style.bottom = "", p.style.left = "", p.style.right = "", Object.keys(A.position).forEach(E => p.style[E] = A.position[E] + "px"), p.style.maxHeight = A.maxHeight != null ? A.maxHeight + "px" : "", O && document.activeElement && o.current) {
                let E = document.activeElement.getBoundingClientRect(),
                    H = o.current.getBoundingClientRect(),
                    X = E[O.type] - H[O.type];
                o.current.scrollTop += X - O.offset
            }
            N(A)
        }
    }, S);
    Fe(k, S), bp(k), Ei({
        ref: i,
        onResize: k
    }), Ei({
        ref: r,
        onResize: k
    });
    let B = c.useRef(!1);
    Fe(() => {
        let O, T = () => {
                B.current = !0, clearTimeout(O), O = setTimeout(() => {
                    B.current = !1
                }, 500), k()
            },
            K = () => {
                B.current && T()
            };
        return He == null || He.addEventListener("resize", T), He == null || He.addEventListener("scroll", K), () => {
            He == null || He.removeEventListener("resize", T), He == null || He.removeEventListener("scroll", K)
        }
    }, [k]);
    let M = c.useCallback(() => {
        B.current || x == null || x()
    }, [x, B]);
    gp({
        triggerRef: r,
        isOpen: g,
        onClose: x && M
    });
    var f, I;
    return {
        overlayProps: {
            style: {
                position: "absolute",
                zIndex: 1e5,
                ...R == null ? void 0 : R.position,
                maxHeight: (f = R == null ? void 0 : R.maxHeight) !== null && f !== void 0 ? f : "100vh"
            }
        },
        placement: (I = R == null ? void 0 : R.placement) !== null && I !== void 0 ? I : null,
        arrowProps: {
            "aria-hidden": "true",
            role: "presentation",
            style: {
                left: R == null ? void 0 : R.arrowOffsetLeft,
                top: R == null ? void 0 : R.arrowOffsetTop
            }
        },
        updatePosition: k
    }
}

function bp(n) {
    Fe(() => (window.addEventListener("resize", n, !1), () => {
        window.removeEventListener("resize", n, !1)
    }), [n])
}

function yp(n, e) {
    return e === "rtl" ? n.replace("start", "right").replace("end", "left") : n.replace("start", "left").replace("end", "right")
}
const Wt = [];

function Ep(n, e) {
    let {
        onClose: t,
        shouldCloseOnBlur: r,
        isOpen: i,
        isDismissable: o = !1,
        isKeyboardDismissDisabled: s = !1,
        shouldCloseOnInteractOutside: l
    } = n;
    c.useEffect(() => (i && Wt.push(e), () => {
        let x = Wt.indexOf(e);
        x >= 0 && Wt.splice(x, 1)
    }), [i, e]);
    let a = () => {
            Wt[Wt.length - 1] === e && t && t()
        },
        u = x => {
            (!l || l(x.target)) && Wt[Wt.length - 1] === e && (x.stopPropagation(), x.preventDefault())
        },
        d = x => {
            (!l || l(x.target)) && (Wt[Wt.length - 1] === e && (x.stopPropagation(), x.preventDefault()), a())
        },
        h = x => {
            x.key === "Escape" && !s && !x.nativeEvent.isComposing && (x.stopPropagation(), x.preventDefault(), a())
        };
    xf({
        ref: e,
        onInteractOutside: o && i ? d : void 0,
        onInteractOutsideStart: u
    });
    let {
        focusWithinProps: D
    } = Kr({
        isDisabled: !r,
        onBlurWithin: x => {
            !x.relatedTarget || Af(x.relatedTarget) || (!l || l(x.relatedTarget)) && (t == null || t())
        }
    }), g = x => {
        x.target === x.currentTarget && x.preventDefault()
    };
    return {
        overlayProps: {
            onKeyDown: h,
            ...D
        },
        underlayProps: {
            onPointerDown: g
        }
    }
}

function Cp(n, e, t) {
    let {
        type: r
    } = n, {
        isOpen: i
    } = e;
    c.useEffect(() => {
        t && t.current && yl.set(t.current, e.close)
    });
    let o;
    r === "menu" ? o = !0 : r === "listbox" && (o = "listbox");
    let s = Ct();
    return {
        triggerProps: {
            "aria-haspopup": o,
            "aria-expanded": i,
            "aria-controls": i ? s : void 0,
            onPress: e.toggle
        },
        overlayProps: {
            id: s
        }
    }
}
const ai = typeof document < "u" && window.visualViewport,
    xp = new Set(["checkbox", "radio", "range", "color", "file", "image", "button", "submit", "reset"]);
let br = 0,
    ui;

function $p(n = {}) {
    let {
        isDisabled: e
    } = n;
    Fe(() => {
        if (!e) return br++, br === 1 && (Mr() ? ui = Fp() : ui = wp()), () => {
            br--, br === 0 && ui()
        }
    }, [e])
}

function wp() {
    return hn(Sn(document.documentElement, "paddingRight", `${window.innerWidth-document.documentElement.clientWidth}px`), Sn(document.documentElement, "overflow", "hidden"))
}

function Fp() {
    let n, e, t = u => {
            n = Ws(u.target, !0), !(n === document.documentElement && n === document.body) && n instanceof HTMLElement && window.getComputedStyle(n).overscrollBehavior === "auto" && (e = Sn(n, "overscrollBehavior", "contain"))
        },
        r = u => {
            if (!n || n === document.documentElement || n === document.body) {
                u.preventDefault();
                return
            }
            n.scrollHeight === n.clientHeight && n.scrollWidth === n.clientWidth && u.preventDefault()
        },
        i = () => {
            e && e()
        },
        o = u => {
            let d = u.target;
            Sp(d) && (l(), d.style.transform = "translateY(-2000px)", requestAnimationFrame(() => {
                d.style.transform = "", ai && (ai.height < window.innerHeight ? requestAnimationFrame(() => {
                    os(d)
                }) : ai.addEventListener("resize", () => os(d), {
                    once: !0
                }))
            }))
        },
        s = null,
        l = () => {
            if (s) return;
            let u = () => {
                    window.scrollTo(0, 0)
                },
                d = window.pageXOffset,
                h = window.pageYOffset;
            s = hn(Kn(window, "scroll", u), Sn(document.documentElement, "paddingRight", `${window.innerWidth-document.documentElement.clientWidth}px`), Sn(document.documentElement, "overflow", "hidden"), Sn(document.body, "marginTop", `-${h}px`), () => {
                window.scrollTo(d, h)
            }), window.scrollTo(0, 0)
        },
        a = hn(Kn(document, "touchstart", t, {
            passive: !1,
            capture: !0
        }), Kn(document, "touchmove", r, {
            passive: !1,
            capture: !0
        }), Kn(document, "touchend", i, {
            passive: !1,
            capture: !0
        }), Kn(document, "focus", o, !0));
    return () => {
        e == null || e(), s == null || s(), a()
    }
}

function Sn(n, e, t) {
    let r = n.style[e];
    return n.style[e] = t, () => {
        n.style[e] = r
    }
}

function Kn(n, e, t, r) {
    return n.addEventListener(e, t, r), () => {
        n.removeEventListener(e, t, r)
    }
}

function os(n) {
    let e = document.scrollingElement || document.documentElement,
        t = n;
    for (; t && t !== e;) {
        let r = Ws(t);
        if (r !== document.documentElement && r !== document.body && r !== t) {
            let i = r.getBoundingClientRect().top,
                o = t.getBoundingClientRect().top;
            o > i + t.clientHeight && (r.scrollTop += o - i)
        }
        t = r.parentElement
    }
}

function Sp(n) {
    return n instanceof HTMLInputElement && !xp.has(n.type) || n instanceof HTMLTextAreaElement || n instanceof HTMLElement && n.isContentEditable
}
var El = {};
El = {
    dismiss: "تجاهل"
};
var Cl = {};
Cl = {
    dismiss: "Отхвърляне"
};
var xl = {};
xl = {
    dismiss: "Odstranit"
};
var $l = {};
$l = {
    dismiss: "Luk"
};
var wl = {};
wl = {
    dismiss: "Schließen"
};
var Fl = {};
Fl = {
    dismiss: "Απόρριψη"
};
var Sl = {};
Sl = {
    dismiss: "Dismiss"
};
var _l = {};
_l = {
    dismiss: "Descartar"
};
var Pl = {};
Pl = {
    dismiss: "Lõpeta"
};
var Tl = {};
Tl = {
    dismiss: "Hylkää"
};
var kl = {};
kl = {
    dismiss: "Rejeter"
};
var Al = {};
Al = {
    dismiss: "התעלם"
};
var Ll = {};
Ll = {
    dismiss: "Odbaci"
};
var Bl = {};
Bl = {
    dismiss: "Elutasítás"
};
var Rl = {};
Rl = {
    dismiss: "Ignora"
};
var Ml = {};
Ml = {
    dismiss: "閉じる"
};
var Nl = {};
Nl = {
    dismiss: "무시"
};
var Il = {};
Il = {
    dismiss: "Atmesti"
};
var Kl = {};
Kl = {
    dismiss: "Nerādīt"
};
var Ol = {};
Ol = {
    dismiss: "Lukk"
};
var jl = {};
jl = {
    dismiss: "Negeren"
};
var zl = {};
zl = {
    dismiss: "Zignoruj"
};
var Vl = {};
Vl = {
    dismiss: "Descartar"
};
var Wl = {};
Wl = {
    dismiss: "Dispensar"
};
var Hl = {};
Hl = {
    dismiss: "Revocare"
};
var Ul = {};
Ul = {
    dismiss: "Пропустить"
};
var Gl = {};
Gl = {
    dismiss: "Zrušiť"
};
var Xl = {};
Xl = {
    dismiss: "Opusti"
};
var ql = {};
ql = {
    dismiss: "Odbaci"
};
var Yl = {};
Yl = {
    dismiss: "Avvisa"
};
var Zl = {};
Zl = {
    dismiss: "Kapat"
};
var Jl = {};
Jl = {
    dismiss: "Скасувати"
};
var Ql = {};
Ql = {
    dismiss: "取消"
};
var ea = {};
ea = {
    dismiss: "關閉"
};
var ta = {};
ta = {
    "ar-AE": El,
    "bg-BG": Cl,
    "cs-CZ": xl,
    "da-DK": $l,
    "de-DE": wl,
    "el-GR": Fl,
    "en-US": Sl,
    "es-ES": _l,
    "et-EE": Pl,
    "fi-FI": Tl,
    "fr-FR": kl,
    "he-IL": Al,
    "hr-HR": Ll,
    "hu-HU": Bl,
    "it-IT": Rl,
    "ja-JP": Ml,
    "ko-KR": Nl,
    "lt-LT": Il,
    "lv-LV": Kl,
    "nb-NO": Ol,
    "nl-NL": jl,
    "pl-PL": zl,
    "pt-BR": Vl,
    "pt-PT": Wl,
    "ro-RO": Hl,
    "ru-RU": Ul,
    "sk-SK": Gl,
    "sl-SI": Xl,
    "sr-SP": ql,
    "sv-SE": Yl,
    "tr-TR": Zl,
    "uk-UA": Jl,
    "zh-CN": Ql,
    "zh-TW": ea
};

function _p(n) {
    return n && n.__esModule ? n.default : n
}

function ss(n) {
    let {
        onDismiss: e,
        ...t
    } = n, r = oo(_p(ta), "@react-aria/overlays"), i = zs(t, r.format("dismiss")), o = () => {
        e && e()
    };
    return W.createElement(up, null, W.createElement("button", { ...i,
        tabIndex: -1,
        onClick: o,
        style: {
            width: 1,
            height: 1
        }
    }))
}
let On = new WeakMap,
    gt = [];

function Pp(n, e = document.body) {
    let t = new Set(n),
        r = new Set,
        i = a => {
            for (let D of a.querySelectorAll("[data-live-announcer], [data-react-aria-top-layer]")) t.add(D);
            let u = D => {
                    if (t.has(D) || D.parentElement && r.has(D.parentElement) && D.parentElement.getAttribute("role") !== "row") return NodeFilter.FILTER_REJECT;
                    for (let g of t)
                        if (D.contains(g)) return NodeFilter.FILTER_SKIP;
                    return NodeFilter.FILTER_ACCEPT
                },
                d = document.createTreeWalker(a, NodeFilter.SHOW_ELEMENT, {
                    acceptNode: u
                }),
                h = u(a);
            if (h === NodeFilter.FILTER_ACCEPT && o(a), h !== NodeFilter.FILTER_REJECT) {
                let D = d.nextNode();
                for (; D != null;) o(D), D = d.nextNode()
            }
        },
        o = a => {
            var u;
            let d = (u = On.get(a)) !== null && u !== void 0 ? u : 0;
            a.getAttribute("aria-hidden") === "true" && d === 0 || (d === 0 && a.setAttribute("aria-hidden", "true"), r.add(a), On.set(a, d + 1))
        };
    gt.length && gt[gt.length - 1].disconnect(), i(e);
    let s = new MutationObserver(a => {
        for (let u of a)
            if (!(u.type !== "childList" || u.addedNodes.length === 0) && ![...t, ...r].some(d => d.contains(u.target))) {
                for (let d of u.removedNodes) d instanceof Element && (t.delete(d), r.delete(d));
                for (let d of u.addedNodes)(d instanceof HTMLElement || d instanceof SVGElement) && (d.dataset.liveAnnouncer === "true" || d.dataset.reactAriaTopLayer === "true") ? t.add(d) : d instanceof Element && i(d)
            }
    });
    s.observe(e, {
        childList: !0,
        subtree: !0
    });
    let l = {
        observe() {
            s.observe(e, {
                childList: !0,
                subtree: !0
            })
        },
        disconnect() {
            s.disconnect()
        }
    };
    return gt.push(l), () => {
        s.disconnect();
        for (let a of r) {
            let u = On.get(a);
            u != null && (u === 1 ? (a.removeAttribute("aria-hidden"), On.delete(a)) : On.set(a, u - 1))
        }
        l === gt[gt.length - 1] ? (gt.pop(), gt.length && gt[gt.length - 1].observe()) : gt.splice(gt.indexOf(l), 1)
    }
}

function Tp(n, e) {
    let {
        triggerRef: t,
        popoverRef: r,
        isNonModal: i,
        isKeyboardDismissDisabled: o,
        shouldCloseOnInteractOutside: s,
        ...l
    } = n, {
        overlayProps: a,
        underlayProps: u
    } = Ep({
        isOpen: e.isOpen && !l["data-react-aria-top-layer"],
        onClose: e.close,
        shouldCloseOnBlur: !0,
        isDismissable: !i,
        isKeyboardDismissDisabled: o,
        shouldCloseOnInteractOutside: s
    }, r), {
        overlayProps: d,
        arrowProps: h,
        placement: D
    } = mp({ ...l,
        targetRef: t,
        overlayRef: r,
        isOpen: e.isOpen,
        onClose: i ? e.close : null
    });
    return $p({
        isDisabled: i || !e.isOpen
    }), Fe(() => {
        if (e.isOpen && !i && r.current) return Pp([r.current])
    }, [i, e.isOpen, r]), {
        popoverProps: Oe(a, d),
        arrowProps: h,
        underlayProps: u,
        placement: D
    }
}
const kp = c.createContext({});

function Ap() {
    var n;
    return (n = c.useContext(kp)) !== null && n !== void 0 ? n : {}
}
const Lp = W.createContext(null);

function Bp(n) {
    let e = Ln(),
        {
            portalContainer: t = e ? null : document.body,
            isExiting: r
        } = n,
        [i, o] = c.useState(!1),
        s = c.useMemo(() => ({
            contain: i,
            setContain: o
        }), [i, o]),
        {
            getContainer: l
        } = Ap();
    if (!n.portalContainer && l && (t = l()), !t) return null;
    let a = n.children;
    return n.disableFocusManagement || (a = W.createElement(to, {
        restoreFocus: !0,
        contain: i && !r
    }, a)), a = W.createElement(Lp.Provider, {
        value: s
    }, W.createElement(hf, null, a)), jn.createPortal(a, t)
}
const lo = new WeakMap;

function Rp(n) {
    return typeof n == "string" ? n.replace(/\s*/g, "") : "" + n
}

function Mp(n, e) {
    let t = lo.get(n);
    if (!t) throw new Error("Unknown list");
    return `${t.id}-option-${Rp(e)}`
}

function Mi(n) {
    return wd() ? n.altKey : n.ctrlKey
}
const Np = 1e3;

function na(n) {
    let {
        keyboardDelegate: e,
        selectionManager: t,
        onTypeSelect: r
    } = n, i = c.useRef({
        search: "",
        timeout: void 0
    }).current, o = s => {
        let l = Ip(s.key);
        if (!(!l || s.ctrlKey || s.metaKey || !s.currentTarget.contains(s.target))) {
            if (l === " " && i.search.trim().length > 0 && (s.preventDefault(), "continuePropagation" in s || s.stopPropagation()), i.search += l, e.getKeyForSearch != null) {
                let a = e.getKeyForSearch(i.search, t.focusedKey);
                a == null && (a = e.getKeyForSearch(i.search)), a != null && (t.setFocusedKey(a), r && r(a))
            }
            clearTimeout(i.timeout), i.timeout = setTimeout(() => {
                i.search = ""
            }, Np)
        }
    };
    return {
        typeSelectProps: {
            onKeyDownCapture: e.getKeyForSearch ? o : void 0
        }
    }
}

function Ip(n) {
    return n.length === 1 || !/^[A-Z]/i.test(n) ? n : ""
}

function Kp(n) {
    let {
        selectionManager: e,
        keyboardDelegate: t,
        ref: r,
        autoFocus: i = !1,
        shouldFocusWrap: o = !1,
        disallowEmptySelection: s = !1,
        disallowSelectAll: l = !1,
        selectOnFocus: a = e.selectionBehavior === "replace",
        disallowTypeAhead: u = !1,
        shouldUseVirtualFocus: d,
        allowsTabNavigation: h = !1,
        isVirtualized: D,
        scrollRef: g = r,
        linkBehavior: x = "action"
    } = n, {
        direction: P
    } = rr(), L = Hi(), R = m => {
        var p;
        if (m.altKey && m.key === "Tab" && m.preventDefault(), !(!((p = r.current) === null || p === void 0) && p.contains(m.target))) return;
        const w = (z, oe) => {
            if (z != null) {
                if (e.isLink(z) && x === "selection" && a && !Mi(m)) {
                    var Q;
                    Ar.flushSync(() => {
                        e.setFocusedKey(z, oe)
                    });
                    let re = (Q = g.current) === null || Q === void 0 ? void 0 : Q.querySelector(`[data-key="${CSS.escape(z.toString())}"]`),
                        ae = e.getItemProps(z);
                    re && L.open(re, m, ae.href, ae.routerOptions);
                    return
                }
                if (e.setFocusedKey(z, oe), e.isLink(z) && x === "override") return;
                m.shiftKey && e.selectionMode === "multiple" ? e.extendSelection(z) : a && !Mi(m) && e.replaceSelection(z)
            }
        };
        switch (m.key) {
            case "ArrowDown":
                if (t.getKeyBelow) {
                    var C, A, E;
                    let z = e.focusedKey != null ? (C = t.getKeyBelow) === null || C === void 0 ? void 0 : C.call(t, e.focusedKey) : (A = t.getFirstKey) === null || A === void 0 ? void 0 : A.call(t);
                    z == null && o && (z = (E = t.getFirstKey) === null || E === void 0 ? void 0 : E.call(t, e.focusedKey)), z != null && (m.preventDefault(), w(z))
                }
                break;
            case "ArrowUp":
                if (t.getKeyAbove) {
                    var H, X, q;
                    let z = e.focusedKey != null ? (H = t.getKeyAbove) === null || H === void 0 ? void 0 : H.call(t, e.focusedKey) : (X = t.getLastKey) === null || X === void 0 ? void 0 : X.call(t);
                    z == null && o && (z = (q = t.getLastKey) === null || q === void 0 ? void 0 : q.call(t, e.focusedKey)), z != null && (m.preventDefault(), w(z))
                }
                break;
            case "ArrowLeft":
                if (t.getKeyLeftOf) {
                    var G, ne, te;
                    let z = e.focusedKey != null ? (G = t.getKeyLeftOf) === null || G === void 0 ? void 0 : G.call(t, e.focusedKey) : null;
                    z == null && o && (z = P === "rtl" ? (ne = t.getFirstKey) === null || ne === void 0 ? void 0 : ne.call(t, e.focusedKey) : (te = t.getLastKey) === null || te === void 0 ? void 0 : te.call(t, e.focusedKey)), z != null && (m.preventDefault(), w(z, P === "rtl" ? "first" : "last"))
                }
                break;
            case "ArrowRight":
                if (t.getKeyRightOf) {
                    var se, ue, ie;
                    let z = e.focusedKey != null ? (se = t.getKeyRightOf) === null || se === void 0 ? void 0 : se.call(t, e.focusedKey) : null;
                    z == null && o && (z = P === "rtl" ? (ue = t.getLastKey) === null || ue === void 0 ? void 0 : ue.call(t, e.focusedKey) : (ie = t.getFirstKey) === null || ie === void 0 ? void 0 : ie.call(t, e.focusedKey)), z != null && (m.preventDefault(), w(z, P === "rtl" ? "last" : "first"))
                }
                break;
            case "Home":
                if (t.getFirstKey) {
                    if (e.focusedKey === null && m.shiftKey) return;
                    m.preventDefault();
                    let z = t.getFirstKey(e.focusedKey, wn(m));
                    e.setFocusedKey(z), z != null && (wn(m) && m.shiftKey && e.selectionMode === "multiple" ? e.extendSelection(z) : a && e.replaceSelection(z))
                }
                break;
            case "End":
                if (t.getLastKey) {
                    if (e.focusedKey === null && m.shiftKey) return;
                    m.preventDefault();
                    let z = t.getLastKey(e.focusedKey, wn(m));
                    e.setFocusedKey(z), z != null && (wn(m) && m.shiftKey && e.selectionMode === "multiple" ? e.extendSelection(z) : a && e.replaceSelection(z))
                }
                break;
            case "PageDown":
                if (t.getKeyPageBelow && e.focusedKey != null) {
                    let z = t.getKeyPageBelow(e.focusedKey);
                    z != null && (m.preventDefault(), w(z))
                }
                break;
            case "PageUp":
                if (t.getKeyPageAbove && e.focusedKey != null) {
                    let z = t.getKeyPageAbove(e.focusedKey);
                    z != null && (m.preventDefault(), w(z))
                }
                break;
            case "a":
                wn(m) && e.selectionMode === "multiple" && l !== !0 && (m.preventDefault(), e.selectAll());
                break;
            case "Escape":
                !s && e.selectedKeys.size !== 0 && (m.stopPropagation(), m.preventDefault(), e.clearSelection());
                break;
            case "Tab":
                if (!h) {
                    if (m.shiftKey) r.current.focus();
                    else {
                        let z = Gt(r.current, {
                                tabbable: !0
                            }),
                            oe, Q;
                        do Q = z.lastChild(), Q && (oe = Q); while (Q);
                        oe && !oe.contains(document.activeElement) && Ht(oe)
                    }
                    break
                }
        }
    }, N = c.useRef({
        top: 0,
        left: 0
    });
    pr(g, "scroll", D ? void 0 : () => {
        var m, p, w, C;
        N.current = {
            top: (w = (m = g.current) === null || m === void 0 ? void 0 : m.scrollTop) !== null && w !== void 0 ? w : 0,
            left: (C = (p = g.current) === null || p === void 0 ? void 0 : p.scrollLeft) !== null && C !== void 0 ? C : 0
        }
    });
    let S = m => {
            if (e.isFocused) {
                m.currentTarget.contains(m.target) || e.setFocused(!1);
                return
            }
            if (m.currentTarget.contains(m.target)) {
                if (e.setFocused(!0), e.focusedKey == null) {
                    var p, w;
                    let E = X => {
                            X != null && (e.setFocusedKey(X), a && e.replaceSelection(X))
                        },
                        H = m.relatedTarget;
                    var C, A;
                    H && m.currentTarget.compareDocumentPosition(H) & Node.DOCUMENT_POSITION_FOLLOWING ? E((C = e.lastSelectedKey) !== null && C !== void 0 ? C : (p = t.getLastKey) === null || p === void 0 ? void 0 : p.call(t)) : E((A = e.firstSelectedKey) !== null && A !== void 0 ? A : (w = t.getFirstKey) === null || w === void 0 ? void 0 : w.call(t))
                } else !D && g.current && (g.current.scrollTop = N.current.top, g.current.scrollLeft = N.current.left);
                if (e.focusedKey != null && g.current) {
                    let E = g.current.querySelector(`[data-key="${CSS.escape(e.focusedKey.toString())}"]`);
                    E && (E.contains(document.activeElement) || Ht(E), _r() === "keyboard" && Ao(E, {
                        containingElement: r.current
                    }))
                }
            }
        },
        j = m => {
            m.currentTarget.contains(m.relatedTarget) || e.setFocused(!1)
        },
        k = c.useRef(!1);
    pr(r, Id, d ? m => {
        let {
            detail: p
        } = m;
        m.stopPropagation(), e.setFocused(!0), (p == null ? void 0 : p.focusStrategy) === "first" && (k.current = !0)
    } : void 0);
    let B = it(() => {
        var m, p;
        let w = (p = (m = t.getFirstKey) === null || m === void 0 ? void 0 : m.call(t)) !== null && p !== void 0 ? p : null;
        if (w == null) {
            var C;
            (C = r.current) === null || C === void 0 || C.dispatchEvent(new CustomEvent(Us, {
                cancelable: !0,
                bubbles: !0
            })), e.collection.size > 0 && (k.current = !1)
        } else e.setFocusedKey(w), k.current = !1
    });
    To(() => {
        k.current && B()
    }, [e.collection, B]);
    let M = it(() => {
        e.collection.size > 0 && (k.current = !1)
    });
    To(() => {
        M()
    }, [e.focusedKey, M]), pr(r, Nd, d ? m => {
        m.stopPropagation(), e.setFocused(!1), e.setFocusedKey(null)
    } : void 0);
    const f = c.useRef(i);
    c.useEffect(() => {
        if (f.current) {
            var m, p;
            let A = null;
            var w;
            i === "first" && (A = (w = (m = t.getFirstKey) === null || m === void 0 ? void 0 : m.call(t)) !== null && w !== void 0 ? w : null);
            var C;
            i === "last" && (A = (C = (p = t.getLastKey) === null || p === void 0 ? void 0 : p.call(t)) !== null && C !== void 0 ? C : null);
            let E = e.selectedKeys;
            if (E.size) {
                for (let H of E)
                    if (e.canSelectItem(H)) {
                        A = H;
                        break
                    }
            }
            e.setFocused(!0), e.setFocusedKey(A), A == null && !d && r.current && Jn(r.current)
        }
    }, []);
    let I = c.useRef(e.focusedKey);
    c.useEffect(() => {
        if (e.isFocused && e.focusedKey != null && (e.focusedKey !== I.current || f.current) && g.current && r.current) {
            let m = _r(),
                p = r.current.querySelector(`[data-key="${CSS.escape(e.focusedKey.toString())}"]`);
            if (!p) return;
            (m === "keyboard" || f.current) && (Hs(g.current, p), m !== "virtual" && Ao(p, {
                containingElement: r.current
            }))
        }!d && e.isFocused && e.focusedKey == null && I.current != null && r.current && Jn(r.current), I.current = e.focusedKey, f.current = !1
    }), pr(r, "react-aria-focus-scope-restore", m => {
        m.preventDefault(), e.setFocused(!0)
    });
    let O = {
            onKeyDown: R,
            onFocus: S,
            onBlur: j,
            onMouseDown(m) {
                g.current === m.target && m.preventDefault()
            }
        },
        {
            typeSelectProps: T
        } = na({
            keyboardDelegate: t,
            selectionManager: e
        });
    u || (O = Oe(T, O));
    let K;
    return d ? K = -1 : K = e.focusedKey == null ? 0 : -1, {
        collectionProps: { ...O,
            tabIndex: K
        }
    }
}

function Op(n) {
    let {
        id: e,
        selectionManager: t,
        key: r,
        ref: i,
        shouldSelectOnPressUp: o,
        shouldUseVirtualFocus: s,
        focus: l,
        isDisabled: a,
        onAction: u,
        allowsDifferentPressOrigin: d,
        linkBehavior: h = "action"
    } = n, D = Hi();
    e = Ct(e);
    let g = E => {
        if (E.pointerType === "keyboard" && Mi(E)) t.toggleSelection(r);
        else {
            if (t.selectionMode === "none") return;
            if (t.isLink(r)) {
                if (h === "selection" && i.current) {
                    let H = t.getItemProps(r);
                    D.open(i.current, E, H.href, H.routerOptions), t.setSelectedKeys(t.selectedKeys);
                    return
                } else if (h === "override" || h === "none") return
            }
            t.selectionMode === "single" ? t.isSelected(r) && !t.disallowEmptySelection ? t.toggleSelection(r) : t.replaceSelection(r) : E && E.shiftKey ? t.extendSelection(r) : t.selectionBehavior === "toggle" || E && (wn(E) || E.pointerType === "touch" || E.pointerType === "virtual") ? t.toggleSelection(r) : t.replaceSelection(r)
        }
    };
    c.useEffect(() => {
        if (r === t.focusedKey && t.isFocused)
            if (!s) l ? l() : document.activeElement !== i.current && i.current && Jn(i.current);
            else {
                var H;
                let X = new CustomEvent(Us, {
                    cancelable: !0,
                    bubbles: !0
                });
                (H = i.current) === null || H === void 0 || H.dispatchEvent(X)
            }
    }, [i, r, t.focusedKey, t.childFocusStrategy, t.isFocused, s]), a = a || t.isDisabled(r);
    let x = {};
    !s && !a ? x = {
        tabIndex: r === t.focusedKey ? 0 : -1,
        onFocus(E) {
            E.target === i.current && t.setFocusedKey(r)
        }
    } : a && (x.onMouseDown = E => {
        E.preventDefault()
    });
    let P = t.isLink(r) && h === "override",
        L = t.isLink(r) && h !== "selection" && h !== "none",
        R = !a && t.canSelectItem(r) && !P,
        N = (u || L) && !a,
        S = N && (t.selectionBehavior === "replace" ? !R : !R || t.isEmpty),
        j = N && R && t.selectionBehavior === "replace",
        k = S || j,
        B = c.useRef(null),
        M = k && R,
        f = c.useRef(!1),
        I = c.useRef(!1),
        O = E => {
            if (u && u(), L && i.current) {
                let H = t.getItemProps(r);
                D.open(i.current, E, H.href, H.routerOptions)
            }
        },
        T = {};
    o ? (T.onPressStart = E => {
        B.current = E.pointerType, f.current = M, E.pointerType === "keyboard" && (!k || as()) && g(E)
    }, d ? (T.onPressUp = S ? void 0 : E => {
        E.pointerType === "mouse" && R && g(E)
    }, T.onPress = S ? O : E => {
        E.pointerType !== "keyboard" && E.pointerType !== "mouse" && R && g(E)
    }) : T.onPress = E => {
        if (S || j && E.pointerType !== "mouse") {
            if (E.pointerType === "keyboard" && !ls()) return;
            O(E)
        } else E.pointerType !== "keyboard" && R && g(E)
    }) : (T.onPressStart = E => {
        B.current = E.pointerType, f.current = M, I.current = S, R && (E.pointerType === "mouse" && !S || E.pointerType === "keyboard" && (!N || as())) && g(E)
    }, T.onPress = E => {
        (E.pointerType === "touch" || E.pointerType === "pen" || E.pointerType === "virtual" || E.pointerType === "keyboard" && k && ls() || E.pointerType === "mouse" && I.current) && (k ? O(E) : R && g(E))
    }), x["data-key"] = r, T.preventFocusOnPress = s;
    let {
        pressProps: K,
        isPressed: m
    } = Ji(T), p = j ? E => {
        B.current === "mouse" && (E.stopPropagation(), E.preventDefault(), O(E))
    } : void 0, {
        longPressProps: w
    } = ul({
        isDisabled: !M,
        onLongPress(E) {
            E.pointerType === "touch" && (g(E), t.setSelectionBehavior("toggle"))
        }
    }), C = E => {
        B.current === "touch" && f.current && E.preventDefault()
    }, A = t.isLink(r) ? E => {
        Dn.isOpening || E.preventDefault()
    } : void 0;
    return {
        itemProps: Oe(x, R || S ? K : {}, M ? w : {}, {
            onDoubleClick: p,
            onDragStartCapture: C,
            onClick: A,
            id: e
        }),
        isPressed: m,
        isSelected: t.isSelected(r),
        isFocused: t.isFocused && t.focusedKey === r,
        isDisabled: a,
        allowsSelection: R,
        hasAction: k
    }
}

function ls() {
    let n = window.event;
    return (n == null ? void 0 : n.key) === "Enter"
}

function as() {
    let n = window.event;
    return (n == null ? void 0 : n.key) === " " || (n == null ? void 0 : n.code) === "Space"
}
class us {
    getItemRect(e) {
        let t = this.ref.current;
        if (!t) return null;
        let r = e != null ? t.querySelector(`[data-key="${CSS.escape(e.toString())}"]`) : null;
        if (!r) return null;
        let i = t.getBoundingClientRect(),
            o = r.getBoundingClientRect();
        return {
            x: o.left - i.left + t.scrollLeft,
            y: o.top - i.top + t.scrollTop,
            width: o.width,
            height: o.height
        }
    }
    getContentSize() {
        let e = this.ref.current;
        var t, r;
        return {
            width: (t = e == null ? void 0 : e.scrollWidth) !== null && t !== void 0 ? t : 0,
            height: (r = e == null ? void 0 : e.scrollHeight) !== null && r !== void 0 ? r : 0
        }
    }
    getVisibleRect() {
        let e = this.ref.current;
        var t, r, i, o;
        return {
            x: (t = e == null ? void 0 : e.scrollLeft) !== null && t !== void 0 ? t : 0,
            y: (r = e == null ? void 0 : e.scrollTop) !== null && r !== void 0 ? r : 0,
            width: (i = e == null ? void 0 : e.offsetWidth) !== null && i !== void 0 ? i : 0,
            height: (o = e == null ? void 0 : e.offsetHeight) !== null && o !== void 0 ? o : 0
        }
    }
    constructor(e) {
        this.ref = e
    }
}
class ao {
    isDisabled(e) {
        var t;
        return this.disabledBehavior === "all" && (((t = e.props) === null || t === void 0 ? void 0 : t.isDisabled) || this.disabledKeys.has(e.key))
    }
    findNextNonDisabled(e, t) {
        let r = e;
        for (; r != null;) {
            let i = this.collection.getItem(r);
            if ((i == null ? void 0 : i.type) === "item" && !this.isDisabled(i)) return r;
            r = t(r)
        }
        return null
    }
    getNextKey(e) {
        let t = e;
        return t = this.collection.getKeyAfter(t), this.findNextNonDisabled(t, r => this.collection.getKeyAfter(r))
    }
    getPreviousKey(e) {
        let t = e;
        return t = this.collection.getKeyBefore(t), this.findNextNonDisabled(t, r => this.collection.getKeyBefore(r))
    }
    findKey(e, t, r) {
        let i = e,
            o = this.layoutDelegate.getItemRect(i);
        if (!o || i == null) return null;
        let s = o;
        do {
            if (i = t(i), i == null) break;
            o = this.layoutDelegate.getItemRect(i)
        } while (o && r(s, o) && i != null);
        return i
    }
    isSameRow(e, t) {
        return e.y === t.y || e.x !== t.x
    }
    isSameColumn(e, t) {
        return e.x === t.x || e.y !== t.y
    }
    getKeyBelow(e) {
        return this.layout === "grid" && this.orientation === "vertical" ? this.findKey(e, t => this.getNextKey(t), this.isSameRow) : this.getNextKey(e)
    }
    getKeyAbove(e) {
        return this.layout === "grid" && this.orientation === "vertical" ? this.findKey(e, t => this.getPreviousKey(t), this.isSameRow) : this.getPreviousKey(e)
    }
    getNextColumn(e, t) {
        return t ? this.getPreviousKey(e) : this.getNextKey(e)
    }
    getKeyRightOf(e) {
        let t = this.direction === "ltr" ? "getKeyRightOf" : "getKeyLeftOf";
        return this.layoutDelegate[t] ? (e = this.layoutDelegate[t](e), this.findNextNonDisabled(e, r => this.layoutDelegate[t](r))) : this.layout === "grid" ? this.orientation === "vertical" ? this.getNextColumn(e, this.direction === "rtl") : this.findKey(e, r => this.getNextColumn(r, this.direction === "rtl"), this.isSameColumn) : this.orientation === "horizontal" ? this.getNextColumn(e, this.direction === "rtl") : null
    }
    getKeyLeftOf(e) {
        let t = this.direction === "ltr" ? "getKeyLeftOf" : "getKeyRightOf";
        return this.layoutDelegate[t] ? (e = this.layoutDelegate[t](e), this.findNextNonDisabled(e, r => this.layoutDelegate[t](r))) : this.layout === "grid" ? this.orientation === "vertical" ? this.getNextColumn(e, this.direction === "ltr") : this.findKey(e, r => this.getNextColumn(r, this.direction === "ltr"), this.isSameColumn) : this.orientation === "horizontal" ? this.getNextColumn(e, this.direction === "ltr") : null
    }
    getFirstKey() {
        let e = this.collection.getFirstKey();
        return this.findNextNonDisabled(e, t => this.collection.getKeyAfter(t))
    }
    getLastKey() {
        let e = this.collection.getLastKey();
        return this.findNextNonDisabled(e, t => this.collection.getKeyBefore(t))
    }
    getKeyPageAbove(e) {
        let t = this.ref.current,
            r = this.layoutDelegate.getItemRect(e);
        if (!r) return null;
        if (t && !qn(t)) return this.getFirstKey();
        let i = e;
        if (this.orientation === "horizontal") {
            let o = Math.max(0, r.x + r.width - this.layoutDelegate.getVisibleRect().width);
            for (; r && r.x > o && i != null;) i = this.getKeyAbove(i), r = i == null ? null : this.layoutDelegate.getItemRect(i)
        } else {
            let o = Math.max(0, r.y + r.height - this.layoutDelegate.getVisibleRect().height);
            for (; r && r.y > o && i != null;) i = this.getKeyAbove(i), r = i == null ? null : this.layoutDelegate.getItemRect(i)
        }
        return i ? ? this.getFirstKey()
    }
    getKeyPageBelow(e) {
        let t = this.ref.current,
            r = this.layoutDelegate.getItemRect(e);
        if (!r) return null;
        if (t && !qn(t)) return this.getLastKey();
        let i = e;
        if (this.orientation === "horizontal") {
            let o = Math.min(this.layoutDelegate.getContentSize().width, r.y - r.width + this.layoutDelegate.getVisibleRect().width);
            for (; r && r.x < o && i != null;) i = this.getKeyBelow(i), r = i == null ? null : this.layoutDelegate.getItemRect(i)
        } else {
            let o = Math.min(this.layoutDelegate.getContentSize().height, r.y - r.height + this.layoutDelegate.getVisibleRect().height);
            for (; r && r.y < o && i != null;) i = this.getKeyBelow(i), r = i == null ? null : this.layoutDelegate.getItemRect(i)
        }
        return i ? ? this.getLastKey()
    }
    getKeyForSearch(e, t) {
        if (!this.collator) return null;
        let r = this.collection,
            i = t || this.getFirstKey();
        for (; i != null;) {
            let o = r.getItem(i);
            if (!o) return null;
            let s = o.textValue.slice(0, e.length);
            if (o.textValue && this.collator.compare(s, e) === 0) return i;
            i = this.getNextKey(i)
        }
        return null
    }
    constructor(...e) {
        if (e.length === 1) {
            let t = e[0];
            this.collection = t.collection, this.ref = t.ref, this.collator = t.collator, this.disabledKeys = t.disabledKeys || new Set, this.disabledBehavior = t.disabledBehavior || "all", this.orientation = t.orientation || "vertical", this.direction = t.direction, this.layout = t.layout || "stack", this.layoutDelegate = t.layoutDelegate || new us(t.ref)
        } else this.collection = e[0], this.disabledKeys = e[1], this.ref = e[2], this.collator = e[3], this.layout = "stack", this.orientation = "vertical", this.disabledBehavior = "all", this.layoutDelegate = new us(this.ref);
        this.layout === "stack" && this.orientation === "vertical" && (this.getKeyLeftOf = void 0, this.getKeyRightOf = void 0)
    }
}

function jp(n) {
    let {
        selectionManager: e,
        collection: t,
        disabledKeys: r,
        ref: i,
        keyboardDelegate: o,
        layoutDelegate: s
    } = n, l = so({
        usage: "search",
        sensitivity: "base"
    }), a = e.disabledBehavior, u = c.useMemo(() => o || new ao({
        collection: t,
        disabledKeys: r,
        disabledBehavior: a,
        ref: i,
        collator: l,
        layoutDelegate: s
    }), [o, s, t, r, i, l, a]), {
        collectionProps: d
    } = Kp({ ...n,
        ref: i,
        selectionManager: e,
        keyboardDelegate: u
    });
    return {
        listProps: d
    }
}

function zp(n, e, t) {
    let r = Nt(n, {
            labelable: !0
        }),
        i = n.selectionBehavior || "toggle",
        o = n.linkBehavior || (i === "replace" ? "action" : "override");
    i === "toggle" && o === "action" && (o = "override");
    let {
        listProps: s
    } = jp({ ...n,
        ref: t,
        selectionManager: e.selectionManager,
        collection: e.collection,
        disabledKeys: e.disabledKeys,
        linkBehavior: o
    }), {
        focusWithinProps: l
    } = Kr({
        onFocusWithin: n.onFocus,
        onBlurWithin: n.onBlur,
        onFocusWithinChange: n.onFocusChange
    }), a = Ct(n.id);
    lo.set(e, {
        id: a,
        shouldUseVirtualFocus: n.shouldUseVirtualFocus,
        shouldSelectOnPressUp: n.shouldSelectOnPressUp,
        shouldFocusOnHover: n.shouldFocusOnHover,
        isVirtualized: n.isVirtualized,
        onAction: n.onAction,
        linkBehavior: o
    });
    let {
        labelProps: u,
        fieldProps: d
    } = gl({ ...n,
        id: a,
        labelElementType: "span"
    });
    return {
        labelProps: u,
        listBoxProps: Oe(r, l, e.selectionManager.selectionMode === "multiple" ? {
            "aria-multiselectable": "true"
        } : {}, {
            role: "listbox",
            ...Oe(d, s)
        })
    }
}
class Vp {
    build(e, t) {
        return this.context = t, cs(() => this.iterateCollection(e))
    }* iterateCollection(e) {
        let {
            children: t,
            items: r
        } = e;
        if (W.isValidElement(t) && t.type === W.Fragment) yield* this.iterateCollection({
            children: t.props.children,
            items: r
        });
        else if (typeof t == "function") {
            if (!r) throw new Error("props.children was a function but props.items is missing");
            let i = 0;
            for (let o of r) yield* this.getFullNode({
                value: o,
                index: i
            }, {
                renderer: t
            }), i++
        } else {
            let i = [];
            W.Children.forEach(t, s => {
                s && i.push(s)
            });
            let o = 0;
            for (let s of i) {
                let l = this.getFullNode({
                    element: s,
                    index: o
                }, {});
                for (let a of l) o++, yield a
            }
        }
    }
    getKey(e, t, r, i) {
        if (e.key != null) return e.key;
        if (t.type === "cell" && t.key != null) return `${i}${t.key}`;
        let o = t.value;
        if (o != null) {
            var s;
            let l = (s = o.key) !== null && s !== void 0 ? s : o.id;
            if (l == null) throw new Error("No key found for item");
            return l
        }
        return i ? `${i}.${t.index}` : `$.${t.index}`
    }
    getChildState(e, t) {
        return {
            renderer: t.renderer || e.renderer
        }
    }* getFullNode(e, t, r, i) {
        if (W.isValidElement(e.element) && e.element.type === W.Fragment) {
            let L = [];
            W.Children.forEach(e.element.props.children, N => {
                L.push(N)
            });
            var o;
            let R = (o = e.index) !== null && o !== void 0 ? o : 0;
            for (const N of L) yield* this.getFullNode({
                element: N,
                index: R++
            }, t, r, i);
            return
        }
        let s = e.element;
        if (!s && e.value && t && t.renderer) {
            let L = this.cache.get(e.value);
            if (L && (!L.shouldInvalidate || !L.shouldInvalidate(this.context))) {
                L.index = e.index, L.parentKey = i ? i.key : null, yield L;
                return
            }
            s = t.renderer(e.value)
        }
        if (W.isValidElement(s)) {
            let L = s.type;
            if (typeof L != "function" && typeof L.getCollectionNode != "function") {
                let j = s.type;
                throw new Error(`Unknown element <${j}> in collection.`)
            }
            let R = L.getCollectionNode(s.props, this.context);
            var l;
            let N = (l = e.index) !== null && l !== void 0 ? l : 0,
                S = R.next();
            for (; !S.done && S.value;) {
                let j = S.value;
                e.index = N;
                var a;
                let k = (a = j.key) !== null && a !== void 0 ? a : null;
                k == null && (k = j.element ? null : this.getKey(s, e, t, r));
                let M = [...this.getFullNode({ ...j,
                    key: k,
                    index: N,
                    wrapper: Wp(e.wrapper, j.wrapper)
                }, this.getChildState(t, j), r ? `${r}${s.key}` : s.key, i)];
                for (let f of M) {
                    var u, d;
                    f.value = (d = (u = j.value) !== null && u !== void 0 ? u : e.value) !== null && d !== void 0 ? d : null, f.value && this.cache.set(f.value, f);
                    var h;
                    if (e.type && f.type !== e.type) throw new Error(`Unsupported type <${ci(f.type)}> in <${ci((h=i==null?void 0:i.type)!==null&&h!==void 0?h:"unknown parent type")}>. Only <${ci(e.type)}> is supported.`);
                    N++, yield f
                }
                S = R.next(M)
            }
            return
        }
        if (e.key == null || e.type == null) return;
        let D = this;
        var g, x;
        let P = {
            type: e.type,
            props: e.props,
            key: e.key,
            parentKey: i ? i.key : null,
            value: (g = e.value) !== null && g !== void 0 ? g : null,
            level: i ? i.level + 1 : 0,
            index: e.index,
            rendered: e.rendered,
            textValue: (x = e.textValue) !== null && x !== void 0 ? x : "",
            "aria-label": e["aria-label"],
            wrapper: e.wrapper,
            shouldInvalidate: e.shouldInvalidate,
            hasChildNodes: e.hasChildNodes || !1,
            childNodes: cs(function*() {
                if (!e.hasChildNodes || !e.childNodes) return;
                let L = 0;
                for (let R of e.childNodes()) {
                    R.key != null && (R.key = `${P.key}${R.key}`);
                    let N = D.getFullNode({ ...R,
                        index: L
                    }, D.getChildState(t, R), P.key, P);
                    for (let S of N) L++, yield S
                }
            })
        };
        yield P
    }
    constructor() {
        this.cache = new WeakMap
    }
}

function cs(n) {
    let e = [],
        t = null;
    return {*[Symbol.iterator]() {
            for (let r of e) yield r;
            t || (t = n());
            for (let r of t) e.push(r), yield r
        }
    }
}

function Wp(n, e) {
    if (n && e) return t => n(e(t));
    if (n) return n;
    if (e) return e
}

function ci(n) {
    return n[0].toUpperCase() + n.slice(1)
}

function Hp(n, e, t) {
    let r = c.useMemo(() => new Vp, []),
        {
            children: i,
            items: o,
            collection: s
        } = n;
    return c.useMemo(() => {
        if (s) return s;
        let a = r.build({
            children: i,
            items: o
        }, t);
        return e(a)
    }, [r, i, o, s, t, e])
}

function ra(n, e) {
    return typeof e.getChildren == "function" ? e.getChildren(n.key) : n.childNodes
}

function Up(n) {
    return Gp(n)
}

function Gp(n, e) {
    for (let t of n) return t
}

function di(n, e, t) {
    if (e.parentKey === t.parentKey) return e.index - t.index;
    let r = [...ds(n, e), e],
        i = [...ds(n, t), t],
        o = r.slice(0, i.length).findIndex((s, l) => s !== i[l]);
    return o !== -1 ? (e = r[o], t = i[o], e.index - t.index) : r.findIndex(s => s === t) >= 0 ? 1 : (i.findIndex(s => s === e) >= 0, -1)
}

function ds(n, e) {
    let t = [],
        r = e;
    for (;
        (r == null ? void 0 : r.parentKey) != null;) r = n.getItem(r.parentKey), r && t.unshift(r);
    return t
}
const fs = new WeakMap;

function Xp(n) {
    let e = fs.get(n);
    if (e != null) return e;
    let t = 0,
        r = i => {
            for (let o of i) o.type === "section" ? r(ra(o, n)) : t++
        };
    return r(n), fs.set(n, t), t
}

function qp(n, e, t) {
    var r, i;
    let {
        key: o
    } = n, s = lo.get(e);
    var l;
    let a = (l = n.isDisabled) !== null && l !== void 0 ? l : e.selectionManager.isDisabled(o);
    var u;
    let d = (u = n.isSelected) !== null && u !== void 0 ? u : e.selectionManager.isSelected(o);
    var h;
    let D = (h = n.shouldSelectOnPressUp) !== null && h !== void 0 ? h : s == null ? void 0 : s.shouldSelectOnPressUp;
    var g;
    let x = (g = n.shouldFocusOnHover) !== null && g !== void 0 ? g : s == null ? void 0 : s.shouldFocusOnHover;
    var P;
    let L = (P = n.shouldUseVirtualFocus) !== null && P !== void 0 ? P : s == null ? void 0 : s.shouldUseVirtualFocus;
    var R;
    let N = (R = n.isVirtualized) !== null && R !== void 0 ? R : s == null ? void 0 : s.isVirtualized,
        S = $r(),
        j = $r(),
        k = {
            role: "option",
            "aria-disabled": a || void 0,
            "aria-selected": e.selectionManager.selectionMode !== "none" ? d : void 0
        };
    rn() && Vi() || (k["aria-label"] = n["aria-label"], k["aria-labelledby"] = S, k["aria-describedby"] = j);
    let B = e.collection.getItem(o);
    if (N) {
        let A = Number(B == null ? void 0 : B.index);
        k["aria-posinset"] = Number.isNaN(A) ? void 0 : A + 1, k["aria-setsize"] = Xp(e.collection)
    }
    let M = s != null && s.onAction ? () => {
            var A;
            return s == null || (A = s.onAction) === null || A === void 0 ? void 0 : A.call(s, o)
        } : void 0,
        f = Mp(e, o),
        {
            itemProps: I,
            isPressed: O,
            isFocused: T,
            hasAction: K,
            allowsSelection: m
        } = Op({
            selectionManager: e.selectionManager,
            key: o,
            ref: t,
            shouldSelectOnPressUp: D,
            allowsDifferentPressOrigin: D && x,
            isVirtualized: N,
            shouldUseVirtualFocus: L,
            isDisabled: a,
            onAction: M || !(B == null || (r = B.props) === null || r === void 0) && r.onAction ? hn(B == null || (i = B.props) === null || i === void 0 ? void 0 : i.onAction, M) : void 0,
            linkBehavior: s == null ? void 0 : s.linkBehavior,
            id: f
        }),
        {
            hoverProps: p
        } = eo({
            isDisabled: a || !x,
            onHoverStart() {
                Sr() || (e.selectionManager.setFocused(!0), e.selectionManager.setFocusedKey(o))
            }
        }),
        w = Nt(B == null ? void 0 : B.props);
    delete w.id;
    let C = Td(B == null ? void 0 : B.props);
    return {
        optionProps: { ...k,
            ...Oe(w, I, p, C),
            id: f
        },
        labelProps: {
            id: S
        },
        descriptionProps: {
            id: j
        },
        isFocused: T,
        isFocusVisible: T && Sr(),
        isSelected: d,
        isDisabled: a,
        isPressed: O,
        allowsSelection: m,
        hasAction: K
    }
}

function Yp(n) {
    let {
        heading: e,
        "aria-label": t
    } = n, r = Ct();
    return {
        itemProps: {
            role: "presentation"
        },
        headingProps: e ? {
            id: r,
            role: "presentation"
        } : {},
        groupProps: {
            role: "group",
            "aria-label": t,
            "aria-labelledby": e ? r : void 0
        }
    }
}
var ia = {};
ia = {
    longPressMessage: "اضغط مطولاً أو اضغط على Alt + السهم لأسفل لفتح القائمة"
};
var oa = {};
oa = {
    longPressMessage: "Натиснете продължително или натиснете Alt+ стрелка надолу, за да отворите менюто"
};
var sa = {};
sa = {
    longPressMessage: "Dlouhým stiskem nebo stisknutím kláves Alt + šipka dolů otevřete nabídku"
};
var la = {};
la = {
    longPressMessage: "Langt tryk eller tryk på Alt + pil ned for at åbne menuen"
};
var aa = {};
aa = {
    longPressMessage: "Drücken Sie lange oder drücken Sie Alt + Nach-unten, um das Menü zu öffnen"
};
var ua = {};
ua = {
    longPressMessage: "Πιέστε παρατεταμένα ή πατήστε Alt + κάτω βέλος για να ανοίξετε το μενού"
};
var ca = {};
ca = {
    longPressMessage: "Long press or press Alt + ArrowDown to open menu"
};
var da = {};
da = {
    longPressMessage: "Mantenga pulsado o pulse Alt + flecha abajo para abrir el menú"
};
var fa = {};
fa = {
    longPressMessage: "Menüü avamiseks vajutage pikalt või vajutage klahve Alt + allanool"
};
var pa = {};
pa = {
    longPressMessage: "Avaa valikko painamalla pohjassa tai näppäinyhdistelmällä Alt + Alanuoli"
};
var ha = {};
ha = {
    longPressMessage: "Appuyez de manière prolongée ou appuyez sur Alt + Flèche vers le bas pour ouvrir le menu."
};
var Da = {};
Da = {
    longPressMessage: "לחץ לחיצה ארוכה או הקש Alt + ArrowDown כדי לפתוח את התפריט"
};
var va = {};
va = {
    longPressMessage: "Dugo pritisnite ili pritisnite Alt + strelicu prema dolje za otvaranje izbornika"
};
var ga = {};
ga = {
    longPressMessage: "Nyomja meg hosszan, vagy nyomja meg az Alt + lefele nyíl gombot a menü megnyitásához"
};
var ma = {};
ma = {
    longPressMessage: "Premere a lungo o premere Alt + Freccia giù per aprire il menu"
};
var ba = {};
ba = {
    longPressMessage: "長押しまたは Alt+下矢印キーでメニューを開く"
};
var ya = {};
ya = {
    longPressMessage: "길게 누르거나 Alt + 아래쪽 화살표를 눌러 메뉴 열기"
};
var Ea = {};
Ea = {
    longPressMessage: "Norėdami atidaryti meniu, nuspaudę palaikykite arba paspauskite „Alt + ArrowDown“."
};
var Ca = {};
Ca = {
    longPressMessage: "Lai atvērtu izvēlni, turiet nospiestu vai nospiediet taustiņu kombināciju Alt + lejupvērstā bultiņa"
};
var xa = {};
xa = {
    longPressMessage: "Langt trykk eller trykk Alt + PilNed for å åpne menyen"
};
var $a = {};
$a = {
    longPressMessage: "Druk lang op Alt + pijl-omlaag of druk op Alt om het menu te openen"
};
var wa = {};
wa = {
    longPressMessage: "Naciśnij i przytrzymaj lub naciśnij klawisze Alt + Strzałka w dół, aby otworzyć menu"
};
var Fa = {};
Fa = {
    longPressMessage: "Pressione e segure ou pressione Alt + Seta para baixo para abrir o menu"
};
var Sa = {};
Sa = {
    longPressMessage: "Prima continuamente ou prima Alt + Seta Para Baixo para abrir o menu"
};
var _a = {};
_a = {
    longPressMessage: "Apăsați lung sau apăsați pe Alt + săgeată în jos pentru a deschide meniul"
};
var Pa = {};
Pa = {
    longPressMessage: "Нажмите и удерживайте или нажмите Alt + Стрелка вниз, чтобы открыть меню"
};
var Ta = {};
Ta = {
    longPressMessage: "Ponuku otvoríte dlhým stlačením alebo stlačením klávesu Alt + klávesu so šípkou nadol"
};
var ka = {};
ka = {
    longPressMessage: "Za odprtje menija pritisnite in držite gumb ali pritisnite Alt+puščica navzdol"
};
var Aa = {};
Aa = {
    longPressMessage: "Dugo pritisnite ili pritisnite Alt + strelicu prema dole da otvorite meni"
};
var La = {};
La = {
    longPressMessage: "Håll nedtryckt eller tryck på Alt + pil nedåt för att öppna menyn"
};
var Ba = {};
Ba = {
    longPressMessage: "Menüyü açmak için uzun basın veya Alt + Aşağı Ok tuşuna basın"
};
var Ra = {};
Ra = {
    longPressMessage: "Довго або звичайно натисніть комбінацію клавіш Alt і стрілка вниз, щоб відкрити меню"
};
var Ma = {};
Ma = {
    longPressMessage: "长按或按 Alt + 向下方向键以打开菜单"
};
var Na = {};
Na = {
    longPressMessage: "長按或按 Alt+向下鍵以開啟功能表"
};
var Ia = {};
Ia = {
    "ar-AE": ia,
    "bg-BG": oa,
    "cs-CZ": sa,
    "da-DK": la,
    "de-DE": aa,
    "el-GR": ua,
    "en-US": ca,
    "es-ES": da,
    "et-EE": fa,
    "fi-FI": pa,
    "fr-FR": ha,
    "he-IL": Da,
    "hr-HR": va,
    "hu-HU": ga,
    "it-IT": ma,
    "ja-JP": ba,
    "ko-KR": ya,
    "lt-LT": Ea,
    "lv-LV": Ca,
    "nb-NO": xa,
    "nl-NL": $a,
    "pl-PL": wa,
    "pt-BR": Fa,
    "pt-PT": Sa,
    "ro-RO": _a,
    "ru-RU": Pa,
    "sk-SK": Ta,
    "sl-SI": ka,
    "sr-SP": Aa,
    "sv-SE": La,
    "tr-TR": Ba,
    "uk-UA": Ra,
    "zh-CN": Ma,
    "zh-TW": Na
};

function Zp(n) {
    return n && n.__esModule ? n.default : n
}

function Jp(n, e, t) {
    let {
        type: r = "menu",
        isDisabled: i,
        trigger: o = "press"
    } = n, s = Ct(), {
        triggerProps: l,
        overlayProps: a
    } = Cp({
        type: r
    }, e, t), u = g => {
        if (!i && !(o === "longPress" && !g.altKey) && t && t.current) switch (g.key) {
            case "Enter":
            case " ":
                if (o === "longPress") return;
            case "ArrowDown":
                "continuePropagation" in g || g.stopPropagation(), g.preventDefault(), e.toggle("first");
                break;
            case "ArrowUp":
                "continuePropagation" in g || g.stopPropagation(), g.preventDefault(), e.toggle("last");
                break;
            default:
                "continuePropagation" in g && g.continuePropagation()
        }
    }, d = oo(Zp(Ia), "@react-aria/menu"), {
        longPressProps: h
    } = ul({
        isDisabled: i || o !== "longPress",
        accessibilityDescription: d.format("longPressMessage"),
        onLongPressStart() {
            e.close()
        },
        onLongPress() {
            e.open("first")
        }
    }), D = {
        onPressStart(g) {
            g.pointerType !== "touch" && g.pointerType !== "keyboard" && !i && e.open(g.pointerType === "virtual" ? "first" : null)
        },
        onPress(g) {
            g.pointerType === "touch" && !i && e.toggle()
        }
    };
    return delete l.onPress, {
        menuTriggerProps: { ...l,
            ...o === "press" ? D : h,
            id: s,
            onKeyDown: u
        },
        menuProps: { ...a,
            "aria-labelledby": s,
            autoFocus: e.focusStrategy || !0,
            onClose: e.close
        }
    }
}
const Ka = new WeakMap;

function Qp(n, e, t) {
    let {
        keyboardDelegate: r,
        isDisabled: i,
        isRequired: o,
        name: s,
        validationBehavior: l = "aria"
    } = n, a = so({
        usage: "search",
        sensitivity: "base"
    }), u = c.useMemo(() => r || new ao(e.collection, e.disabledKeys, t, a), [r, e.collection, e.disabledKeys, a]), {
        menuTriggerProps: d,
        menuProps: h
    } = Jp({
        isDisabled: i,
        type: "listbox"
    }, e, t), D = f => {
        switch (f.key) {
            case "ArrowLeft":
                {
                    var I, O;f.preventDefault();
                    let m = e.selectedKey != null ? (I = u.getKeyAbove) === null || I === void 0 ? void 0 : I.call(u, e.selectedKey) : (O = u.getFirstKey) === null || O === void 0 ? void 0 : O.call(u);m && e.setSelectedKey(m);
                    break
                }
            case "ArrowRight":
                {
                    var T, K;f.preventDefault();
                    let m = e.selectedKey != null ? (T = u.getKeyBelow) === null || T === void 0 ? void 0 : T.call(u, e.selectedKey) : (K = u.getFirstKey) === null || K === void 0 ? void 0 : K.call(u);m && e.setSelectedKey(m);
                    break
                }
        }
    }, {
        typeSelectProps: g
    } = na({
        keyboardDelegate: u,
        selectionManager: e.selectionManager,
        onTypeSelect(f) {
            e.setSelectedKey(f)
        }
    }), {
        isInvalid: x,
        validationErrors: P,
        validationDetails: L
    } = e.displayValidation, {
        labelProps: R,
        fieldProps: N,
        descriptionProps: S,
        errorMessageProps: j
    } = ap({ ...n,
        labelElementType: "span",
        isInvalid: x,
        errorMessage: n.errorMessage || P
    });
    g.onKeyDown = g.onKeyDownCapture, delete g.onKeyDownCapture;
    let k = Nt(n, {
            labelable: !0
        }),
        B = Oe(g, d, N),
        M = Ct();
    return Ka.set(e, {
        isDisabled: i,
        isRequired: o,
        name: s,
        validationBehavior: l
    }), {
        labelProps: { ...R,
            onClick: () => {
                if (!n.isDisabled) {
                    var f;
                    (f = t.current) === null || f === void 0 || f.focus(), al("keyboard")
                }
            }
        },
        triggerProps: Oe(k, { ...B,
            isDisabled: i,
            onKeyDown: hn(B.onKeyDown, D, n.onKeyDown),
            onKeyUp: n.onKeyUp,
            "aria-labelledby": [M, B["aria-labelledby"], B["aria-label"] && !B["aria-labelledby"] ? B.id : null].filter(Boolean).join(" "),
            onFocus(f) {
                e.isFocused || (n.onFocus && n.onFocus(f), n.onFocusChange && n.onFocusChange(!0), e.setFocused(!0))
            },
            onBlur(f) {
                e.isOpen || (n.onBlur && n.onBlur(f), n.onFocusChange && n.onFocusChange(!1), e.setFocused(!1))
            }
        }),
        valueProps: {
            id: M
        },
        menuProps: { ...h,
            autoFocus: e.focusStrategy || !0,
            shouldSelectOnPressUp: !0,
            shouldFocusOnHover: !0,
            disallowEmptySelection: !0,
            linkBehavior: "selection",
            onBlur: f => {
                f.currentTarget.contains(f.relatedTarget) || (n.onBlur && n.onBlur(f), n.onFocusChange && n.onFocusChange(!1), e.setFocused(!1))
            },
            "aria-labelledby": [N["aria-labelledby"], B["aria-label"] && !N["aria-labelledby"] ? B.id : null].filter(Boolean).join(" ")
        },
        descriptionProps: S,
        errorMessageProps: j,
        isInvalid: x,
        validationErrors: P,
        validationDetails: L
    }
}

function eh(n, e, t) {
    let r = Ka.get(e) || {},
        {
            autoComplete: i,
            name: o = r.name,
            isDisabled: s = r.isDisabled
        } = n,
        {
            validationBehavior: l,
            isRequired: a
        } = r,
        {
            visuallyHiddenProps: u
        } = ml();
    Md(n.selectRef, e.selectedKey, e.setSelectedKey), ip({
        validationBehavior: l,
        focus: () => {
            var h;
            return (h = t.current) === null || h === void 0 ? void 0 : h.focus()
        }
    }, e, n.selectRef);
    var d;
    return {
        containerProps: { ...u,
            "aria-hidden": !0,
            "data-react-aria-prevent-focus": !0,
            "data-a11y-ignore": "aria-hidden-focus"
        },
        inputProps: {
            style: {
                display: "none"
            }
        },
        selectProps: {
            tabIndex: -1,
            autoComplete: i,
            disabled: s,
            required: l === "native" && a,
            name: o,
            value: (d = e.selectedKey) !== null && d !== void 0 ? d : "",
            onChange: h => e.setSelectedKey(h.target.value)
        }
    }
}

function th(n) {
    let {
        state: e,
        triggerRef: t,
        label: r,
        name: i,
        isDisabled: o
    } = n, s = c.useRef(null), {
        containerProps: l,
        selectProps: a
    } = eh({ ...n,
        selectRef: s
    }, e, t);
    var u;
    return e.collection.size <= 300 ? W.createElement("div", { ...l,
        "data-testid": "hidden-select-container"
    }, W.createElement("label", null, r, W.createElement("select", { ...a,
        ref: s
    }, W.createElement("option", null), [...e.collection.getKeys()].map(d => {
        let h = e.collection.getItem(d);
        if (h && h.type === "item") return W.createElement("option", {
            key: h.key,
            value: h.key
        }, h.textValue)
    })))) : i ? W.createElement("input", {
        type: "hidden",
        autoComplete: a.autoComplete,
        name: i,
        disabled: o,
        value: (u = e.selectedKey) !== null && u !== void 0 ? u : ""
    }) : null
}
const nh = c.createContext(null),
    rh = new Set(["form", "formAction", "formEncType", "formMethod", "formNoValidate", "formTarget", "name", "value"]),
    Oa = c.createContext({}),
    ih = Hd(function(e, t) {
        [e, t] = nr(e, t, Oa), e = oh(e);
        let r = e,
            {
                isPending: i
            } = r,
            {
                buttonProps: o,
                isPressed: s
            } = Jf(e, t),
            {
                focusProps: l,
                isFocused: a,
                isFocusVisible: u
            } = io(e),
            {
                hoverProps: d,
                isHovered: h
            } = eo({ ...e,
                isDisabled: e.isDisabled || i
            }),
            D = {
                isHovered: h,
                isPressed: (r.isPressed || s) && !i,
                isFocused: a,
                isFocusVisible: u,
                isDisabled: e.isDisabled || !1,
                isPending: i ? ? !1
            },
            g = sn({ ...e,
                values: D,
                defaultClassName: "react-aria-Button"
            }),
            x = Ct(o.id),
            P = Ct(),
            L = o["aria-labelledby"];
        i && (L ? L = `${L} ${P}` : o["aria-label"] && (L = `${x} ${P}`));
        let R = c.useRef(i);
        return c.useEffect(() => {
            let N = {
                "aria-labelledby": L || x
            };
            (!R.current && a && i || R.current && a && !i) && qo(N, "assertive"), R.current = i
        }, [i, a, L, x]), W.createElement("button", { ...Nt(e, {
                propNames: rh
            }),
            ...Oe(o, l, d),
            ...g,
            type: o.type === "submit" && i ? "button" : o.type,
            id: x,
            ref: t,
            "aria-labelledby": L,
            slot: e.slot || void 0,
            "aria-disabled": i ? "true" : o["aria-disabled"],
            "data-disabled": e.isDisabled || void 0,
            "data-pressed": D.isPressed || void 0,
            "data-hovered": h || void 0,
            "data-focused": a || void 0,
            "data-pending": i || void 0,
            "data-focus-visible": u || void 0
        }, W.createElement(nh.Provider, {
            value: {
                id: P
            }
        }, g.children))
    });

function oh(n) {
    return n.isPending && (n.onPress = void 0, n.onPressStart = void 0, n.onPressEnd = void 0, n.onPressChange = void 0, n.onPressUp = void 0, n.onKeyDown = void 0, n.onKeyUp = void 0, n.onClick = void 0, n.href = void 0), n
}
const uo = c.createContext({}),
    sh = c.createContext(null);
class ps {*[Symbol.iterator]() {
        yield* this.iterable
    }
    get size() {
        return this.keyMap.size
    }
    getKeys() {
        return this.keyMap.keys()
    }
    getKeyBefore(e) {
        let t = this.keyMap.get(e);
        var r;
        return t && (r = t.prevKey) !== null && r !== void 0 ? r : null
    }
    getKeyAfter(e) {
        let t = this.keyMap.get(e);
        var r;
        return t && (r = t.nextKey) !== null && r !== void 0 ? r : null
    }
    getFirstKey() {
        return this.firstKey
    }
    getLastKey() {
        return this.lastKey
    }
    getItem(e) {
        var t;
        return (t = this.keyMap.get(e)) !== null && t !== void 0 ? t : null
    }
    at(e) {
        const t = [...this.getKeys()];
        return this.getItem(t[e])
    }
    getChildren(e) {
        let t = this.keyMap.get(e);
        return (t == null ? void 0 : t.childNodes) || []
    }
    constructor(e) {
        this.keyMap = new Map, this.firstKey = null, this.lastKey = null, this.iterable = e;
        let t = s => {
            if (this.keyMap.set(s.key, s), s.childNodes && s.type === "section")
                for (let l of s.childNodes) t(l)
        };
        for (let s of e) t(s);
        let r = null,
            i = 0;
        for (let [s, l] of this.keyMap) r ? (r.nextKey = s, l.prevKey = r.key) : (this.firstKey = s, l.prevKey = void 0), l.type === "item" && (l.index = i++), r = l, r.nextKey = void 0;
        var o;
        this.lastKey = (o = r == null ? void 0 : r.key) !== null && o !== void 0 ? o : null
    }
}
class St extends Set {
    constructor(e, t, r) {
        super(e), e instanceof St ? (this.anchorKey = t ? ? e.anchorKey, this.currentKey = r ? ? e.currentKey) : (this.anchorKey = t ? ? null, this.currentKey = r ? ? null)
    }
}

function lh(n, e) {
    if (n.size !== e.size) return !1;
    for (let t of n)
        if (!e.has(t)) return !1;
    return !0
}

function ah(n) {
    let {
        selectionMode: e = "none",
        disallowEmptySelection: t = !1,
        allowDuplicateSelectionEvents: r,
        selectionBehavior: i = "toggle",
        disabledBehavior: o = "all"
    } = n, s = c.useRef(!1), [, l] = c.useState(!1), a = c.useRef(null), u = c.useRef(null), [, d] = c.useState(null), h = c.useMemo(() => hs(n.selectedKeys), [n.selectedKeys]), D = c.useMemo(() => hs(n.defaultSelectedKeys, new St), [n.defaultSelectedKeys]), [g, x] = Ui(h, D, n.onSelectionChange), P = c.useMemo(() => n.disabledKeys ? new Set(n.disabledKeys) : new Set, [n.disabledKeys]), [L, R] = c.useState(i);
    i === "replace" && L === "toggle" && typeof g == "object" && g.size === 0 && R("replace");
    let N = c.useRef(i);
    return c.useEffect(() => {
        i !== N.current && (R(i), N.current = i)
    }, [i]), {
        selectionMode: e,
        disallowEmptySelection: t,
        selectionBehavior: L,
        setSelectionBehavior: R,
        get isFocused() {
            return s.current
        },
        setFocused(S) {
            s.current = S, l(S)
        },
        get focusedKey() {
            return a.current
        },
        get childFocusStrategy() {
            return u.current
        },
        setFocusedKey(S, j = "first") {
            a.current = S, u.current = j, d(S)
        },
        selectedKeys: g,
        setSelectedKeys(S) {
            (r || !lh(S, g)) && x(S)
        },
        disabledKeys: P,
        disabledBehavior: o
    }
}

function hs(n, e) {
    return n ? n === "all" ? "all" : new St(n) : e
}
class uh {
    get selectionMode() {
        return this.state.selectionMode
    }
    get disallowEmptySelection() {
        return this.state.disallowEmptySelection
    }
    get selectionBehavior() {
        return this.state.selectionBehavior
    }
    setSelectionBehavior(e) {
        this.state.setSelectionBehavior(e)
    }
    get isFocused() {
        return this.state.isFocused
    }
    setFocused(e) {
        this.state.setFocused(e)
    }
    get focusedKey() {
        return this.state.focusedKey
    }
    get childFocusStrategy() {
        return this.state.childFocusStrategy
    }
    setFocusedKey(e, t) {
        (e == null || this.collection.getItem(e)) && this.state.setFocusedKey(e, t)
    }
    get selectedKeys() {
        return this.state.selectedKeys === "all" ? new Set(this.getSelectAllKeys()) : this.state.selectedKeys
    }
    get rawSelection() {
        return this.state.selectedKeys
    }
    isSelected(e) {
        if (this.state.selectionMode === "none") return !1;
        let t = this.getKey(e);
        return t == null ? !1 : this.state.selectedKeys === "all" ? this.canSelectItem(t) : this.state.selectedKeys.has(t)
    }
    get isEmpty() {
        return this.state.selectedKeys !== "all" && this.state.selectedKeys.size === 0
    }
    get isSelectAll() {
        if (this.isEmpty) return !1;
        if (this.state.selectedKeys === "all") return !0;
        if (this._isSelectAll != null) return this._isSelectAll;
        let e = this.getSelectAllKeys(),
            t = this.state.selectedKeys;
        return this._isSelectAll = e.every(r => t.has(r)), this._isSelectAll
    }
    get firstSelectedKey() {
        let e = null;
        for (let r of this.state.selectedKeys) {
            let i = this.collection.getItem(r);
            (!e || i && di(this.collection, i, e) < 0) && (e = i)
        }
        var t;
        return (t = e == null ? void 0 : e.key) !== null && t !== void 0 ? t : null
    }
    get lastSelectedKey() {
        let e = null;
        for (let r of this.state.selectedKeys) {
            let i = this.collection.getItem(r);
            (!e || i && di(this.collection, i, e) > 0) && (e = i)
        }
        var t;
        return (t = e == null ? void 0 : e.key) !== null && t !== void 0 ? t : null
    }
    get disabledKeys() {
        return this.state.disabledKeys
    }
    get disabledBehavior() {
        return this.state.disabledBehavior
    }
    extendSelection(e) {
        if (this.selectionMode === "none") return;
        if (this.selectionMode === "single") {
            this.replaceSelection(e);
            return
        }
        let t = this.getKey(e);
        if (t == null) return;
        let r;
        if (this.state.selectedKeys === "all") r = new St([t], t, t);
        else {
            let s = this.state.selectedKeys;
            var i;
            let l = (i = s.anchorKey) !== null && i !== void 0 ? i : t;
            r = new St(s, l, t);
            var o;
            for (let a of this.getKeyRange(l, (o = s.currentKey) !== null && o !== void 0 ? o : t)) r.delete(a);
            for (let a of this.getKeyRange(t, l)) this.canSelectItem(a) && r.add(a)
        }
        this.state.setSelectedKeys(r)
    }
    getKeyRange(e, t) {
        let r = this.collection.getItem(e),
            i = this.collection.getItem(t);
        return r && i ? di(this.collection, r, i) <= 0 ? this.getKeyRangeInternal(e, t) : this.getKeyRangeInternal(t, e) : []
    }
    getKeyRangeInternal(e, t) {
        var r;
        if (!((r = this.layoutDelegate) === null || r === void 0) && r.getKeyRange) return this.layoutDelegate.getKeyRange(e, t);
        let i = [],
            o = e;
        for (; o != null;) {
            let s = this.collection.getItem(o);
            if (s && (s.type === "item" || s.type === "cell" && this.allowsCellSelection) && i.push(o), o === t) return i;
            o = this.collection.getKeyAfter(o)
        }
        return []
    }
    getKey(e) {
        let t = this.collection.getItem(e);
        if (!t || t.type === "cell" && this.allowsCellSelection) return e;
        for (; t && t.type !== "item" && t.parentKey != null;) t = this.collection.getItem(t.parentKey);
        return !t || t.type !== "item" ? null : t.key
    }
    toggleSelection(e) {
        if (this.selectionMode === "none") return;
        if (this.selectionMode === "single" && !this.isSelected(e)) {
            this.replaceSelection(e);
            return
        }
        let t = this.getKey(e);
        if (t == null) return;
        let r = new St(this.state.selectedKeys === "all" ? this.getSelectAllKeys() : this.state.selectedKeys);
        r.has(t) ? r.delete(t) : this.canSelectItem(t) && (r.add(t), r.anchorKey = t, r.currentKey = t), !(this.disallowEmptySelection && r.size === 0) && this.state.setSelectedKeys(r)
    }
    replaceSelection(e) {
        if (this.selectionMode === "none") return;
        let t = this.getKey(e);
        if (t == null) return;
        let r = this.canSelectItem(t) ? new St([t], t, t) : new St;
        this.state.setSelectedKeys(r)
    }
    setSelectedKeys(e) {
        if (this.selectionMode === "none") return;
        let t = new St;
        for (let r of e) {
            let i = this.getKey(r);
            if (i != null && (t.add(i), this.selectionMode === "single")) break
        }
        this.state.setSelectedKeys(t)
    }
    getSelectAllKeys() {
        let e = [],
            t = r => {
                for (; r != null;) {
                    if (this.canSelectItem(r)) {
                        var i;
                        let s = this.collection.getItem(r);
                        (s == null ? void 0 : s.type) === "item" && e.push(r);
                        var o;
                        s != null && s.hasChildNodes && (this.allowsCellSelection || s.type !== "item") && t((o = (i = Up(ra(s, this.collection))) === null || i === void 0 ? void 0 : i.key) !== null && o !== void 0 ? o : null)
                    }
                    r = this.collection.getKeyAfter(r)
                }
            };
        return t(this.collection.getFirstKey()), e
    }
    selectAll() {
        !this.isSelectAll && this.selectionMode === "multiple" && this.state.setSelectedKeys("all")
    }
    clearSelection() {
        !this.disallowEmptySelection && (this.state.selectedKeys === "all" || this.state.selectedKeys.size > 0) && this.state.setSelectedKeys(new St)
    }
    toggleSelectAll() {
        this.isSelectAll ? this.clearSelection() : this.selectAll()
    }
    select(e, t) {
        this.selectionMode !== "none" && (this.selectionMode === "single" ? this.isSelected(e) && !this.disallowEmptySelection ? this.toggleSelection(e) : this.replaceSelection(e) : this.selectionBehavior === "toggle" || t && (t.pointerType === "touch" || t.pointerType === "virtual") ? this.toggleSelection(e) : this.replaceSelection(e))
    }
    isSelectionEqual(e) {
        if (e === this.state.selectedKeys) return !0;
        let t = this.selectedKeys;
        if (e.size !== t.size) return !1;
        for (let r of e)
            if (!t.has(r)) return !1;
        for (let r of t)
            if (!e.has(r)) return !1;
        return !0
    }
    canSelectItem(e) {
        var t;
        if (this.state.selectionMode === "none" || this.state.disabledKeys.has(e)) return !1;
        let r = this.collection.getItem(e);
        return !(!r || !(r == null || (t = r.props) === null || t === void 0) && t.isDisabled || r.type === "cell" && !this.allowsCellSelection)
    }
    isDisabled(e) {
        var t, r;
        return this.state.disabledBehavior === "all" && (this.state.disabledKeys.has(e) || !!(!((r = this.collection.getItem(e)) === null || r === void 0 || (t = r.props) === null || t === void 0) && t.isDisabled))
    }
    isLink(e) {
        var t, r;
        return !!(!((r = this.collection.getItem(e)) === null || r === void 0 || (t = r.props) === null || t === void 0) && t.href)
    }
    getItemProps(e) {
        var t;
        return (t = this.collection.getItem(e)) === null || t === void 0 ? void 0 : t.props
    }
    constructor(e, t, r) {
        this.collection = e, this.state = t;
        var i;
        this.allowsCellSelection = (i = r == null ? void 0 : r.allowsCellSelection) !== null && i !== void 0 ? i : !1, this._isSelectAll = null, this.layoutDelegate = (r == null ? void 0 : r.layoutDelegate) || null
    }
}

function ja(n) {
    let {
        filter: e,
        layoutDelegate: t
    } = n, r = ah(n), i = c.useMemo(() => n.disabledKeys ? new Set(n.disabledKeys) : new Set, [n.disabledKeys]), o = c.useCallback(d => e ? new ps(e(d)) : new ps(d), [e]), s = c.useMemo(() => ({
        suppressTextValueWarning: n.suppressTextValueWarning
    }), [n.suppressTextValueWarning]), l = Hp(n, o, s), a = c.useMemo(() => new uh(l, r, {
        layoutDelegate: t
    }), [l, r, t]);
    const u = c.useRef(null);
    return c.useEffect(() => {
        if (r.focusedKey != null && !l.getItem(r.focusedKey) && u.current) {
            const R = u.current.getItem(r.focusedKey),
                N = [...u.current.getKeys()].map(f => {
                    const I = u.current.getItem(f);
                    return (I == null ? void 0 : I.type) === "item" ? I : null
                }).filter(f => f !== null),
                S = [...l.getKeys()].map(f => {
                    const I = l.getItem(f);
                    return (I == null ? void 0 : I.type) === "item" ? I : null
                }).filter(f => f !== null);
            var d, h;
            const j = ((d = N == null ? void 0 : N.length) !== null && d !== void 0 ? d : 0) - ((h = S == null ? void 0 : S.length) !== null && h !== void 0 ? h : 0);
            var D, g, x;
            let k = Math.min(j > 1 ? Math.max(((D = R == null ? void 0 : R.index) !== null && D !== void 0 ? D : 0) - j + 1, 0) : (g = R == null ? void 0 : R.index) !== null && g !== void 0 ? g : 0, ((x = S == null ? void 0 : S.length) !== null && x !== void 0 ? x : 0) - 1),
                B = null,
                M = !1;
            for (; k >= 0;) {
                if (!a.isDisabled(S[k].key)) {
                    B = S[k];
                    break
                }
                if (k < S.length - 1 && !M) k++;
                else {
                    M = !0;
                    var P, L;
                    k > ((P = R == null ? void 0 : R.index) !== null && P !== void 0 ? P : 0) && (k = (L = R == null ? void 0 : R.index) !== null && L !== void 0 ? L : 0), k--
                }
            }
            r.setFocusedKey(B ? B.key : null)
        }
        u.current = l
    }, [l, a, r, r.focusedKey]), {
        collection: l,
        disabledKeys: i,
        selectionManager: a
    }
}

function ch(n) {
    var e;
    let [t, r] = Ui(n.selectedKey, (e = n.defaultSelectedKey) !== null && e !== void 0 ? e : null, n.onSelectionChange), i = c.useMemo(() => t != null ? [t] : [], [t]), {
        collection: o,
        disabledKeys: s,
        selectionManager: l
    } = ja({ ...n,
        selectionMode: "single",
        disallowEmptySelection: !0,
        allowDuplicateSelectionEvents: !0,
        selectedKeys: i,
        onSelectionChange: u => {
            if (u === "all") return;
            var d;
            let h = (d = u.values().next().value) !== null && d !== void 0 ? d : null;
            h === t && n.onSelectionChange && n.onSelectionChange(h), r(h)
        }
    }), a = t != null ? o.getItem(t) : null;
    return {
        collection: o,
        disabledKeys: s,
        selectionManager: l,
        selectedKey: t,
        setSelectedKey: r,
        selectedItem: a
    }
}

function za(n) {
    let [e, t] = Ui(n.isOpen, n.defaultOpen || !1, n.onOpenChange);
    const r = c.useCallback(() => {
            t(!0)
        }, [t]),
        i = c.useCallback(() => {
            t(!1)
        }, [t]),
        o = c.useCallback(() => {
            t(!e)
        }, [t, e]);
    return {
        isOpen: e,
        setOpen: t,
        open: r,
        close: i,
        toggle: o
    }
}

function dh(n) {
    let e = za(n),
        [t, r] = c.useState(null),
        i = ch({ ...n,
            onSelectionChange: a => {
                n.onSelectionChange != null && n.onSelectionChange(a), e.close(), o.commitValidation()
            }
        }),
        o = tp({ ...n,
            value: i.selectedKey
        }),
        [s, l] = c.useState(!1);
    return { ...o,
        ...i,
        ...e,
        focusStrategy: t,
        open(a = null) {
            i.collection.size !== 0 && (r(a), e.open())
        },
        toggle(a = null) {
            i.collection.size !== 0 && (r(a), e.toggle())
        },
        isFocused: s,
        setFocused: l
    }
}
const fh = c.createContext(null),
    ph = c.createContext(null),
    hh = c.createContext(null),
    Dh = {
        CollectionRoot({
            collection: n,
            renderDropIndicator: e
        }) {
            return Ds(n, null, e)
        },
        CollectionBranch({
            collection: n,
            parent: e,
            renderDropIndicator: t
        }) {
            return Ds(n, e, t)
        }
    };

function Ds(n, e, t) {
    return Ys({
        items: e ? n.getChildren(e.key) : n,
        dependencies: [t],
        children(r) {
            var i;
            let o = r.render(r);
            if (!t || r.type !== "item") return o;
            let s = r.key,
                l = n.getKeyAfter(s);
            return W.createElement(W.Fragment, null, t({
                type: "item",
                key: s,
                dropPosition: "before"
            }), o, (l == null || ((i = n.getItem(l)) === null || i === void 0 ? void 0 : i.type) !== "item") && t({
                type: "item",
                key: s,
                dropPosition: "after"
            }))
        }
    })
}
const co = c.createContext(Dh);
var Va = {};
Va = {
    colorSwatchPicker: "تغييرات الألوان",
    dropzoneLabel: "DropZone",
    selectPlaceholder: "حدد عنصرًا",
    tableResizer: "أداة تغيير الحجم"
};
var Wa = {};
Wa = {
    colorSwatchPicker: "Цветови мостри",
    dropzoneLabel: "DropZone",
    selectPlaceholder: "Изберете предмет",
    tableResizer: "Преоразмерител"
};
var Ha = {};
Ha = {
    colorSwatchPicker: "Vzorky barev",
    dropzoneLabel: "Místo pro přetažení",
    selectPlaceholder: "Vyberte položku",
    tableResizer: "Změna velikosti"
};
var Ua = {};
Ua = {
    colorSwatchPicker: "Farveprøver",
    dropzoneLabel: "DropZone",
    selectPlaceholder: "Vælg et element",
    tableResizer: "Størrelsesændring"
};
var Ga = {};
Ga = {
    colorSwatchPicker: "Farbfelder",
    dropzoneLabel: "Ablegebereich",
    selectPlaceholder: "Element wählen",
    tableResizer: "Größenanpassung"
};
var Xa = {};
Xa = {
    colorSwatchPicker: "Χρωματικά δείγματα",
    dropzoneLabel: "DropZone",
    selectPlaceholder: "Επιλέξτε ένα αντικείμενο",
    tableResizer: "Αλλαγή μεγέθους"
};
var qa = {};
qa = {
    selectPlaceholder: "Select an item",
    tableResizer: "Resizer",
    dropzoneLabel: "DropZone",
    colorSwatchPicker: "Color swatches"
};
var Ya = {};
Ya = {
    colorSwatchPicker: "Muestras de colores",
    dropzoneLabel: "DropZone",
    selectPlaceholder: "Seleccionar un artículo",
    tableResizer: "Cambiador de tamaño"
};
var Za = {};
Za = {
    colorSwatchPicker: "Värvinäidised",
    dropzoneLabel: "DropZone",
    selectPlaceholder: "Valige üksus",
    tableResizer: "Suuruse muutja"
};
var Ja = {};
Ja = {
    colorSwatchPicker: "Värimallit",
    dropzoneLabel: "DropZone",
    selectPlaceholder: "Valitse kohde",
    tableResizer: "Koon muuttaja"
};
var Qa = {};
Qa = {
    colorSwatchPicker: "Échantillons de couleurs",
    dropzoneLabel: "DropZone",
    selectPlaceholder: "Sélectionner un élément",
    tableResizer: "Redimensionneur"
};
var eu = {};
eu = {
    colorSwatchPicker: "דוגמיות צבע",
    dropzoneLabel: "DropZone",
    selectPlaceholder: "בחר פריט",
    tableResizer: "שינוי גודל"
};
var tu = {};
tu = {
    colorSwatchPicker: "Uzorci boja",
    dropzoneLabel: "Zona spuštanja",
    selectPlaceholder: "Odaberite stavku",
    tableResizer: "Promjena veličine"
};
var nu = {};
nu = {
    colorSwatchPicker: "Színtárak",
    dropzoneLabel: "DropZone",
    selectPlaceholder: "Válasszon ki egy elemet",
    tableResizer: "Átméretező"
};
var ru = {};
ru = {
    colorSwatchPicker: "Campioni di colore",
    dropzoneLabel: "Zona di rilascio",
    selectPlaceholder: "Seleziona un elemento",
    tableResizer: "Ridimensionamento"
};
var iu = {};
iu = {
    colorSwatchPicker: "カラースウォッチ",
    dropzoneLabel: "ドロップゾーン",
    selectPlaceholder: "項目を選択",
    tableResizer: "サイズ変更ツール"
};
var ou = {};
ou = {
    colorSwatchPicker: "색상 견본",
    dropzoneLabel: "드롭 영역",
    selectPlaceholder: "항목 선택",
    tableResizer: "크기 조정기"
};
var su = {};
su = {
    colorSwatchPicker: "Spalvų pavyzdžiai",
    dropzoneLabel: "„DropZone“",
    selectPlaceholder: "Pasirinkite elementą",
    tableResizer: "Dydžio keitiklis"
};
var lu = {};
lu = {
    colorSwatchPicker: "Krāsu paraugi",
    dropzoneLabel: "DropZone",
    selectPlaceholder: "Izvēlēties vienumu",
    tableResizer: "Izmēra mainītājs"
};
var au = {};
au = {
    colorSwatchPicker: "Fargekart",
    dropzoneLabel: "Droppsone",
    selectPlaceholder: "Velg et element",
    tableResizer: "Størrelsesendrer"
};
var uu = {};
uu = {
    colorSwatchPicker: "kleurstalen",
    dropzoneLabel: "DropZone",
    selectPlaceholder: "Selecteer een item",
    tableResizer: "Resizer"
};
var cu = {};
cu = {
    colorSwatchPicker: "Próbki kolorów",
    dropzoneLabel: "Strefa upuszczania",
    selectPlaceholder: "Wybierz element",
    tableResizer: "Zmiana rozmiaru"
};
var du = {};
du = {
    colorSwatchPicker: "Amostras de cores",
    dropzoneLabel: "DropZone",
    selectPlaceholder: "Selecione um item",
    tableResizer: "Redimensionador"
};
var fu = {};
fu = {
    colorSwatchPicker: "Amostras de cores",
    dropzoneLabel: "DropZone",
    selectPlaceholder: "Selecione um item",
    tableResizer: "Redimensionador"
};
var pu = {};
pu = {
    colorSwatchPicker: "Specimene de culoare",
    dropzoneLabel: "Zonă de plasare",
    selectPlaceholder: "Selectați un element",
    tableResizer: "Instrument de redimensionare"
};
var hu = {};
hu = {
    colorSwatchPicker: "Цветовые образцы",
    dropzoneLabel: "DropZone",
    selectPlaceholder: "Выберите элемент",
    tableResizer: "Средство изменения размера"
};
var Du = {};
Du = {
    colorSwatchPicker: "Vzorkovníky farieb",
    dropzoneLabel: "DropZone",
    selectPlaceholder: "Vyberte položku",
    tableResizer: "Nástroj na zmenu veľkosti"
};
var vu = {};
vu = {
    colorSwatchPicker: "Barvne palete",
    dropzoneLabel: "DropZone",
    selectPlaceholder: "Izberite element",
    tableResizer: "Spreminjanje velikosti"
};
var gu = {};
gu = {
    colorSwatchPicker: "Uzorci boje",
    dropzoneLabel: "DropZone",
    selectPlaceholder: "Izaberite stavku",
    tableResizer: "Promena veličine"
};
var mu = {};
mu = {
    colorSwatchPicker: "Färgrutor",
    dropzoneLabel: "DropZone",
    selectPlaceholder: "Välj en artikel",
    tableResizer: "Storleksändrare"
};
var bu = {};
bu = {
    colorSwatchPicker: "Renk örnekleri",
    dropzoneLabel: "Bırakma Bölgesi",
    selectPlaceholder: "Bir öğe seçin",
    tableResizer: "Yeniden boyutlandırıcı"
};
var yu = {};
yu = {
    colorSwatchPicker: "Зразки кольорів",
    dropzoneLabel: "DropZone",
    selectPlaceholder: "Виберіть елемент",
    tableResizer: "Засіб змінення розміру"
};
var Eu = {};
Eu = {
    colorSwatchPicker: "颜色色板",
    dropzoneLabel: "放置区域",
    selectPlaceholder: "选择一个项目",
    tableResizer: "尺寸调整器"
};
var Cu = {};
Cu = {
    colorSwatchPicker: "色票",
    dropzoneLabel: "放置區",
    selectPlaceholder: "選取項目",
    tableResizer: "大小調整器"
};
var xu = {};
xu = {
    "ar-AE": Va,
    "bg-BG": Wa,
    "cs-CZ": Ha,
    "da-DK": Ua,
    "de-DE": Ga,
    "el-GR": Xa,
    "en-US": qa,
    "es-ES": Ya,
    "et-EE": Za,
    "fi-FI": Ja,
    "fr-FR": Qa,
    "he-IL": eu,
    "hr-HR": tu,
    "hu-HU": nu,
    "it-IT": ru,
    "ja-JP": iu,
    "ko-KR": ou,
    "lt-LT": su,
    "lv-LV": lu,
    "nb-NO": au,
    "nl-NL": uu,
    "pl-PL": cu,
    "pt-BR": du,
    "pt-PT": fu,
    "ro-RO": pu,
    "ru-RU": hu,
    "sk-SK": Du,
    "sl-SI": vu,
    "sr-SP": gu,
    "sv-SE": mu,
    "tr-TR": bu,
    "uk-UA": yu,
    "zh-CN": Eu,
    "zh-TW": Cu
};
const jr = c.createContext({}),
    $u = c.createContext(null),
    vh = c.forwardRef(function(e, t) {
        let {
            render: r
        } = c.useContext($u);
        return W.createElement(W.Fragment, null, r(e, t))
    });

function wu(n, e) {
    var t;
    let r = n == null ? void 0 : n.renderDropIndicator,
        i = n == null || (t = n.isVirtualDragging) === null || t === void 0 ? void 0 : t.call(n),
        o = c.useCallback(s => {
            if (i || e != null && e.isDropTarget(s)) return r ? r(s) : W.createElement(vh, {
                target: s
            })
        }, [e == null ? void 0 : e.target, i, r]);
    return n != null && n.useDropIndicator ? o : void 0
}

function gh(n, e, t) {
    var r, i;
    let o = n.focusedKey,
        s = null;
    if (!(e == null || (r = e.isVirtualDragging) === null || r === void 0) && r.call(e) && (t == null || (i = t.target) === null || i === void 0 ? void 0 : i.type) === "item") {
        s = t.target.key;
        var l;
        t.target.dropPosition === "after" && (s = (l = t.collection.getKeyAfter(s)) !== null && l !== void 0 ? l : s)
    }
    return c.useMemo(() => new Set([o, s].filter(a => a != null)), [o, s])
}
const mh = c.createContext({}),
    bh = c.createContext({}),
    fo = c.createContext(null),
    ir = c.createContext(null),
    yh = c.forwardRef(function(e, t) {
        [e, t] = nr(e, t, fo);
        let r = c.useContext(ir);
        return r ? W.createElement(Fu, {
            state: r,
            props: e,
            listBoxRef: t
        }) : W.createElement(Js, {
            content: W.createElement(ef, e)
        }, i => W.createElement(Eh, {
            props: e,
            listBoxRef: t,
            collection: i
        }))
    });

function Eh({
    props: n,
    listBoxRef: e,
    collection: t
}) {
    n = { ...n,
        collection: t,
        children: null,
        items: null
    };
    let {
        layoutDelegate: r
    } = c.useContext(co), {
        filterFn: i,
        collectionProps: o,
        collectionRef: s
    } = c.useContext(ph) || {};
    e = Nr(c.useMemo(() => Ns(e, s !== void 0 ? s : null), [s, e]));
    let l = c.useMemo(() => i ? t.filter(i) : t, [t, i]),
        a = ja({ ...n,
            collection: l,
            layoutDelegate: r
        });
    return W.createElement(Fu, {
        state: a,
        props: { ...n,
            ...o
        },
        listBoxRef: e
    })
}

function Fu({
    state: n,
    props: e,
    listBoxRef: t
}) {
    let {
        dragAndDropHooks: r,
        layout: i = "stack",
        orientation: o = "vertical"
    } = e, {
        collection: s,
        selectionManager: l
    } = n, a = !!(r != null && r.useDraggableCollectionState), u = !!(r != null && r.useDroppableCollectionState), {
        direction: d
    } = rr(), {
        disabledBehavior: h,
        disabledKeys: D
    } = l, g = so({
        usage: "search",
        sensitivity: "base"
    }), {
        isVirtualized: x,
        layoutDelegate: P,
        dropTargetDelegate: L,
        CollectionRoot: R
    } = c.useContext(co), N = c.useMemo(() => e.keyboardDelegate || new ao({
        collection: s,
        collator: g,
        ref: t,
        disabledKeys: D,
        disabledBehavior: h,
        layout: i,
        orientation: o,
        direction: d,
        layoutDelegate: P
    }), [s, g, t, h, D, o, d, e.keyboardDelegate, i, P]), {
        listBoxProps: S
    } = zp({ ...e,
        shouldSelectOnPressUp: a || e.shouldSelectOnPressUp,
        keyboardDelegate: N,
        isVirtualized: x
    }, n, t), j = c.useRef(a), k = c.useRef(u);
    c.useEffect(() => {
        j.current !== a && console.warn("Drag hooks were provided during one render, but not another. This should be avoided as it may produce unexpected behavior."), k.current !== u && console.warn("Drop hooks were provided during one render, but not another. This should be avoided as it may produce unexpected behavior.")
    }, [a, u]);
    let B, M, f, I = !1,
        O = null,
        T = c.useRef(null);
    if (a && r) {
        B = r.useDraggableCollectionState({
            collection: s,
            selectionManager: l,
            preview: r.renderDragPreview ? T : void 0
        }), r.useDraggableCollection({}, B, t);
        let E = r.DragPreview;
        O = r.renderDragPreview ? W.createElement(E, {
            ref: T
        }, r.renderDragPreview) : null
    }
    if (u && r) {
        M = r.useDroppableCollectionState({
            collection: s,
            selectionManager: l
        });
        let E = r.dropTargetDelegate || L || new r.ListDropTargetDelegate(s, t, {
            orientation: o,
            layout: i,
            direction: d
        });
        f = r.useDroppableCollection({
            keyboardDelegate: N,
            dropTargetDelegate: E
        }, M, t), I = M.isDropTarget({
            type: "root"
        })
    }
    let {
        focusProps: K,
        isFocused: m,
        isFocusVisible: p
    } = io(), w = {
        isDropTarget: I,
        isEmpty: n.collection.size === 0,
        isFocused: m,
        isFocusVisible: p,
        layout: e.layout || "stack",
        state: n
    }, C = sn({
        className: e.className,
        style: e.style,
        defaultClassName: "react-aria-ListBox",
        values: w
    }), A = null;
    return n.collection.size === 0 && e.renderEmptyState && (A = W.createElement("div", {
        role: "option",
        style: {
            display: "contents"
        }
    }, e.renderEmptyState(w))), W.createElement(to, null, W.createElement("div", { ...Nt(e),
        ...Oe(S, K, f == null ? void 0 : f.collectionProps),
        ...C,
        ref: t,
        slot: e.slot || void 0,
        onScroll: e.onScroll,
        "data-drop-target": I || void 0,
        "data-empty": n.collection.size === 0 || void 0,
        "data-focused": m || void 0,
        "data-focus-visible": p || void 0,
        "data-layout": e.layout || "stack",
        "data-orientation": e.orientation || "vertical"
    }, W.createElement(Gi, {
        values: [
            [fo, e],
            [ir, n],
            [jr, {
                dragAndDropHooks: r,
                dragState: B,
                dropState: M
            }],
            [bh, {
                elementType: "div"
            }],
            [$u, {
                render: $h
            }],
            [hh, {
                name: "ListBoxSection",
                render: Ch
            }]
        ]
    }, W.createElement(R, {
        collection: s,
        scrollRef: t,
        persistedKeys: gh(l, r, M),
        renderDropIndicator: wu(r, M)
    })), A, O))
}

function Ch(n, e, t, r = "react-aria-ListBoxSection") {
    let i = c.useContext(ir),
        {
            dragAndDropHooks: o,
            dropState: s
        } = c.useContext(jr),
        {
            CollectionBranch: l
        } = c.useContext(co),
        [a, u] = Xs();
    var d;
    let {
        headingProps: h,
        groupProps: D
    } = Yp({
        heading: u,
        "aria-label": (d = n["aria-label"]) !== null && d !== void 0 ? d : void 0
    }), g = sn({
        defaultClassName: r,
        className: n.className,
        style: n.style,
        values: {}
    });
    return W.createElement("section", { ...Nt(n),
        ...D,
        ...g,
        ref: e
    }, W.createElement(mh.Provider, {
        value: { ...h,
            ref: a
        }
    }, W.createElement(l, {
        collection: i.collection,
        parent: t,
        renderDropIndicator: wu(o, s)
    })))
}
const xh = Jd("item", function(e, t, r) {
    let i = Nr(t),
        o = c.useContext(ir),
        {
            dragAndDropHooks: s,
            dragState: l,
            dropState: a
        } = c.useContext(jr),
        {
            optionProps: u,
            labelProps: d,
            descriptionProps: h,
            ...D
        } = qp({
            key: r.key,
            "aria-label": e == null ? void 0 : e["aria-label"]
        }, o, i),
        {
            hoverProps: g,
            isHovered: x
        } = eo({
            isDisabled: !D.allowsSelection && !D.hasAction,
            onHoverStart: r.props.onHoverStart,
            onHoverChange: r.props.onHoverChange,
            onHoverEnd: r.props.onHoverEnd
        }),
        P = null;
    l && s && (P = s.useDraggableItem({
        key: r.key
    }, l));
    let L = null;
    a && s && (L = s.useDroppableItem({
        target: {
            type: "item",
            key: r.key,
            dropPosition: "on"
        }
    }, a, i));
    let R = l && l.isDragging(r.key),
        N = sn({ ...e,
            id: void 0,
            children: e.children,
            defaultClassName: "react-aria-ListBoxItem",
            values: { ...D,
                isHovered: x,
                selectionMode: o.selectionManager.selectionMode,
                selectionBehavior: o.selectionManager.selectionBehavior,
                allowsDragging: !!l,
                isDragging: R,
                isDropTarget: L == null ? void 0 : L.isDropTarget
            }
        });
    c.useEffect(() => {
        r.textValue || console.warn("A `textValue` prop is required for <ListBoxItem> elements with non-plain text children in order to support accessibility features such as type to select.")
    }, [r.textValue]);
    let S = e.href ? "a" : "div";
    return W.createElement(S, { ...Oe(u, g, P == null ? void 0 : P.dragProps, L == null ? void 0 : L.dropProps),
        ...N,
        ref: i,
        "data-allows-dragging": !!l || void 0,
        "data-selected": D.isSelected || void 0,
        "data-disabled": D.isDisabled || void 0,
        "data-hovered": x || void 0,
        "data-focused": D.isFocused || void 0,
        "data-focus-visible": D.isFocusVisible || void 0,
        "data-pressed": D.isPressed || void 0,
        "data-dragging": R || void 0,
        "data-drop-target": (L == null ? void 0 : L.isDropTarget) || void 0,
        "data-selection-mode": o.selectionManager.selectionMode === "none" ? void 0 : o.selectionManager.selectionMode
    }, W.createElement(Gi, {
        values: [
            [uo, {
                slots: {
                    label: d,
                    description: h
                }
            }]
        ]
    }, N.children))
});

function $h(n, e) {
    e = Nr(e);
    let {
        dragAndDropHooks: t,
        dropState: r
    } = c.useContext(jr), {
        dropIndicatorProps: i,
        isHidden: o,
        isDropTarget: s
    } = t.useDropIndicator(n, r, e);
    return o ? null : W.createElement(Fh, { ...n,
        dropIndicatorProps: i,
        isDropTarget: s,
        ref: e
    })
}

function wh(n, e) {
    let {
        dropIndicatorProps: t,
        isDropTarget: r,
        ...i
    } = n, o = sn({ ...i,
        defaultClassName: "react-aria-DropIndicator",
        values: {
            isDropTarget: r
        }
    });
    return W.createElement("div", { ...t,
        ...o,
        role: "option",
        ref: e,
        "data-drop-target": r || void 0
    })
}
const Fh = c.forwardRef(wh),
    Sh = c.createContext({
        placement: "bottom"
    }),
    Su = c.createContext(null),
    _h = c.forwardRef(function(e, t) {
        [e, t] = nr(e, t, Su);
        let r = c.useContext(_u),
            i = za(e),
            o = e.isOpen != null || e.defaultOpen != null || !r ? i : r,
            s = Od(t, o.isOpen) || e.isExiting || !1;
        if (Ud()) {
            let a = e.children;
            return typeof a == "function" && (a = a({
                trigger: e.trigger || null,
                placement: "bottom",
                isEntering: !1,
                isExiting: !1,
                defaultChildren: null
            })), W.createElement(W.Fragment, null, a)
        }
        return o && !o.isOpen && !s ? null : W.createElement(Ph, { ...e,
            triggerRef: e.triggerRef,
            state: o,
            popoverRef: t,
            isExiting: s
        })
    });

function Ph({
    state: n,
    isExiting: e,
    UNSTABLE_portalContainer: t,
    ...r
}) {
    let i = c.useRef(null),
        [o, s] = c.useState(0);
    Fe(() => {
        i.current && n.isOpen && s(i.current.getBoundingClientRect().width)
    }, [n.isOpen, i]);
    var l;
    let {
        popoverProps: a,
        underlayProps: u,
        arrowProps: d,
        placement: h
    } = Tp({ ...r,
        offset: (l = r.offset) !== null && l !== void 0 ? l : 8,
        arrowSize: o
    }, n), D = r.popoverRef, g = Kd(D, !!h) || r.isEntering || !1, x = sn({ ...r,
        defaultClassName: "react-aria-Popover",
        values: {
            trigger: r.trigger || null,
            placement: h,
            isEntering: g,
            isExiting: e
        }
    }), P = { ...a.style,
        ...x.style
    };
    return W.createElement(Bp, { ...r,
        isExiting: e,
        portalContainer: t
    }, !r.isNonModal && n.isOpen && W.createElement("div", {
        "data-testid": "underlay",
        ...u,
        style: {
            position: "fixed",
            inset: 0
        }
    }), W.createElement("div", { ...Oe(Nt(r), a),
        ...x,
        ref: D,
        slot: r.slot || void 0,
        style: P,
        "data-trigger": r.trigger,
        "data-placement": h,
        "data-entering": g || void 0,
        "data-exiting": e || void 0
    }, !r.isNonModal && W.createElement(ss, {
        onDismiss: n.close
    }), W.createElement(Sh.Provider, {
        value: { ...d,
            placement: h,
            ref: i
        }
    }, x.children), W.createElement(ss, {
        onDismiss: n.close
    })))
}
const _u = c.createContext(null);

function Th(n) {
    return n && n.__esModule ? n.default : n
}
const po = c.createContext(null),
    Pu = c.createContext(null),
    kh = c.forwardRef(function(e, t) {
        [e, t] = nr(e, t, po);
        let {
            children: r,
            isDisabled: i = !1,
            isInvalid: o = !1,
            isRequired: s = !1
        } = e, l = c.useMemo(() => typeof r == "function" ? r({
            isOpen: !1,
            isDisabled: i,
            isInvalid: o,
            isRequired: s,
            isFocused: !1,
            isFocusVisible: !1,
            defaultChildren: null
        }) : r, [r, i, o, s]);
        return W.createElement(Js, {
            content: l
        }, a => W.createElement(Ah, {
            props: e,
            collection: a,
            selectRef: t
        }))
    });

function Ah({
    props: n,
    selectRef: e,
    collection: t
}) {
    let {
        validationBehavior: r
    } = Xi(fh) || {};
    var i, o;
    let s = (o = (i = n.validationBehavior) !== null && i !== void 0 ? i : r) !== null && o !== void 0 ? o : "native",
        l = dh({ ...n,
            collection: t,
            children: void 0,
            validationBehavior: s
        }),
        {
            isFocusVisible: a,
            focusProps: u
        } = io({
            within: !0
        }),
        d = c.useRef(null),
        [h, D] = Xs(),
        {
            labelProps: g,
            triggerProps: x,
            valueProps: P,
            menuProps: L,
            descriptionProps: R,
            errorMessageProps: N,
            ...S
        } = Qp({ ...jd(n),
            label: D,
            validationBehavior: s
        }, l, d),
        [j, k] = c.useState(null),
        B = c.useCallback(() => {
            d.current && k(d.current.offsetWidth + "px")
        }, [d]);
    Ei({
        ref: d,
        onResize: B
    });
    let M = c.useMemo(() => ({
            isOpen: l.isOpen,
            isFocused: l.isFocused,
            isFocusVisible: a,
            isDisabled: n.isDisabled || !1,
            isInvalid: S.isInvalid || !1,
            isRequired: n.isRequired || !1
        }), [l.isOpen, l.isFocused, a, n.isDisabled, S.isInvalid, n.isRequired]),
        f = sn({ ...n,
            values: M,
            defaultClassName: "react-aria-Select"
        }),
        I = Nt(n);
    delete I.id;
    let O = c.useRef(null);
    return W.createElement(Gi, {
        values: [
            [po, n],
            [Pu, l],
            [Tu, P],
            [nf, { ...g,
                ref: h,
                elementType: "span"
            }],
            [Oa, { ...x,
                ref: d,
                isPressed: l.isOpen
            }],
            [_u, l],
            [Su, {
                trigger: "Select",
                triggerRef: d,
                scrollRef: O,
                placement: "bottom start",
                style: {
                    "--trigger-width": j
                }
            }],
            [fo, { ...L,
                ref: O
            }],
            [ir, l],
            [uo, {
                slots: {
                    description: R,
                    errorMessage: N
                }
            }],
            [sh, S]
        ]
    }, W.createElement("div", { ...I,
        ...f,
        ...u,
        ref: e,
        slot: n.slot || void 0,
        "data-focused": l.isFocused || void 0,
        "data-focus-visible": a || void 0,
        "data-open": l.isOpen || void 0,
        "data-disabled": n.isDisabled || void 0,
        "data-invalid": S.isInvalid || void 0,
        "data-required": n.isRequired || void 0
    }), W.createElement(th, {
        autoComplete: n.autoComplete,
        state: l,
        triggerRef: d,
        label: D,
        name: n.name,
        isDisabled: n.isDisabled
    }))
}
const Tu = c.createContext(null),
    Lh = c.forwardRef(function(e, t) {
        var r, i;
        [e, t] = nr(e, t, Tu);
        let o = c.useContext(Pu),
            {
                placeholder: s
            } = Xi(po),
            l = o.selectedKey != null ? o.collection.getItem(o.selectedKey) : null,
            a = l == null ? void 0 : l.props.children;
        typeof a == "function" && (a = a({
            isHovered: !1,
            isPressed: !1,
            isSelected: !1,
            isFocused: !1,
            isFocusVisible: !1,
            isDisabled: !1,
            selectionMode: "single",
            selectionBehavior: "toggle"
        }));
        let u = oo(Th(xu), "react-aria-components");
        var d, h, D;
        let g = sn({ ...e,
                defaultChildren: (d = a ? ? s) !== null && d !== void 0 ? d : u.format("selectPlaceholder"),
                defaultClassName: "react-aria-SelectValue",
                values: {
                    selectedItem: (h = (r = o.selectedItem) === null || r === void 0 ? void 0 : r.value) !== null && h !== void 0 ? h : null,
                    selectedText: (D = (i = o.selectedItem) === null || i === void 0 ? void 0 : i.textValue) !== null && D !== void 0 ? D : null,
                    isPlaceholder: !l
                }
            }),
            x = Nt(e);
        return W.createElement("span", {
            ref: t,
            ...x,
            ...g,
            "data-placeholder": !l || void 0
        }, W.createElement(uo.Provider, {
            value: void 0
        }, g.children))
    }),
    Bh = "390px",
    Rh = "768px",
    Mh = "1024px",
    Nh = "1280px",
    Ih = "1680px",
    Kh = "1920px",
    Oh = "_animatedBackground_30lxk_1",
    jh = {
        mobile: Bh,
        tablet: Rh,
        desktop: Mh,
        mlarge: Nh,
        large: Ih,
        xlarge: Kh,
        animatedBackground: Oh
    },
    zh = ["xlarge", "large", "mlarge", "desktop", "tablet", "mobile"],
    ku = zh.map(n => [n, parseFloat(jh[n])]),
    Vh = [640, 750, 828, 1080, 1200, 1920, 2048],
    Wh = [1, 2],
    Hh = 75,
    Uh = "auto",
    vs = Object.fromEntries(ku),
    Gh = n => {
        if (typeof n == "string") return n;
        const e = [];
        let t = "";
        for (const r of n)
            if (typeof r == "string") t = r;
            else
                for (const [i, o] of Object.entries(r)) e.push([vs[i], `(min-width: ${vs[i]}px) ${o}`]);
        return [...e.sort((r, i) => r[0] - i[0]).map(r => r[1]), t].filter(Boolean).join(", ")
    },
    gs = (n, {
        width: e,
        height: t,
        format: r,
        quality: i
    }) => {
        const o = new URLSearchParams;
        return e && o.set("w", String(e)), t && o.set("h", String(t)), o.set("fm", r), o.set("q", String(i)), n + "?" + o.toString()
    },
    Xh = (n, {
        densities: e = Wh,
        format: t = Uh,
        quality: r = Hh,
        withSizes: i,
        ...o
    }) => {
        const s = new Map;
        if (!i) e.forEach(l => {
            const a = gs(n, {
                width: o.width * l,
                height: o.height * l,
                quality: r,
                format: t
            });
            s.set(l + "x", a)
        });
        else {
            const l = o.width / o.height;
            Object.values(Vh).forEach(a => {
                e.forEach(u => {
                    const d = a * u,
                        h = Math.round(d / l);
                    if (!s.has(d + "w")) {
                        const D = gs(n, {
                            width: d,
                            height: h,
                            quality: r,
                            format: t
                        });
                        s.set(d + "w", D)
                    }
                })
            })
        }
        return [...s].map(([l, a]) => `${a} ${l}`).join(", ")
    },
    _n = c.forwardRef(({
        src: n,
        sizes: e,
        densities: t,
        width: r,
        height: i,
        quality: o,
        format: s,
        fill: l = !0,
        fadeIn: a = !0,
        style: u = {},
        isWebgl: d,
        ...h
    }, D) => {
        const g = c.useMemo(() => e ? Gh(e) : void 0, [JSON.stringify(e)]),
            x = {
                densities: t,
                width: r,
                height: i,
                quality: o,
                format: s,
                withSizes: !!e
            },
            P = c.useMemo(() => Xh(n, x), [n, JSON.stringify(x)]),
            L = l ? {
                width: "100%",
                height: "100%",
                objectFit: "cover",
                ...u
            } : {
                width: "100%",
                height: "100%",
                objectFit: "contain",
                ...u
            },
            R = c.useRef(null);
        a && (L.visibility = "hidden");
        const {
            add: N
        } = Cs();
        return c.useEffect(() => {
            if (!a) return;
            const S = R.current,
                j = getComputedStyle(S).opacity,
                k = () => {
                    if (!S) return;
                    S.animate([{
                        opacity: 0,
                        visibility: "hidden"
                    }, {
                        opacity: j,
                        visibility: "visible"
                    }], {
                        duration: 500,
                        easing: "ease-out"
                    }).addEventListener("finish", () => S.style.visibility = "")
                };
            return S.complete ? k() : (S.addEventListener("load", k), () => S.removeEventListener("load", k))
        }, [a]), $.jsx("img", {
            ref: rc([R, D, N("image", 0)]),
            src: n,
            sizes: g,
            width: r,
            height: i,
            srcSet: P,
            loading: "lazy",
            style: L,
            ...d ? {
                "data-object": "image",
                "data-mouse-only": !0
            } : {},
            ...h
        })
    });
_n.displayName = "Image";
const qh = "_listBoxItem_zipky_1",
    Yh = "_langBtn_zipky_23",
    Zh = "_webGLEffect_zipky_54",
    Jh = "_popover_zipky_86",
    Qh = "_listBox_zipky_1",
    xn = {
        listBoxItem: qh,
        langBtn: Yh,
        webGLEffect: Zh,
        popover: Jh,
        listBox: Qh
    },
    Au = ({
        label: n,
        uniqueClassName: e,
        className: t = "",
        popoverClassName: r = "",
        listBoxClassName: i = ""
    }) => {
        var x;
        const {
            locale: o,
            locales: s,
            hreflangs: l
        } = Tn().props, a = c.useRef(null), u = c.useRef(), [d, h] = c.useState(""), D = P => {
            document.documentElement.classList.toggle("overflow-auto", P)
        }, g = P => {
            var L;
            window.location.href = ((L = l.find(R => R.locale_code === P)) == null ? void 0 : L.href) || window.location.href
        };
        return c.useEffect(() => {
            if (o) {
                const P = s.find(R => R.locale === o),
                    L = n === "full" ? P == null ? void 0 : P.name : P == null ? void 0 : P.locale;
                h(L || "")
            }
        }, [o, s, n]), $.jsxs(kh, {
            ref: a,
            className: Ge(xn.langBtn, t, e),
            "aria-label": n === "full" ? (x = s.find(P => P.locale === o)) == null ? void 0 : x.name : o,
            selectedKey: o,
            onSelectionChange: g,
            onOpenChange: D,
            children: [$.jsx("div", {
                onMouseEnter: () => {
                    var P;
                    return (P = u.current) == null ? void 0 : P.scrambleText()
                },
                children: $.jsxs(ih, {
                    children: [$.jsx("div", {
                        className: xn.webGLEffect,
                        children: $.jsx(_n, {
                            src: "/images/dots-header.png",
                            alt: "Dots",
                            height: 80,
                            width: 210
                        })
                    }), $.jsx(Lh, {
                        children: $.jsx(pt, {
                            ref: u,
                            color: "white",
                            className: xn.headerBtnText,
                            children: d
                        })
                    })]
                })
            }), $.jsx(_h, {
                className: Ge(xn.popover, r),
                shouldFlip: !1,
                containerPadding: 0,
                offset: 0,
                UNSTABLE_portalContainer: a.current,
                shouldUpdatePosition: !1,
                children: $.jsx(yh, {
                    "data-lenis-prevent": !0,
                    className: xn.listBox,
                    children: l.map(P => P.locale_code === o ? null : $.jsx(xh, {
                        className: Ge(xn.listBoxItem, i),
                        textValue: n === "full" ? P.locale.native : P.locale_code,
                        id: P.locale_code,
                        children: $.jsx("span", {
                            children: n === "full" ? P.locale.native : P.locale_code
                        })
                    }, P.locale_code))
                })
            })]
        })
    },
    eD = (n, e) => c.createElement("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        width: 24,
        height: 24,
        fill: "none",
        viewBox: "0 0 24 24",
        focusable: "false",
        "aria-hidden": "true",
        ref: e,
        ...n
    }, c.createElement("path", {
        fill: "#fff",
        d: "M6.94 5a2 2 0 1 1-4-.002 2 2 0 0 1 4 .002M7 8.48H3V21h4zm6.32 0H9.34V21h3.94v-6.57c0-3.66 4.77-4 4.77 0V21H22v-7.93c0-6.17-7.06-5.94-8.72-2.91z"
    })),
    Lu = c.forwardRef(eD),
    tD = (n, e) => c.createElement("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        width: 24,
        height: 24,
        fill: "none",
        viewBox: "0 0 24 24",
        focusable: "false",
        "aria-hidden": "true",
        ref: e,
        ...n
    }, c.createElement("path", {
        fill: "#fff",
        d: "M12.244 4c.534.003 1.87.016 3.29.073l.504.022c1.429.067 2.857.183 3.566.38.945.266 1.687 1.04 1.938 2.022.4 1.56.45 4.602.456 5.339l.001.152v.174c-.007.737-.057 3.78-.457 5.339-.254.985-.997 1.76-1.938 2.022-.709.197-2.137.313-3.566.38l-.504.023c-1.42.056-2.756.07-3.29.072l-.235.001h-.255c-1.13-.007-5.856-.058-7.36-.476-.944-.266-1.687-1.04-1.938-2.022-.4-1.56-.45-4.602-.456-5.339v-.326c.006-.737.056-3.78.456-5.339.254-.985.997-1.76 1.939-2.021 1.503-.419 6.23-.47 7.36-.476zM9.999 8.5v7l6-3.5z"
    })),
    Bu = c.forwardRef(tD),
    nD = "_flexWrapper_u89vv_23",
    rD = "_socialLink_u89vv_44",
    iD = "_small_u89vv_52",
    oD = "_langBtn_u89vv_57",
    sD = "_description_u89vv_65",
    mt = {
        flexWrapper: nD,
        socialLink: rD,
        small: iD,
        langBtn: oD,
        description: sD
    },
    lD = ({
        usefulLinks: n
    }) => {
        const {
            t: e
        } = er();
        return $.jsxs("div", {
            className: "hide-desktop",
            children: [$.jsxs("div", {
                className: mt.flexWrapper,
                children: [$.jsx("a", {
                    href: "https://www.linkedin.com/company/neverhack/",
                    target: "_blank",
                    rel: "noopener noreferrer",
                    className: mt.socialLink,
                    children: $.jsx(Lu, {})
                }), $.jsx(Au, {
                    label: "full",
                    className: mt.langBtn,
                    uniqueClassName: "locale-switcher-footer",
                    popoverClassName: mt.popoverHeader
                }), $.jsx("a", {
                    href: "https://www.youtube.com/channel/UCTWlceXeb6kQA4GOjMLCe_w",
                    target: "_blank",
                    rel: "noopener noreferrer",
                    className: mt.socialLink,
                    children: $.jsx(Bu, {})
                })]
            }), $.jsx("div", {
                className: mt.flexWrapper,
                children: $.jsx("p", {
                    className: mt.description,
                    children: e("app.footer.neverhack_description")
                })
            }), $.jsx("div", {
                className: mt.flexWrapper,
                children: n.map((t, r) => $.jsx(_t, {
                    href: t.href,
                    children: t.name
                }, r))
            }), $.jsxs("div", {
                className: mt.flexWrapper,
                children: [$.jsx("a", {
                    className: mt.small,
                    href: "https://neverhack.ethic-channel.com/home?change_language=en",
                    target: "_blank",
                    rel: "noreferrer",
                    children: e("app.footer.whistleblow")
                }), $.jsx(_t, {
                    className: mt.small,
                    href: route("web.legal.notices"),
                    children: e("app.footer.legal_notices")
                }), $.jsx(_t, {
                    className: mt.small,
                    href: route("web.legal.terms.use"),
                    children: e("app.footer.terms_and_conditions")
                })]
            })]
        })
    },
    aD = "_flexWrapper_mz94d_1",
    uD = "_footer_mz94d_23",
    cD = "_topWrapper_mz94d_33",
    dD = "_bottomWrapper_mz94d_54",
    fD = "_lineWrapper_mz94d_59",
    pD = "_bottom_mz94d_54",
    hD = "_top_mz94d_33",
    DD = "_socialLink_mz94d_95",
    vD = "_itemEmpty_mz94d_105",
    gD = "_descriptionWrapper_mz94d_111",
    mD = "_rights_mz94d_124",
    bD = "_credits_mz94d_140",
    yD = "_link_mz94d_156",
    Ue = {
        flexWrapper: aD,
        footer: uD,
        topWrapper: cD,
        bottomWrapper: dD,
        lineWrapper: fD,
        bottom: pD,
        top: hD,
        socialLink: DD,
        itemEmpty: vD,
        descriptionWrapper: gD,
        rights: mD,
        credits: bD,
        link: yD
    },
    ED = () => {
        const {
            t: n
        } = er(), {
            add: e
        } = Cs(), t = c.useRef(null), r = c.useRef(null), i = c.useRef(), o = c.useRef(), s = c.useRef(), l = c.useRef(), a = c.useRef(), u = [{
            name: n("app.footer.presse"),
            href: route("web.press.index")
        }, {
            name: "NAS24 France",
            href: "https://www.google.com"
        }], d = n("app.home.slogan").split(" ");
        return on(() => {
            var h;
            if (r.current && r.current.tl) {
                const D = kn.ScrollTrigger.create({
                    trigger: t.current,
                    start: "top 80%",
                    animation: (h = r.current) == null ? void 0 : h.tl,
                    toggleActions: "play complete none reverse"
                });
                return () => {
                    D == null || D.kill()
                }
            }
        }), $.jsxs("footer", {
            ref: t,
            className: Ue.footer,
            children: [$.jsxs("div", {
                className: Ue.topWrapper,
                children: [$.jsx(Rs, {
                    ref: r,
                    folder: "footer",
                    imagesCount: 59
                }), $.jsxs(bi, {
                    tag: "p",
                    children: [d[0] ? ? "", " ", d[1] ? ? "", $.jsx("br", {}), d[2] ? ? "", $.jsx("br", {}), d[3] ? ? "", $.jsx("br", {})]
                })]
            }), $.jsxs("div", {
                className: Ue.bottomWrapper,
                children: [$.jsx(lD, {
                    usefulLinks: u
                }), $.jsx("div", {
                    className: Ge(Ue.lineWrapper, "hide-mobile-tablet"),
                    children: $.jsxs("div", {
                        className: Ge(Ue.flexWrapper, Ue.top, "container"),
                        children: [$.jsx("a", {
                            href: "https://www.linkedin.com/company/neverhack/",
                            target: "_blank",
                            rel: "noopener noreferrer",
                            className: Ue.socialLink,
                            children: $.jsx(Lu, {})
                        }), $.jsx("a", {
                            href: "https://www.youtube.com/channel/UCTWlceXeb6kQA4GOjMLCe_w",
                            target: "_blank",
                            rel: "noopener noreferrer",
                            className: Ue.socialLink,
                            children: $.jsx(Bu, {})
                        }), $.jsx("div", {
                            ref: e("empty", 0),
                            "data-mouse-only": !0,
                            className: Ue.itemEmpty,
                            "data-object": "grid",
                            "data-config": "footer"
                        }), $.jsx(_t, {
                            href: route("web.press.index"),
                            onMouseEnter: () => {
                                var h;
                                return (h = i.current) == null ? void 0 : h.scrambleText()
                            },
                            children: $.jsx(pt, {
                                ref: i,
                                centered: !0,
                                children: n("app.footer.presse")
                            })
                        }), $.jsx(_t, {
                            href: route("web.research.advise"),
                            onMouseEnter: () => {
                                var h;
                                return (h = o.current) == null ? void 0 : h.scrambleText()
                            },
                            children: $.jsx(pt, {
                                ref: o,
                                centered: !0,
                                children: n("app.footer.research")
                            })
                        })]
                    })
                }), $.jsx("div", {
                    className: Ge(Ue.lineWrapper, "hide-mobile-tablet"),
                    children: $.jsxs("div", {
                        className: Ge(Ue.flexWrapper, Ue.bottom, "container"),
                        children: [$.jsx("div", {
                            className: Ue.descriptionWrapper,
                            children: $.jsx("p", {
                                className: Ue.description,
                                children: n("app.footer.neverhack_description")
                            })
                        }), $.jsx("a", {
                            className: Ue.small,
                            href: "https://neverhack.ethic-channel.com/home?change_language=en",
                            target: "_blank",
                            rel: "noreferrer",
                            onMouseEnter: () => {
                                var h;
                                return (h = s.current) == null ? void 0 : h.scrambleText()
                            },
                            children: $.jsx(pt, {
                                ref: s,
                                centered: !0,
                                children: n("app.footer.whistleblow")
                            })
                        }), $.jsx(_t, {
                            className: Ue.small,
                            href: route("web.legal.notices"),
                            onMouseEnter: () => {
                                var h;
                                return (h = l.current) == null ? void 0 : h.scrambleText()
                            },
                            children: $.jsx(pt, {
                                ref: l,
                                centered: !0,
                                children: n("app.footer.legal_notices")
                            })
                        }), $.jsx(_t, {
                            className: Ue.small,
                            href: route("web.legal.terms.use"),
                            onMouseEnter: () => {
                                var h;
                                return (h = a.current) == null ? void 0 : h.scrambleText()
                            },
                            children: $.jsx(pt, {
                                ref: a,
                                centered: !0,
                                children: n("app.footer.terms_and_conditions")
                            })
                        })]
                    })
                })]
            }), $.jsxs("p", {
                className: Ue.rights,
                children: ["NEVERHACK ©", oc().format("Y"), " ", n("app.footer.neverhack_rights")]
            }), $.jsxs("p", {
                className: Ue.credits,
                children: ["Tailor-made by", " ", $.jsx("a", {
                    className: Ue.link,
                    href: "https://makepill.com/",
                    target: "_blank",
                    rel: "noopener noreferrer",
                    children: "Makepill"
                }), " & ", $.jsx("a", {
                    className: Ue.link,
                    href: "https://60fps.fr/",
                    target: "_blank",
                    rel: "noopener noreferrer",
                    children: "60fps"
                })]
            })]
        })
    },
    Ru = c.createContext({
        menuUseCasesOpen: !1,
        setMenuUseCasesOpen: () => {}
    }),
    CD = ({
        children: n
    }) => {
        const [e, t] = c.useState(!1);
        return $.jsx(Ru.Provider, {
            value: {
                menuUseCasesOpen: e,
                setMenuUseCasesOpen: t
            },
            children: n
        })
    },
    xD = () => c.useContext(Ru),
    $D = (n, e) => {
        const t = c.useRef(!0);
        c.useEffect(() => {
            if (t.current) {
                t.current = !1;
                return
            }
            return n()
        }, e)
    },
    wD = (n, e) => c.createElement("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        width: 20,
        height: 20,
        fill: "none",
        viewBox: "0 0 20 20",
        focusable: "false",
        "aria-hidden": "true",
        ref: e,
        ...n
    }, c.createElement("path", {
        stroke: "currentColor",
        strokeLinecap: "square",
        d: "M15 10.714V5m0 0H9.286M15 5 5 15"
    })),
    Ni = c.forwardRef(wD),
    FD = "_menuMobile_v8y70_23",
    SD = "_menuMobileNav_v8y70_43",
    _D = "_menuItem_v8y70_53",
    PD = "_menuItemLink_v8y70_58",
    TD = "_active_v8y70_68",
    kD = "_withSuperscript_v8y70_72",
    AD = "_superscript_v8y70_77",
    LD = "_arrow_v8y70_112",
    Dt = {
        menuMobile: FD,
        menuMobileNav: SD,
        menuItem: _D,
        menuItemLink: PD,
        active: TD,
        withSuperscript: kD,
        superscript: AD,
        arrow: LD
    },
    BD = ({
        isOpen: n,
        menus: e,
        setMenuOpen: t
    }) => {
        const r = c.useRef(null),
            i = c.useRef(null),
            o = c.useRef(null),
            {
                t: s
            } = er();
        return $D(() => (o.current = Me.timeline(), n ? (o.current.fromTo(r.current, {
            display: "block"
        }, {
            y: 0,
            duration: 1,
            ease: "menuIn"
        }, 0), o.current.to(i.current, {
            y: 0,
            duration: 1,
            ease: "menuIn"
        }, 0)) : (o.current.to(r.current, {
            y: "-100%",
            duration: 1.4,
            ease: "immg.zoomOut",
            display: "none"
        }, 0), o.current.to(i.current, {
            y: "100%",
            duration: 1.4,
            ease: "immg.zoomOut"
        }, 0)), () => {
            var l;
            (l = o.current) == null || l.kill()
        }), [n]), $.jsx("div", {
            ref: r,
            "data-lenis-prevent": !0,
            className: Dt.menuMobile,
            children: $.jsx("nav", {
                ref: i,
                className: Dt.menuMobileNav,
                children: $.jsxs("ol", {
                    children: [e.map(({
                        name: l,
                        href: a,
                        active: u,
                        superscript: d
                    }) => $.jsx("li", {
                        className: Dt.menuItem,
                        children: $.jsx(_t, {
                            prefetch: !0,
                            href: a,
                            className: Ge({
                                [Dt.active]: u
                            }, Dt.menuItemLink),
                            onClick: () => t(!1),
                            children: $.jsxs("p", {
                                className: Ge(d && Dt.withSuperscript),
                                children: [$.jsx("span", {
                                    children: l
                                }), d && $.jsx("span", {
                                    className: Dt.superscript,
                                    children: d
                                })]
                            })
                        })
                    }, l)), $.jsx("li", {
                        className: Dt.menuItem,
                        children: $.jsxs("a", {
                            className: Dt.menuItemLink,
                            target: "_blank",
                            rel: "noopener noreferrer",
                            href: "https://hub.neverhack.com/campaign/gartner",
                            children: ["Gartner Report", $.jsx(Ni, {
                                className: Dt.arrow
                            })]
                        })
                    }), $.jsx("li", {
                        className: Dt.menuItem,
                        children: $.jsxs("a", {
                            className: Dt.menuItemLink,
                            target: "_blank",
                            rel: "noopener noreferrer",
                            href: "https://hub.neverhack.com",
                            children: [s("app.ui.join_hub"), $.jsx(Ni, {
                                className: Dt.arrow
                            })]
                        })
                    })]
                })
            })
        })
    },
    RD = () => {
        const [n, e] = c.useState("mobile");
        return c.useEffect(() => {
            const t = () => {
                const r = ku.find(([, i]) => window.innerWidth >= i);
                e(r ? r[0] : "mobile")
            };
            return window.addEventListener("resize", t), t(), () => window.removeEventListener("resize", t)
        }, []), n
    },
    dn = () => {
        const n = c.useRef([]);
        return [n, t => r => {
            n.current[t] = r
        }]
    },
    MD = "_useCaseLink_11ivc_1",
    ND = "_menuUseCases_11ivc_23",
    ID = "_overlay_11ivc_59",
    KD = "_innerWrapper_11ivc_71",
    OD = "_gridWrapper_11ivc_108",
    jD = "_topWrapperGrid_11ivc_123",
    zD = "_leftWrapperGrid_11ivc_130",
    VD = "_rightWrapperGrid_11ivc_136",
    WD = "_caseGrid_11ivc_149",
    HD = "_bottomWrapperGrid_11ivc_158",
    UD = "_borderBottom_11ivc_172",
    GD = "_borderRight_11ivc_172",
    XD = "_borderCenter_11ivc_172",
    qD = "_borderLeft_11ivc_172",
    YD = "_leftWrapper_11ivc_130",
    ZD = "_contentsWrapper_11ivc_223",
    JD = "_preTitle_11ivc_267",
    QD = "_caseImageWrapper_11ivc_285",
    e0 = "_caseImage_11ivc_285",
    t0 = "_video_11ivc_319",
    n0 = "_rightWrapper_11ivc_136",
    r0 = "_backgroundWrapper_11ivc_343",
    i0 = "_backgroundWrapperBig_11ivc_343",
    o0 = "_useCasesWrapper_11ivc_365",
    s0 = "_number_11ivc_379",
    l0 = "_useCase_11ivc_1",
    a0 = "_active_11ivc_469",
    u0 = "_infos_11ivc_483",
    c0 = "_caseImageWrapperMobile_11ivc_493",
    xe = {
        useCaseLink: MD,
        menuUseCases: ND,
        overlay: ID,
        innerWrapper: KD,
        gridWrapper: OD,
        topWrapperGrid: jD,
        leftWrapperGrid: zD,
        rightWrapperGrid: VD,
        caseGrid: WD,
        bottomWrapperGrid: HD,
        borderBottom: UD,
        borderRight: GD,
        borderCenter: XD,
        borderLeft: qD,
        leftWrapper: YD,
        contentsWrapper: ZD,
        preTitle: JD,
        caseImageWrapper: QD,
        caseImage: e0,
        video: t0,
        rightWrapper: n0,
        backgroundWrapper: r0,
        backgroundWrapperBig: i0,
        useCasesWrapper: o0,
        number: s0,
        useCase: l0,
        active: a0,
        infos: u0,
        caseImageWrapperMobile: c0
    },
    d0 = ({
        isOpen: n,
        setMenuUseCasesOpen: e
    }) => {
        const {
            menuUseCases: t
        } = Tn().props, {
            useCase: r
        } = Tn().props, i = RD(), {
            t: o
        } = er(), s = tr(), l = c.useRef(null), a = c.useRef(null), u = c.useRef(null), d = c.useRef(), h = c.useRef(null), D = c.useRef(null), [g, x] = dn(), [P, L] = dn(), [R, N] = dn(), [S, j] = dn(), [k, B] = dn(), [M, f] = dn(), [I, O] = dn(), [T, K] = c.useState(t.at(0)), m = c.useRef(null), p = E => {
            const H = a.current;
            Me.context(() => {
                const X = Me.timeline();
                n ? (s == null || s.stop(), X.from(l.current, {
                    display: "block",
                    opacity: 0,
                    ease: "linear",
                    duration: 1.1
                }, 0), d.current && (X.from(d.current.el, {
                    opacity: 0,
                    ease: "linear",
                    duration: .9
                }, .8), X.add(() => {
                    var q;
                    return (q = d.current) == null ? void 0 : q.scrambleText()
                }, .8)), m.current = new Xn.SplitText(h.current, {
                    type: "lines"
                }), X.from(m.current.lines, {
                    y: "100%",
                    ease: "power3.out",
                    duration: 1,
                    stagger: .1
                }, .8), X.from(h.current, {
                    opacity: 0,
                    duration: .9,
                    ease: "linear"
                }, .8), X.to(H, {
                    y: 0,
                    duration: 1,
                    ease: "menuIn"
                }, 0), X.to(u.current, {
                    y: 0,
                    duration: 1,
                    ease: "menuIn"
                }, 0), i !== "mobile" && i !== "tablet" && i !== "desktop" && (X.fromTo(P.current, {
                    scaleY: 0
                }, {
                    scaleY: 1,
                    duration: 1.4,
                    ease: "immg.zoomOut",
                    stagger: .02
                }, .2), X.fromTo(R.current, {
                    scaleX: 0
                }, {
                    scaleX: 1,
                    duration: 1.4,
                    ease: "immg.zoomOut",
                    stagger: .04
                }, .2)), X.to(M.current, {
                    scaleX: 0,
                    stagger: .06,
                    duration: 1.1,
                    ease: "immg.zoomOut"
                }, .5), X.from(D.current, {
                    scale: 1.05,
                    duration: 1,
                    ease: "immg.zoomOut"
                }, .9), X.from(D.current, {
                    opacity: 0,
                    duration: .7,
                    ease: "linear"
                }, 1), X.from(g.current, {
                    opacity: 0,
                    duration: .3,
                    ease: "linear"
                }, .7), S.current.forEach((q, G) => {
                    X.add(() => q.scrambleText(), 1 + G * .06)
                }), X.from(I.current, {
                    opacity: 0,
                    duration: 1.1,
                    ease: "linear",
                    stagger: .05
                }, 1.1)) : (X.set(l.current, {
                    display: "none"
                }, 0), X.to(H, {
                    y: "-100%",
                    duration: .6,
                    ease: "immg.zoomOut"
                }, 0), X.to(u.current, {
                    y: "100%",
                    duration: .6,
                    ease: "immg.zoomOut"
                }, 0), X.call(() => s == null ? void 0 : s.start())), X.call(E)
            }, H)
        }, w = c.useRef(() => {}), C = () => {
            var X;
            const E = t.findIndex(q => q === T);
            k.current[E] && ((X = S.current[E]) == null || X.scrambleText()), Me.context(() => {
                const q = Me.timeline();
                q.from(D.current, {
                    scale: .94,
                    duration: .6,
                    ease: "immg.zoomOut"
                }, 0), q.fromTo(D.current, {
                    opacity: 0
                }, {
                    opacity: 1,
                    duration: .3
                }, 0), q.call(w.current)
            }, D.current)
        }, A = () => {
            Me.context(() => {
                const E = Me.timeline();
                E.to(D.current, {
                    scale: 1.02,
                    duration: .3,
                    ease: "immg.zoomOut"
                }, 0), E.to(D.current, {
                    opacity: 0,
                    duration: .2
                }, 0), E.call(w.current)
            }, D.current)
        };
        return $.jsx(Et, {
            mountOnEnter: !0,
            unmountOnExit: !0,
            nodeRef: a,
            in: n,
            timeout: 800,
            addEndListener: p,
            children: $.jsxs(to, {
                contain: !0,
                restoreFocus: !0,
                autoFocus: !0,
                children: [$.jsx("div", {
                    ref: l,
                    className: xe.overlay
                }), $.jsx("div", {
                    ref: a,
                    "data-lenis-prevent": !0,
                    className: xe.menuUseCases,
                    children: $.jsxs("div", {
                        ref: u,
                        className: xe.innerWrapper,
                        children: [$.jsxs("div", {
                            className: xe.leftWrapper,
                            children: [$.jsxs("div", {
                                className: xe.contentsWrapper,
                                children: [$.jsx(pt, {
                                    ref: d,
                                    uppercase: !0,
                                    className: xe.preTitle,
                                    timescale: .8,
                                    children: o("app.menu.usecase_pretitle")
                                }), $.jsx("h2", {
                                    ref: h,
                                    children: o("app.menu.usecase_title")
                                }), $.jsx("div", {
                                    ref: f(0),
                                    className: "rect-anim"
                                })]
                            }), $.jsxs("div", {
                                className: xe.caseImageWrapper,
                                children: [$.jsx(Br, {
                                    children: $.jsx(Et, {
                                        nodeRef: D,
                                        timeout: 100,
                                        addEndListener: E => w.current = E,
                                        onEnter: C,
                                        onExit: A,
                                        children: $.jsx("div", {
                                            ref: D,
                                            className: xe.caseImage,
                                            children: $.jsx(bo, {
                                                formats: ["webm", "mov"],
                                                folder: "usecases",
                                                className: xe.video,
                                                videoId: T.video_id,
                                                alpha: !0
                                            })
                                        })
                                    }, T.video_id)
                                }), $.jsx("div", {
                                    ref: f(1),
                                    className: "rect-anim"
                                })]
                            }), $.jsx("div", {
                                ref: x(0),
                                className: xe.backgroundWrapperBig
                            })]
                        }), $.jsxs("div", {
                            className: xe.rightWrapper,
                            children: [$.jsx("div", {
                                className: xe.useCasesWrapper,
                                children: t.map((E, H) => $.jsxs(_t, {
                                    ref: B(H),
                                    href: route("web.use-cases.single", E.slug),
                                    className: Ge(xe.useCaseLink, {
                                        [xe.active]: r && E.slug === r.slug
                                    }),
                                    onMouseEnter: () => K(E),
                                    onClick: () => e(!1),
                                    children: [$.jsx(bo, {
                                        formats: ["webm", "mov"],
                                        folder: "usecases",
                                        videoId: E.video_id,
                                        className: xe.caseImageWrapperMobile
                                    }), $.jsxs("div", {
                                        ref: O(H),
                                        className: xe.infos,
                                        children: [$.jsx(pt, {
                                            ref: j(H),
                                            uppercase: !0,
                                            className: xe.number,
                                            children: "/ " + E.reference
                                        }), $.jsx("span", {
                                            className: xe.useCase,
                                            children: E.short_title
                                        })]
                                    }), $.jsx("div", {
                                        ref: f(H + 2),
                                        className: "rect-anim"
                                    })]
                                }, H))
                            }), $.jsx("div", {
                                ref: x(1),
                                className: xe.backgroundWrapper
                            })]
                        }), $.jsxs("div", {
                            className: xe.gridWrapper,
                            children: [$.jsx("div", {
                                ref: L(0),
                                className: xe.borderLeft
                            }), $.jsx("div", {
                                ref: L(1),
                                className: xe.borderRight
                            }), $.jsx("div", {
                                className: xe.topWrapperGrid,
                                children: $.jsx("div", {
                                    ref: N(1),
                                    className: xe.borderBottom
                                })
                            }), $.jsx("div", {
                                className: xe.leftWrapperGrid,
                                children: $.jsx("div", {
                                    ref: L(2),
                                    className: xe.borderRight
                                })
                            }), $.jsxs("div", {
                                className: xe.rightWrapperGrid,
                                children: [$.jsx("div", {
                                    ref: L(3),
                                    className: xe.borderCenter
                                }), t.slice(0, t.length / 2).map((E, H) => $.jsx("div", {
                                    className: xe.caseGrid,
                                    children: $.jsx("div", {
                                        ref: N(H + 2),
                                        className: xe.borderBottom
                                    })
                                }, H))]
                            }), $.jsx("div", {
                                className: xe.bottomWrapperGrid,
                                children: $.jsx("div", {
                                    ref: N(t.length / 2 + 1),
                                    className: xe.borderBottom
                                })
                            })]
                        })]
                    })
                })]
            })
        })
    },
    f0 = (n, e) => c.createElement("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        width: 20,
        height: 20,
        fill: "none",
        viewBox: "0 0 20 20",
        focusable: "false",
        "aria-hidden": "true",
        ref: e,
        ...n
    }, c.createElement("path", {
        stroke: "#fff",
        strokeLinecap: "square",
        strokeLinejoin: "round",
        d: "M1 13h18M1 7h18"
    })),
    p0 = c.forwardRef(f0),
    h0 = (n, e) => c.createElement("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        width: 20,
        height: 20,
        fill: "none",
        viewBox: "0 0 20 20",
        focusable: "false",
        "aria-hidden": "true",
        ref: e,
        ...n
    }, c.createElement("path", {
        stroke: "currentColor",
        strokeLinecap: "square",
        strokeLinejoin: "round",
        d: "m13.999 14.06-3.97-4.03m0 0L6.059 6m3.97 4.03 4.03-3.97m-4.03 3.97L5.999 14"
    })),
    ms = c.forwardRef(h0),
    D0 = (n, e) => c.createElement("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        width: 136,
        height: 24,
        fill: "none",
        viewBox: "0 0 136 24",
        focusable: "false",
        "aria-hidden": "true",
        ref: e,
        ...n
    }, c.createElement("path", {
        fill: "#fff",
        d: "M24.518 0H16.96c-.24 0-.401.16-.401.32v8.237c0 .16-.161.24-.242.08L7.315.08c0-.08-.08-.08-.16-.08H.401C.16 0 0 .16 0 .32v6.558c0 .08 0 .16.08.16l17.525 16.874c0 .08.08.08.16.08h6.833c.241 0 .402-.16.402-.4V.32c-.08-.16-.241-.32-.482-.32M7.958 16.003H.402c-.241 0-.402.16-.402.32V23.6c0 .24.16.4.402.4h7.556c.241 0 .402-.16.402-.32v-7.277c0-.24-.241-.4-.402-.4M37 6h1.518l5.913 8.88-.08-.8V6h1.599v11.52h-1.52l-5.913-8.88.08.8v8.08H37zm11.35 0h7.75v1.44h-6.152v3.76h5.274v1.2h-5.274v3.76h6.153v1.44H48.35zm10.144 0h1.678l3.037 8.72.16.8.16-.8L66.564 6h1.758l-3.996 11.52H62.57zM70.64 6h7.75v1.44h-6.152v3.76h5.274v1.2h-5.274v3.76h6.153v1.44H70.64zm15.264 0c1.199 0 2.158.32 2.717.88.64.56.959 1.44.959 2.56 0 .88-.24 1.6-.64 2.08-.399.48-1.038.88-1.837 1.04l2.717 4.96h-1.838l-2.557-4.72h-3.037v4.72H80.79V6zm-.24 5.44c.64 0 1.199-.16 1.599-.56.4-.32.639-.88.639-1.52s-.16-1.12-.56-1.52q-.599-.48-1.678-.48h-3.356v4h3.356zM92.216 6h1.598v5.12h5.833V6h1.599v11.52h-1.599v-5.04h-5.833v5.04h-1.598zm21.251 11.52h-1.758l-3.037-8.72-.16-.8-.159.8-3.037 8.72h-1.758L107.554 6h1.757zm7.115.48c-.958 0-1.758-.16-2.477-.48a3.7 3.7 0 0 1-1.678-1.44c-.399-.64-.559-1.36-.559-2.24v-3.68c0-.88.16-1.6.559-2.24q.6-.96 1.678-1.44c.719-.32 1.519-.48 2.477-.48.879 0 1.678.16 2.398.4.639.32 1.198.72 1.598 1.2.399.56.639 1.12.719 1.92h-1.598A2.78 2.78 0 0 0 122.74 8c-.559-.4-1.199-.56-2.078-.56-.559 0-1.118.08-1.598.32-.479.24-.879.56-1.118.96s-.4.88-.4 1.44v3.68c0 .56.16 1.04.4 1.44.239.4.639.72 1.118.96s1.039.32 1.598.32c.879 0 1.598-.16 2.078-.56q.839-.6.959-1.68h1.598c-.08 1.12-.559 2.08-1.359 2.72q-1.318.96-3.356.96m8.626-12v5.04L133.843 6h1.997l-5.274 5.76L136 17.6h-2.157l-4.715-5.04v5.04h-1.598V6z"
    })),
    v0 = c.forwardRef(D0),
    g0 = (n, e) => c.createElement("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        width: 14,
        height: 14,
        fill: "none",
        viewBox: "0 0 14 14",
        focusable: "false",
        "aria-hidden": "true",
        ref: e,
        ...n
    }, c.createElement("path", {
        fill: "currentColor",
        d: "M0 0h2v2H0z",
        opacity: .991
    }), c.createElement("path", {
        fill: "currentColor",
        d: "M6 0h2v2H6z",
        opacity: .992
    }), c.createElement("path", {
        fill: "currentColor",
        d: "M12 0h2v2h-2z",
        opacity: .993
    }), c.createElement("path", {
        fill: "currentColor",
        d: "M0 6h2v2H0z",
        opacity: .994
    }), c.createElement("path", {
        fill: "currentColor",
        d: "M6 6h2v2H6z",
        opacity: .995
    }), c.createElement("path", {
        fill: "currentColor",
        d: "M12 6h2v2h-2z",
        opacity: .996
    }), c.createElement("path", {
        fill: "currentColor",
        d: "M0 12h2v2H0z",
        opacity: .997
    }), c.createElement("path", {
        fill: "currentColor",
        d: "M6 12h2v2H6z",
        opacity: .998
    }), c.createElement("path", {
        fill: "currentColor",
        d: "M12 12h2v2h-2z",
        opacity: .999
    })),
    m0 = c.forwardRef(g0),
    b0 = (n, e) => c.createElement("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        width: 14,
        height: 14,
        fill: "none",
        viewBox: "0 0 14 14",
        focusable: "false",
        "aria-hidden": "true",
        ref: e,
        ...n
    }, c.createElement("path", {
        fill: "#fff",
        fillOpacity: .75,
        d: "M.583 6.417A5.833 5.833 0 0 0 6.417.583h1.166a5.833 5.833 0 0 0 5.834 5.834v1.166a5.833 5.833 0 0 0-5.834 5.834H6.417A5.833 5.833 0 0 0 .583 7.583zM3.385 7A7.03 7.03 0 0 1 7 10.615 7.03 7.03 0 0 1 10.615 7 7.03 7.03 0 0 1 7 3.385 7.03 7.03 0 0 1 3.385 7"
    })),
    y0 = c.forwardRef(b0),
    E0 = "_menuBtn_gv9a5_1",
    C0 = "_header_gv9a5_23",
    x0 = "_bannerClosed_gv9a5_35",
    $0 = "_webGLEffect_gv9a5_40",
    w0 = "_banner_gv9a5_35",
    F0 = "_itemsWrapper_gv9a5_95",
    S0 = "_iconCross_gv9a5_114",
    _0 = "_burger_gv9a5_121",
    P0 = "_squareDot_gv9a5_126",
    T0 = "_mobileRightWrapper_gv9a5_144",
    k0 = "_active_gv9a5_149",
    A0 = "_gartnerButton_gv9a5_153",
    L0 = "_hubBtn_gv9a5_153",
    B0 = "_headerNav_gv9a5_153",
    R0 = "_caseBtn_gv9a5_153",
    M0 = "_logoWrapper_gv9a5_153",
    N0 = "_headerBtnText_gv9a5_173",
    I0 = "_logo_gv9a5_153",
    K0 = "_disabled_gv9a5_246",
    O0 = "_useCaseIconWrapper_gv9a5_285",
    j0 = "_headerNavOl_gv9a5_312",
    z0 = "_headerNavText_gv9a5_338",
    V0 = "_arrow_gv9a5_419",
    W0 = "_withSuperscript_gv9a5_433",
    H0 = "_superscript_gv9a5_448",
    U0 = "_langBtnHeader_gv9a5_455",
    G0 = "_menuCaseOpen_gv9a5_497",
    X0 = "_menuMbOpen_gv9a5_528",
    Ce = {
        menuBtn: E0,
        header: C0,
        bannerClosed: x0,
        webGLEffect: $0,
        banner: w0,
        itemsWrapper: F0,
        iconCross: S0,
        burger: _0,
        squareDot: P0,
        mobileRightWrapper: T0,
        active: k0,
        gartnerButton: A0,
        hubBtn: L0,
        headerNav: B0,
        caseBtn: R0,
        logoWrapper: M0,
        headerBtnText: N0,
        logo: I0,
        disabled: K0,
        useCaseIconWrapper: O0,
        headerNavOl: j0,
        headerNavText: z0,
        arrow: V0,
        withSuperscript: W0,
        superscript: H0,
        langBtnHeader: U0,
        menuCaseOpen: G0,
        menuMbOpen: X0
    },
    q0 = () => {
        const {
            menu: n,
            offersCount: e
        } = Tn().props, {
            banner: t
        } = Tn().props, [r, i] = c.useState(t === null), [o, s] = c.useState(!1), [l, a] = c.useState(!1), {
            menuUseCasesOpen: u,
            setMenuUseCasesOpen: d
        } = xD(), {
            t: h
        } = er(), D = tr(), g = c.useRef(null), x = c.useRef(), P = c.useRef(), L = c.useRef(), R = c.useRef(null);
        let N = null;
        const S = [{
            name: h("app.menu.home"),
            href: route("web.index"),
            active: n === "home",
            superscript: ""
        }, {
            name: h("app.menu.offers"),
            href: route("web.offers.index"),
            active: n === "offers",
            superscript: e ? ? ""
        }, {
            name: h("app.menu.about"),
            href: route("web.about.index"),
            active: n === "about",
            superscript: ""
        }, {
            name: h("app.menu.careers"),
            href: route("web.careers.recruitment"),
            active: n === "careers",
            superscript: ""
        }, {
            name: h("app.menu.jobs"),
            href: route("web.careers.index"),
            active: n === "jobs",
            superscript: ""
        }, {
            name: h("app.menu.news"),
            href: route("web.news.index"),
            active: n === "news",
            superscript: ""
        }, {
            name: h("app.menu.contact"),
            href: route("web.contact.index"),
            active: n === "contact",
            superscript: ""
        }];
        c.useEffect(() => {
            o ? D == null || D.stop() : D == null || D.start()
        }, [o, D]), c.useEffect(() => {
            u ? i(!0) : (D == null ? void 0 : D.actualScroll) < 100 && t && i(!1);
            const B = M => {
                M.key === "Escape" && u && d(!1)
            };
            return window.addEventListener("keyup", B), () => window.removeEventListener("keyup", B)
        }, [u, D, d, t]), on(() => {
            var B, M;
            N = ((B = g.current) == null ? void 0 : B.querySelectorAll("path")) || null, N && ((M = R.current) == null || M.kill(), R.current = Me.timeline({
                repeat: -1,
                yoyo: !0
            }), R.current.fromTo(N, {
                opacity: .35
            }, {
                opacity: .8,
                duration: .8,
                stagger: {
                    each: .8,
                    amount: 1,
                    grid: "auto",
                    ease: "linear",
                    from: "random"
                }
            }))
        }, [g]);
        const j = B => {
                var M, f, I;
                B.type === "mouseenter" ? ((M = R.current) == null || M.timeScale(2), (f = x.current) == null || f.scrambleText()) : (I = R.current) == null || I.timeScale(1)
            },
            k = () => {
                a(!0), d(!u), setTimeout(() => {
                    a(!1)
                }, u ? 500 : 800)
            };
        return c.useEffect(() => {
            if (t) {
                const B = () => {
                    Math.abs(D == null ? void 0 : D.actualScroll) < 100 ? i(!1) : i(!0)
                };
                return window.addEventListener("scroll", B), () => window.removeEventListener("scroll", B)
            } else i(!0)
        }, [t, D, n]), $.jsxs($.Fragment, {
            children: [$.jsx(d0, {
                isOpen: u,
                setMenuUseCasesOpen: d
            }), $.jsx(BD, {
                isOpen: o,
                menus: S,
                setMenuOpen: s
            }), $.jsxs("header", {
                className: Ge(Ce.header, {
                    [Ce.menuMbOpen]: o,
                    [Ce.menuCaseOpen]: u,
                    [Ce.bannerClosed]: r || n !== "home"
                }),
                children: [t && $.jsxs("div", {
                    className: Ce.banner,
                    children: [$.jsx(y0, {}), $.jsx("p", {
                        children: t.content
                    }), t.cta_link && t.cta_label && $.jsxs("a", {
                        href: t.cta_link,
                        children: [t.cta_label, " →"]
                    })]
                }), $.jsxs("div", {
                    className: Ce.itemsWrapper,
                    children: [$.jsxs(_t, {
                        prefetch: !0,
                        href: "/",
                        className: Ce.logoWrapper,
                        children: [$.jsx("div", {
                            className: Ce.webGLEffect,
                            children: $.jsx(_n, {
                                src: "/images/dots-header.png",
                                alt: "Dots",
                                height: 80,
                                width: 210
                            })
                        }), $.jsx(v0, {
                            className: Ce.logo
                        })]
                    }), $.jsxs("div", {
                        className: Ce.mobileRightWrapper,
                        children: [$.jsxs("button", {
                            className: Ge(Ce.caseBtn, {
                                [Ce.disabled]: l
                            }),
                            type: "button",
                            onClick: () => k(),
                            onMouseEnter: j,
                            onMouseLeave: j,
                            children: [$.jsx("div", {
                                className: Ce.webGLEffect,
                                children: $.jsx(_n, {
                                    src: "/images/dots-header.png",
                                    alt: "Dots",
                                    height: 80,
                                    width: 210
                                })
                            }), $.jsx(pt, {
                                ref: x,
                                className: Ce.headerBtnText,
                                children: h("app.menu.usecase")
                            }), $.jsxs("div", {
                                className: Ce.useCaseIconWrapper,
                                children: [$.jsx(m0, {
                                    ref: g,
                                    className: Ce.squareDot
                                }), $.jsx(ms, {
                                    className: Ce.iconCross
                                })]
                            })]
                        }), $.jsx(Au, {
                            label: "short",
                            className: Ge(Ce.langBtnHeader, "hide-desktop"),
                            uniqueClassName: "locale-switcher-header-mobile"
                        }), $.jsxs("button", {
                            type: "button",
                            className: Ce.menuBtn,
                            onClick: () => {
                                u && d(!1), s(B => !B)
                            },
                            children: [$.jsx(p0, {
                                className: Ce.burger
                            }), $.jsx(ms, {
                                className: Ce.iconCross
                            })]
                        })]
                    }), $.jsx("nav", {
                        className: Ce.headerNav,
                        children: $.jsx("ol", {
                            className: Ce.headerNavOl,
                            children: S.map(({
                                name: B,
                                href: M,
                                active: f,
                                superscript: I
                            }) => $.jsx("li", {
                                children: $.jsxs(_t, {
                                    prefetch: !0,
                                    href: M,
                                    className: Ge({
                                        [Ce.active]: f,
                                        [Ce.withSuperscript]: I
                                    }, Ce.headerNavText),
                                    children: [$.jsx(pt, {
                                        color: "white",
                                        onHover: !0,
                                        children: B
                                    }), I && $.jsx("span", {
                                        className: Ce.superscript,
                                        children: String(I)
                                    })]
                                })
                            }, B))
                        })
                    }), $.jsxs("a", {
                        className: Ce.gartnerButton,
                        target: "_blank",
                        rel: "noopener noreferrer",
                        href: "https://hub.neverhack.com/campaign/gartner",
                        onMouseEnter: () => {
                            var B;
                            return (B = L.current) == null ? void 0 : B.scrambleText()
                        },
                        children: [$.jsx("div", {
                            className: Ce.webGLEffect,
                            children: $.jsx(_n, {
                                src: "/images/dots-header.png",
                                alt: "Dots",
                                height: 80,
                                width: 210
                            })
                        }), $.jsx(pt, {
                            ref: L,
                            color: "white",
                            className: Ce.headerBtnText,
                            children: "Gartner Report"
                        })]
                    }), $.jsxs("a", {
                        className: Ce.hubBtn,
                        target: "_blank",
                        rel: "noopener noreferrer",
                        href: "https://hub.neverhack.com",
                        onMouseEnter: () => {
                            var B;
                            return (B = P.current) == null ? void 0 : B.scrambleText()
                        },
                        children: [$.jsx("div", {
                            className: Ce.webGLEffect,
                            children: $.jsx(_n, {
                                src: "/images/dots-header.png",
                                alt: "Dots",
                                height: 80,
                                width: 210
                            })
                        }), $.jsx(pt, {
                            ref: P,
                            color: "white",
                            className: Ce.headerBtnText,
                            children: h("app.ui.join_hub")
                        }), $.jsx(Ni, {
                            className: Ce.arrow
                        })]
                    })]
                })]
            })]
        })
    },
    Y0 = "_animatedBackground_1egcf_1",
    Z0 = "_buttonWrapper_1egcf_23",
    J0 = "_withIcon_1egcf_39",
    Q0 = "_primary_1egcf_43",
    ev = "_secondary_1egcf_54",
    tv = "_tertiary_1egcf_68",
    nv = "_quaternary_1egcf_94",
    rv = "_quinary_1egcf_107",
    yr = {
        animatedBackground: Y0,
        buttonWrapper: Z0,
        withIcon: J0,
        primary: Q0,
        secondary: ev,
        tertiary: tv,
        quaternary: nv,
        quinary: rv
    },
    iv = "_closing_1c5xi_60",
    ov = "_modalOverlay_1c5xi_64",
    sv = "_modalContent_1c5xi_80",
    lv = "_preHeader_1c5xi_94",
    av = "_header_1c5xi_112",
    uv = "_modalBody_1c5xi_129",
    cv = "_modalFooter_1c5xi_135",
    en = {
        closing: iv,
        modalOverlay: ov,
        modalContent: sv,
        preHeader: lv,
        header: av,
        modalBody: uv,
        modalFooter: cv
    },
    bs = "CampaignDialog",
    ys = "campaignDialogClosed",
    dv = () => {
        const {
            modal: n,
            setModal: e
        } = Uc(), [t, r] = c.useState(!1), i = () => {
            r(!0), setTimeout(() => {
                sessionStorage.setItem(ys, "true"), e(!1)
            }, 400)
        };
        c.useEffect(() => {
            const a = u => {
                u.key === "Escape" && i()
            };
            return window.addEventListener("keydown", a), () => {
                window.removeEventListener("keydown", a)
            }
        });
        const o = `${en.modalOverlay} ${t?en.closing:""}`,
            s = `${en.modalContent} ${t?en.closing:""}`,
            l = c.useRef();
        return c.useEffect(() => {
            const a = sessionStorage.getItem(ys);
            if (n || a) return;
            const u = () => {
                    e(bs)
                },
                d = Math.random() * 5e3 + 5e3,
                h = setTimeout(u, d),
                D = () => {
                    window.scrollY >= 1e3 && u()
                };
            return window.addEventListener("scroll", D, {
                passive: !0
            }), () => {
                clearTimeout(h), window.removeEventListener("scroll", D)
            }
        }, [n, e]), n !== bs ? null : $.jsx("div", {
            className: o,
            onClick: i,
            children: $.jsxs("div", {
                className: s,
                onClick: a => a.stopPropagation(),
                children: [$.jsxs("div", {
                    className: en.modalBody,
                    children: [$.jsx(pt, {
                        ref: l,
                        className: en.preHeader,
                        onHover: !0,
                        children: "_GARTNER_REPORT"
                    }), $.jsxs(bi, {
                        className: en.header,
                        children: ["Get the latest Gartner", $.jsx("sup", {
                            children: "®"
                        }), " report"]
                    }), $.jsx(bi, {
                        children: "Gartner's latest report, Top Trends in Cybersecurity for 2025, is essential reading for CISOs and cybersecurity leaders looking to future-proof their strategy."
                    })]
                }), $.jsxs("div", {
                    className: en.modalFooter,
                    children: [$.jsx("button", {
                        className: Ge(yr.buttonWrapper, yr.primary, "plausible-event-name=CampaignDialogGartner+Open"),
                        type: "button",
                        onClick: () => {
                            i(), window.open("https://hub.neverhack.com/campaign/gartner", "_blank")
                        },
                        children: "Download report"
                    }), $.jsx("button", {
                        className: Ge(yr.buttonWrapper, yr.secondary, "plausible-event-name=CampaignDialogGartner+Close"),
                        type: "button",
                        onClick: () => i(),
                        children: "I'm not interested"
                    })]
                })]
            })
        })
    },
    fv = "_Wrapper_p0de2_23",
    pv = {
        Wrapper: fv
    },
    hv = () => {
        const n = c.useRef(null);
        return tr(e => {
            cn.state.emit(Mn.SCROLL, e.scroll)
        }), c.useEffect(() => ((async () => {
            var t;
            n.current && (await cn.init(n.current, document.body), cn.state.emit(Mn.ATTACH), cn.state.emit(Mn.RESIZE, (t = cn.tools) == null ? void 0 : t.viewport.infos))
        })(), () => {
            cn.state.emit(Mn.DETACH), cn.state.emit(Mn.DESTROY)
        }), []), $.jsx("div", {
            ref: n,
            className: pv.Wrapper
        })
    },
    Dv = Cr.visit;
Cr.visit = function(n, e) {
    return Dv.apply(Cr, [n, { ...e,
        preserveScroll: !0
    }])
};
const Es = 550,
    vv = () => {},
    gv = ({
        children: n
    }) => {
        const e = c.useRef(null),
            [t, r] = c.useState(!1),
            [i, o] = c.useState(!1),
            s = Tn(),
            l = tr(),
            a = c.useRef(null),
            u = c.useRef(vv),
            [d, h] = c.useState("hidden"),
            D = () => {
                t ? setTimeout(() => window.scrollTo(window.history.state.documentScrollPosition), 30) : (o(!1), window.scrollTo(0, 0)), l == null || l.start(), kn.ScrollTrigger.refresh()
            },
            g = () => {
                var P;
                (P = u.current) == null || P.call(u), t || o(!0), l == null || l.stop()
            },
            x = () => {
                u.current = sc()
            };
        return c.useEffect(() => {
            const P = () => r(!0);
            window.addEventListener("popstate", P);
            const L = Cr.on("start", () => r(!1));
            return h(void 0), () => {
                window.removeEventListener("popstate", P), L()
            }
        }, []), $.jsxs(Hc, {
            children: [$.jsx(ic, {}), $.jsx(Wc, {
                children: $.jsx(CD, {
                    children: $.jsxs("div", {
                        ref: a,
                        children: [$.jsx(Vc, {}), $.jsx(q0, {}), $.jsx(hv, {}), $.jsx(Br, {
                            children: $.jsx(Oi, {
                                appear: !0,
                                unmountOnExit: !0,
                                nodeRef: e,
                                classNames: "fade",
                                timeout: t ? 0 : Es,
                                onEntering: D,
                                onEntered: x,
                                onExit: g,
                                children: $.jsxs("main", {
                                    ref: e,
                                    style: {
                                        visibility: d
                                    },
                                    children: [n, $.jsx(dv, {})]
                                })
                            }, s.props.ziggy.location)
                        }), $.jsx(ED, {}), $.jsx(Nc, {
                            isOpen: i,
                            duration: Es
                        })]
                    })
                })
            })]
        })
    },
    mv = "Neverhack";
Hu({
    title: n => `${n} - ${mv}`,
    resolve: async n => {
        const e = await Uu(`./pages/${n}.tsx`, Object.assign({
            "./pages/About/Index.tsx": () => fe(() =>
                import ("./Index-BxiFpJdy.js"), __vite__mapDeps([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35])),
            "./pages/About/components/Timeline.tsx": () => fe(() =>
                import ("./Timeline-DenWUXG4.js"), __vite__mapDeps([17, 1, 4, 5, 7, 18, 19, 20, 21, 22, 23, 24, 25, 26, 2, 27, 28])),
            "./pages/About/components/Vision.tsx": () => fe(() =>
                import ("./Vision-ykAEJzlT.js"), __vite__mapDeps([29, 1, 4, 7, 5, 18, 19, 20, 21, 22, 23, 24, 25, 26, 2, 27, 30])),
            "./pages/Careers/Index.tsx": () => fe(() =>
                import ("./Index-Bc3r_PC5.js"), __vite__mapDeps([36, 1, 4, 7, 5, 2, 37, 9, 38, 32, 33, 39, 40, 41, 42, 43, 44, 45, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 46])),
            "./pages/Careers/Recruitment.tsx": () => fe(() =>
                import ("./Recruitment-NDge1QAe.js"), __vite__mapDeps([47, 1, 4, 7, 5, 2, 13, 6, 8, 9, 48, 45, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 49, 50, 51, 52])),
            "./pages/Careers/Single.tsx": () => fe(() =>
                import ("./Single-RMu6RNvg.js"), __vite__mapDeps([53, 1, 4, 7, 5, 2, 9, 39, 40, 48, 45, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 49, 54, 55, 12, 13, 14, 32, 33, 56, 57])),
            "./pages/Careers/components/JobProcess.tsx": () => fe(() =>
                import ("./JobProcess-Cr9hsEdo.js"), __vite__mapDeps([48, 1, 4, 5, 7, 2, 9, 45, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 49])),
            "./pages/Careers/components/JobsRoles.tsx": () => fe(() =>
                import ("./JobsRoles-B528G8kh.js"), __vite__mapDeps([50, 1, 4, 5, 7, 2, 9, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 51])),
            "./pages/Careers/components/OtherJobs.tsx": () => fe(() =>
                import ("./OtherJobs-CcvfsEnV.js"), __vite__mapDeps([54, 1, 2, 55, 4, 12, 13, 14, 5, 7, 32, 9, 33, 56, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27])),
            "./pages/Contact/Index.tsx": () => fe(() =>
                import ("./Index-BsLmuUkW.js"), __vite__mapDeps([58, 1, 7, 4, 5, 2, 6, 8, 39, 40, 59, 60, 61, 9, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 62, 63, 12, 13, 14, 64, 65])),
            "./pages/Contact/components/ContactForm.tsx": () => fe(() =>
                import ("./ContactForm-CAlW6kkj.js"), __vite__mapDeps([59, 1, 4, 7, 5, 2, 60, 61, 9, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 62])),
            "./pages/Contact/components/ContactOffices.tsx": () => fe(() =>
                import ("./ContactOffices-DhYO_XEA.js"), __vite__mapDeps([63, 1, 4, 12, 13, 14, 2, 7, 5, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 64])),
            "./pages/Events/Single.tsx": () => fe(() =>
                import ("./Single-CM0zR9Qk.js"), __vite__mapDeps([66, 1, 4, 7, 5, 2, 11, 12, 13, 14, 15, 16, 39, 40, 67, 60, 61, 9, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 68, 69, 45, 70, 71, 72, 73, 74, 75, 76, 77, 78, 55, 32, 33, 56, 79])),
            "./pages/Events/components/EventForm.tsx": () => fe(() =>
                import ("./EventForm-CfQJCPC9.js"), __vite__mapDeps([67, 1, 4, 2, 60, 61, 9, 7, 5, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 68])),
            "./pages/Events/components/Guests.tsx": () => fe(() =>
                import ("./Guests-WMGdaDfz.js"), __vite__mapDeps([69, 1, 4, 2, 45, 18, 19, 20, 21, 22, 23, 24, 5, 7, 25, 26, 27, 70])),
            "./pages/Events/components/MediasGallery.tsx": () => fe(() =>
                import ("./MediasGallery-Dlw_58fQ.js"), __vite__mapDeps([71, 1, 4, 2, 18, 19, 20, 21, 22, 23, 24, 5, 7, 25, 26, 27, 72])),
            "./pages/Events/components/Partners.tsx": () => fe(() =>
                import ("./Partners-CS4TQwxV.js"), __vite__mapDeps([73, 1, 74, 4, 2, 7, 5, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 75])),
            "./pages/Home/Index.tsx": () => fe(() =>
                import ("./Index-BeFiUfOT.js"), __vite__mapDeps([80, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 81, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 82, 83, 84, 85, 86, 87, 45, 88, 31, 12, 13, 14, 32, 33, 34, 89])),
            "./pages/Home/components/HeroHome.tsx": () => fe(() =>
                import ("./HeroHome-DqrOOAs-.js"), __vite__mapDeps([81, 1, 4, 2, 7, 5, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 82])),
            "./pages/Home/components/KeyNumbersHome.tsx": () => fe(() =>
                import ("./KeyNumbersHome-B7tiPzhO.js"), __vite__mapDeps([83, 1, 5, 7, 4, 9, 18, 19, 20, 21, 22, 23, 24, 25, 26, 2, 27, 84])),
            "./pages/Home/components/UseCasesListing.tsx": () => fe(() =>
                import ("./UseCasesListing-CsM1ixH8.js"), __vite__mapDeps([85, 1, 4, 5, 7, 2, 9, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 86])),
            "./pages/Home/components/Values.tsx": () => fe(() =>
                import ("./Values-DYz5ZrGZ.js"), __vite__mapDeps([87, 1, 4, 5, 7, 2, 9, 45, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 88])),
            "./pages/Legal/DataPrivacy.tsx": () => fe(() =>
                import ("./DataPrivacy-MplkL4mZ.js"), __vite__mapDeps([90, 1, 91, 4, 37, 5, 7, 2, 9, 38, 92, 93, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 94])),
            "./pages/Legal/LegalNotices.tsx": () => fe(() =>
                import ("./LegalNotices-DeRJUZXx.js"), __vite__mapDeps([95, 1, 91, 4, 37, 5, 7, 2, 9, 38, 92, 93, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 94])),
            "./pages/Legal/PrivacyPolicy.tsx": () => fe(() =>
                import ("./PrivacyPolicy-DKhr23rS.js"), __vite__mapDeps([96, 1, 91, 4, 37, 5, 7, 2, 9, 38, 92, 93, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 94])),
            "./pages/Legal/SampleWithdrawalForm.tsx": () => fe(() =>
                import ("./SampleWithdrawalForm-mHSBWKZn.js"), __vite__mapDeps([97, 1, 91, 4, 37, 5, 7, 2, 9, 38, 92, 93, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 94])),
            "./pages/Legal/Terms/Sale.tsx": () => fe(() =>
                import ("./Sale-D-kzARLG.js"), __vite__mapDeps([98, 1, 91, 4, 37, 5, 7, 2, 9, 38, 92, 93, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 94])),
            "./pages/Legal/Terms/Use.tsx": () => fe(() =>
                import ("./Use-D-kzARLG.js"), __vite__mapDeps([99, 1, 91, 4, 37, 5, 7, 2, 9, 38, 92, 93, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 94])),
            "./pages/Legal/components/Layout.tsx": () => fe(() =>
                import ("./Layout-Dv-Tapsq.js"), __vite__mapDeps([91, 1, 4, 37, 5, 7, 2, 9, 38, 92, 93, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 94])),
            "./pages/News/Index.tsx": () => fe(() =>
                import ("./Index-B9rfX-Ay.js"), __vite__mapDeps([100, 1, 4, 7, 5, 2, 3, 6, 8, 9, 10, 32, 33, 39, 40, 41, 42, 43, 44, 45, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 101])),
            "./pages/News/Single.tsx": () => fe(() =>
                import ("./Single-CwvffSAa.js"), __vite__mapDeps([102, 1, 4, 2, 103, 12, 13, 14, 5, 7, 74, 104, 105, 9, 106, 107, 108, 76, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 77, 31, 32, 33, 34, 109])),
            "./pages/News/components/HeroNews.tsx": () => fe(() =>
                import ("./HeroNews-BOgEoWtr.js"), __vite__mapDeps([76, 1, 4, 7, 5, 2, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 77])),
            "./pages/News/components/LatestNews.tsx": () => fe(() =>
                import ("./LatestNews-B1hDNSTx.js"), __vite__mapDeps([78, 1, 2, 55, 4, 12, 13, 14, 5, 7, 32, 9, 33, 56, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27])),
            "./pages/News/components/NewsListing.tsx": () => fe(() =>
                import ("./NewsListing-BI1tBC0S.js"), __vite__mapDeps([31, 1, 4, 12, 13, 14, 5, 7, 2, 32, 9, 33, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 34])),
            "./pages/Offers/Index.tsx": () => fe(() =>
                import ("./Index-Bm-ae8Uv.js"), __vite__mapDeps([110, 1, 4, 5, 7, 2, 37, 9, 38, 39, 40, 41, 42, 45, 111, 12, 13, 14, 106, 74, 104, 105, 107, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 112, 113])),
            "./pages/Offers/Single.tsx": () => fe(() =>
                import ("./Single-CDVdRrM4.js"), __vite__mapDeps([114, 1, 4, 2, 37, 5, 7, 9, 38, 115, 74, 116, 103, 12, 13, 14, 104, 105, 106, 107, 108, 117, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 118, 119])),
            "./pages/Offers/components/Methodology.tsx": () => fe(() =>
                import ("./Methodology-CVGhRYv3.js"), __vite__mapDeps([117, 1, 4, 12, 13, 14, 5, 7, 18, 19, 20, 21, 22, 23, 24, 25, 26, 2, 27, 118])),
            "./pages/Offers/components/OfferCategory.tsx": () => fe(() =>
                import ("./OfferCategory-DAnEQupo.js"), __vite__mapDeps([111, 1, 12, 4, 13, 14, 5, 7, 2, 106, 74, 104, 105, 9, 107, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 112])),
            "./pages/Press/Index.tsx": () => fe(() =>
                import ("./Index-DfPqyTSm.js"), __vite__mapDeps([120, 1, 4, 7, 5, 2, 45, 15, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 121])),
            "./pages/Research/Research.tsx": () => fe(() =>
                import ("./Research-Eu99NAey.js"), __vite__mapDeps([122, 1, 4, 92, 2, 7, 5, 9, 93, 123, 124, 125, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 126, 127])),
            "./pages/Research/components/ResearchContent.tsx": () => fe(() =>
                import ("./ResearchContent-DS_5BWPo.js"), __vite__mapDeps([123, 1, 4, 2, 124])),
            "./pages/Research/components/ResearchLinks.tsx": () => fe(() =>
                import ("./ResearchLinks-DEjc8Ybg.js"), __vite__mapDeps([125, 1, 4, 18, 19, 20, 21, 22, 23, 24, 5, 7, 25, 26, 2, 27, 126])),
            "./pages/UseCases/Index.tsx": () => fe(() =>
                import ("./Index-BWKH0T0u.js"), __vite__mapDeps([128, 1, 2, 37, 4, 5, 7, 9, 38, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 129])),
            "./pages/UseCases/Single.tsx": () => fe(() =>
                import ("./Single-Cv--2wTM.js"), __vite__mapDeps([130, 1, 4, 2, 37, 5, 7, 9, 38, 115, 74, 116, 13, 103, 12, 14, 104, 105, 106, 107, 108, 131, 132, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 133])),
            "./pages/UseCases/components/Quote.tsx": () => fe(() =>
                import ("./Quote-Zh4nVDVR.js"), __vite__mapDeps([131, 1, 4, 132])),
            "./pages/WebglSandbox/Index.tsx": () => fe(() =>
                import ("./Index-CkHLZKhE.js"), __vite__mapDeps([134, 1, 74, 3, 4, 5, 2, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 106, 104, 105, 107, 63, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 64, 135]))
        }));
        return e.default.layout = e.default.layout || (t => $.jsx(gv, {
            children: t
        })), e
    },
    setup({
        el: n,
        App: e,
        props: t
    }) {
        const r = Gu(n);
        window.history.state || window.history.replaceState({
            scrollRegions: []
        }, ""), r.render($.jsx(Xu, {
            locale: t.initialPage.props.locale,
            fallbackLocale: "en",
            files: Object.assign({
                "/lang/php_de.json": qu,
                "/lang/php_en.json": Yu,
                "/lang/php_es.json": Zu,
                "/lang/php_et.json": Ju,
                "/lang/php_fr.json": Qu,
                "/lang/php_it.json": ec,
                "/lang/php_nl.json": tc
            }),
            children: $.jsx(e, { ...t
            })
        }))
    },
    progress: {
        color: "#4B5563"
    }
});
export {
    kh as $, Oi as C, ms as F, _n as I, Xn as S, bi as T, Ii as _, on as a, tr as b, pt as c, RD as d, Ni as e, ih as f, Lh as g, _h as h, yh as i, xh as j, xD as k, v0 as l, fi as m, ks as n, Ki as o, yr as s, dn as u
};